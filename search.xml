<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis 的击穿，穿透，雪崩，分布式锁，缓存一致性</title>
    <url>/posts/dcfaa904/</url>
    <content><![CDATA[<h5 id="1-Redis-的击穿，穿透，雪崩"><a href="#1-Redis-的击穿，穿透，雪崩" class="headerlink" title="1. Redis 的击穿，穿透，雪崩"></a>1. Redis 的击穿，穿透，雪崩</h5><h6 id="1-1-Redis-击穿"><a href="#1-1-Redis-击穿" class="headerlink" title="1.1 Redis 击穿"></a>1.1 Redis 击穿</h6><p><strong>产生原因</strong>：在高并发的情况下，在某一时间点，<strong>在高频获取的key在此时过期，大量请求直接请求到服务器上</strong>，导致缓存击穿</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>可以将<strong>热点数据设置为永远不过期</strong>；</p>
</li>
<li><p>基于 <strong>redis</strong> or <strong>zookeeper</strong> 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p>
<blockquote>
<p>redis的分布式锁主要是通过  setnx 命令，设置锁的过期时间，只有返回是ok的才能去数据库中获取数据</p>
<p><strong>产生问题</strong>：在db端超时导致锁过期 </p>
<p><strong>解决方案</strong>： 通过<strong>zookeeper</strong> 实现分布式锁</p>
</blockquote>
</li>
</ul>
<h6 id="1-2-Redis穿透"><a href="#1-2-Redis穿透" class="headerlink" title="1.2 Redis穿透"></a>1.2 Redis穿透</h6><p>  一般是出现这种情况是因为恶意频繁查询才会对系统造成很大的问题: <strong>key缓存并且数据库不存在</strong>，所以<strong>每次查询都会查询数据库从而导致数据库崩溃</strong>。</p>
<p><strong>解决方案：</strong>使用布隆过滤器</p>
<blockquote>
<p>布隆过滤器缺点：只能增加不能删除</p>
<p>可使用布谷鸟过滤器 ，设置空key</p>
</blockquote>
<h6 id="1-3-Redis雪崩"><a href="#1-3-Redis雪崩" class="headerlink" title="1.3 Redis雪崩"></a>1.3 Redis雪崩</h6><p>雪崩指的是<strong>多个key</strong>查询并且出现<strong>高并发</strong>，缓存中失效或者查不到，然后都去db查询，从而导致db压力突然飙升，从而崩溃。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p> 时点性无关:<strong>均匀的设计过期时间</strong></p>
</li>
<li><p>时点性有关:<strong>强依赖击穿的方案</strong></p>
<p>​                    也可在<strong>程序设计的时候在业务层进行时点进行请求延时操作</strong></p>
<p>​                    当知道<strong>时点之后的数据也可以进行预加载工作</strong></p>
</li>
<li><p>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</p>
</li>
<li><p> 事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</p>
</li>
<li><p>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</p>
<blockquote>
<p>时点性有关指<strong>某一个时间段某些key必须要过期使用新数据</strong></p>
</blockquote>
</li>
</ul>
<h5 id="2-Redis-的分布式锁实现"><a href="#2-Redis-的分布式锁实现" class="headerlink" title="2. Redis  的分布式锁实现"></a>2. Redis  的分布式锁实现</h5><p>最好是使用zookeeper实现分布式锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原理需要三个关键元素</span><br><span class="line">1. setnx</span><br><span class="line">2.过期时间</span><br><span class="line">3.多线程（守护进程），延长过期</span><br></pre></td></tr></table></figure>

<h6 id="2-1-Redis加锁实现"><a href="#2-1-Redis加锁实现" class="headerlink" title="2.1 Redis加锁实现"></a>2.1 Redis加锁实现</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">&quot;NX&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">&quot;PX&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-redis-解锁代码"><a href="#2-2-redis-解锁代码" class="headerlink" title="2.2 redis 解锁代码"></a>2.2 redis 解锁代码</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Redis的弊端"><a href="#Redis的弊端" class="headerlink" title="Redis的弊端"></a>Redis的弊端</h6><ul>
<li>数据库事务超时，导致锁过期</li>
<li><code>redis cluster</code>集群环境下，假如现在<code>A客户端</code>想要加锁，它会根据路由规则选择一台<code>master</code>节点写入<code>key</code> <code>mylock</code>，在加锁成功后，<code>master</code>节点会把<code>key</code>异步复制给对应的<code>slave</code>节点。如果此时<code>redis master</code>节点宕机，为保证集群可用性，会进行<code>主备切换</code>，<code>slave</code>变为了<code>redis master</code>。<code>B客户端</code>在新的<code>master</code>节点上加锁成功，而<code>A客户端</code>也以为自己还是成功加了锁的。此时就会导致同一时间内多个客户端对一个分布式锁完成了加锁，导致各种脏数据的产生。</li>
</ul>
<h5 id="Redis-缓存一致性"><a href="#Redis-缓存一致性" class="headerlink" title="Redis 缓存一致性"></a>Redis 缓存一致性</h5><h6 id="出现场景"><a href="#出现场景" class="headerlink" title="出现场景"></a>出现场景</h6><p>在<strong>高并发的情况</strong>下涉及到数据更新：数据库和缓存更新，就容易出现<strong>缓存(Redis)和数据库（MySQL）间的数据一致性问题</strong>。</p>
<p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：</p>
<p>1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p>
<p>2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p>
<p>因为<strong>写和读是并发</strong>的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。</p>
<h6 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h6><p><strong>1.第一种方案：采用延时双删策略</strong></p>
<p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line"> redis.delKey(key);</span><br><span class="line"> db.updateData(data);</span><br><span class="line"> Thread.sleep(<span class="number">500</span>);</span><br><span class="line"> redis.delKey(key);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体的步骤就是：</strong></p>
<ul>
<li>先删除缓存；</li>
<li>再写数据库；</li>
<li>休眠500毫秒；</li>
<li>再次删除缓存</li>
</ul>
<p><strong>该方案的弊端</strong></p>
<p>结合<strong>双删策略+缓存超时设置</strong>，这样<strong>最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</strong></p>
<p><strong>2、第二种方案：异步更新缓存(基于订阅binlog的同步机制)</strong></p>
<p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p>
<ul>
<li><strong>读Redis</strong>：热数据基本都在Redis</li>
<li><strong>写MySQL</strong>:增删改都是操作MySQL</li>
<li><strong>更新Redis数据</strong>：MySQ的数据操作binlog，来更新到Redis</li>
</ul>
<p><strong>1）数据操作主要分为两大块：</strong></p>
<ul>
<li>一个是全量(将全部数据一次写入到redis)</li>
<li>一个是增量（实时更新）</li>
</ul>
<p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p>
<p><strong>2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</strong></p>
<p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p>
<p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p>
<p><strong>消息推送工具</strong>你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>win10的typora配置gitee云图床</title>
    <url>/posts/fd71e1c8/</url>
    <content><![CDATA[<h5 id="1-相关准备准备"><a href="#1-相关准备准备" class="headerlink" title="1.相关准备准备"></a>1.相关准备准备</h5><ul>
<li><a href="https://www.typora.io/">Typora</a></li>
<li><a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a></li>
<li>gitee/github账号</li>
</ul>
<h5 id="2-gitee-github相关配置"><a href="#2-gitee-github相关配置" class="headerlink" title="2. gitee/github相关配置"></a>2. gitee/github相关配置</h5><ol>
<li><p>新建仓库（<strong>一定要是公开的，不然md到时候无法访问</strong>）</p>
</li>
<li><p>生成Token ，<strong>保存Token</strong></p>
<p> 在自已的用户中心生成私人令牌</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224175635.png" alt="image-20210224175635044"></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224175714.png" alt="image-20210224175714200"></p>
</li>
</ol>
<h5 id="3-PicGO相关配置"><a href="#3-PicGO相关配置" class="headerlink" title="3. PicGO相关配置"></a>3. PicGO相关配置</h5><h6 id="3-1-GitHub设置"><a href="#3-1-GitHub设置" class="headerlink" title="3.1 GitHub设置"></a>3.1 GitHub设置</h6><p><a href="https://blog.csdn.net/yefcion/article/details/88412025">原文地址</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224180016.png" alt="image-20210224180016463"></p>
<ul>
<li>仓库名 即你的仓库名</li>
<li>分支名 默认 <code>master</code></li>
<li>Token 就是刚刚复制的那一串字符</li>
<li>存储路径 这个可以填也可以不填，填了的话图片就上传到 git 中 <code>data</code> 这个文件夹</li>
<li>域名 <code>https://raw.githubusercontent.com/yefcion/cloudimg/master</code>这个要改一下 格式 <code>https://raw.githubusercontent.com/[username]/[仓库名]/master</code></li>
</ul>
<h6 id="3-2-Gitee设置"><a href="#3-2-Gitee设置" class="headerlink" title="3.2 Gitee设置"></a>3.2 Gitee设置</h6><ol>
<li><p>下载插件gitee-uploader</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224180247.png" alt="image-20210224180247392"></p>
</li>
<li><p>设置Gitee并设置为默认图床（Github是外网，可能会慢，故选择gitee为默认）</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224195106.png" alt="image-20210224195106781"></p>
</li>
</ol>
<h6 id="3-3-PicGO设置"><a href="#3-3-PicGO设置" class="headerlink" title="3.3 PicGO设置"></a>3.3 PicGO设置</h6><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224195211.png" alt="image-20210224195211867"></p>
<h5 id="4-Typora设置"><a href="#4-Typora设置" class="headerlink" title="4.Typora设置"></a>4.Typora设置</h5><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224195433.png" alt="image-20210224195433511"></p>
]]></content>
      <categories>
        <category>Typora</category>
        <category>Gitee</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Gitee</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性协议——Zab算法</title>
    <url>/posts/b369a3b6/</url>
    <content><![CDATA[<h1 id="Zab算法描述"><a href="#Zab算法描述" class="headerlink" title="Zab算法描述"></a>Zab算法描述</h1><p>Zab协议 的全称是 <strong>Zookeeper Atomic Broadcast</strong> （Zookeeper原子广播）。</p>
<p><strong>Zookeeper 是通过 Zab 协议来保证分布式事务的最终一致性</strong>。</p>
<ol>
<li>Zab协议是为分布式协调服务Zookeeper专门设计的一种 <strong>支持崩溃恢复</strong> 的 <strong>原子广播协议</strong> ，是Zookeeper保证数据一致性的核心算法。Zab借鉴了Paxos算法，但又不像Paxos那样，是一种通用的分布式一致性算法。<strong>它是特别为Zookeeper设计的支持崩溃恢复的原子广播协议</strong>。</li>
<li>在Zookeeper中主要依赖Zab协议来实现数据一致性，基于该协议，zk实现了一种主备模型（即Leader和Follower模型）的系统架构来保证集群中各个副本之间数据的一致性。<br> 这里的主备系统架构模型，就是指只有一台客户端（Leader）负责处理外部的写事务请求，然后Leader客户端将数据同步到其他Follower节点。</li>
</ol>
<p>Zookeeper 客户端会随机的链接到 zookeeper 集群中的一个节点，如果是<font color=red>读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交</font>。</p>
<h1 id="Zab-协议的特性："><a href="#Zab-协议的特性：" class="headerlink" title="Zab 协议的特性："></a><strong>Zab 协议的特性</strong>：</h1><p>1）Zab 协议需要确保那些<strong>已经在 Leader 服务器上提交（Commit）的事务最终被所有的服务器提交</strong>。</p>
<p>2）Zab 协议需要确保<strong>丢弃那些只在 Leader 上被提出而没有被提交的事务</strong>。</p>
<h1 id="Zab-协议的作用"><a href="#Zab-协议的作用" class="headerlink" title="Zab 协议的作用"></a>Zab 协议的作用</h1><ol>
<li><p><strong>使用一个单一的主进程（Leader）来接收并处理客户端的事务请求</strong>（也就是写请求），并采用了Zab的原子广播协议，将服务器数据的状态变更以 <strong>事务proposal</strong> （事务提议）的形式广播到所有的副本（Follower）进程上去。</p>
</li>
<li><p><strong>保证一个全局的变更序列被顺序引用</strong>。<br> Zookeeper是一个树形结构，很多操作都要先检查才能确定是否可以执行，比如P1的事务t1可能是创建节点”/a”，t2可能是创建节点”/a/bb”，只有先创建了父节点”/a”，才能创建子节点”/a/b”。</p>
<p> 为了保证这一点，Zab要保证同一个Leader发起的事务要按顺序被apply，同时还要保证只有先前Leader的事务被apply之后，新选举出来的Leader才能再次发起事务。</p>
</li>
<li><p><strong>当主进程出现异常的时候，整个zk集群依旧能正常工作</strong>。</p>
</li>
</ol>
<h2 id="Zab协议原理"><a href="#Zab协议原理" class="headerlink" title="Zab协议原理"></a>Zab协议原理</h2><p>Zab协议要求每个 Leader 都要经历三个阶段：<strong>发现，同步，广播</strong>。</p>
<ul>
<li><strong>发现</strong>：要求zookeeper集群必须选举出一个 Leader 进程，同时 Leader 会维护一个 Follower 可用客户端列表。将来客户端可以和这些 Follower节点进行通信。</li>
<li><strong>同步</strong>：Leader 要负责将本身的数据与 Follower 完成同步，做到多副本存储。这样也是提现了CAP中的高可用和分区容错。Follower将队列中未处理完的请求消费完成后，写入本地事务日志中。</li>
<li><strong>广播</strong>：Leader 可以接受客户端新的事务Proposal请求，将新的Proposal请求广播给所有的 Follower。</li>
</ul>
<h2 id="Zab协议核心"><a href="#Zab协议核心" class="headerlink" title="Zab协议核心"></a>Zab协议核心</h2><p>Zab协议的核心：<strong>定义了事务请求的处理方式</strong></p>
<p>1）所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被叫做 <strong>Leader服务器</strong>。其他剩余的服务器则是 <strong>Follower服务器</strong>。</p>
<p>2）Leader服务器 负责将一个客户端事务请求，转换成一个 <strong>事务Proposal</strong>，并将该 Proposal 分发给集群中所有的 Follower 服务器，也就是向所有 Follower 节点发送数据广播请求（或数据复制）</p>
<p>3）分发之后Leader服务器需要等待所有Follower服务器的反馈（Ack请求），<strong>在Zab协议中，只要超过半数的Follower服务器进行了正确的反馈</strong>后（也就是收到半数以上的Follower的Ack请求），那么 Leader 就会再次向所有的 Follower服务器发送 Commit 消息，要求其将上一个 事务proposal 进行提交。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302165537.png" alt="image-20210302165537904"></p>
<h2 id="Zab协议内容"><a href="#Zab协议内容" class="headerlink" title="Zab协议内容"></a>Zab协议内容</h2><p>Zab 协议包括两种基本的模式：<strong>崩溃恢复</strong> 和 <strong>消息广播</strong></p>
<h3 id="Zab协议内容-1"><a href="#Zab协议内容-1" class="headerlink" title="Zab协议内容"></a>Zab协议内容</h3><h4 id="协议过程"><a href="#协议过程" class="headerlink" title="协议过程"></a>协议过程</h4><p>当整个集群启动过程中，或者当 Leader 服务器出现网络中弄断、崩溃退出或重启等异常时，Zab协议就会 <strong>进入崩溃恢复模式</strong>，选举产生新的Leader。</p>
<p>当选举产生了新的 Leader，同时集群中有过半的机器与该 Leader 服务器完成了状态同步（即数据同步）之后，Zab协议就会退出崩溃恢复模式，<strong>进入消息广播模式</strong>。</p>
<p>这时，如果有一台遵守Zab协议的服务器加入集群，因为此时集群中已经存在一个Leader服务器在广播消息，那么该新加入的服务器自动进入恢复模式：找到Leader服务器，并且完成数据同步。同步完成后，作为新的Follower一起参与到消息广播流程中。</p>
<h4 id="协议状态切换"><a href="#协议状态切换" class="headerlink" title="协议状态切换"></a>协议状态切换</h4><p>当Leader出现崩溃退出或者机器重启，亦或是集群中不存在超过半数的服务器与Leader保存正常通信，Zab就会再一次进入崩溃恢复，发起新一轮Leader选举并实现数据同步。同步完成后又会进入消息广播模式，接收事务请求。</p>
<h4 id="保证消息有序"><a href="#保证消息有序" class="headerlink" title="保证消息有序"></a>保证消息有序</h4><p>在整个消息广播中，Leader会将每一个事务请求转换成对应的 proposal 来进行广播，并且在广播 事务Proposal 之前，Leader服务器会首先为这个事务Proposal分配一个全局单递增的唯一ID，称之为事务ID（即zxid），由于Zab协议需要保证每一个消息的严格的顺序关系，因此必须将每一个proposal按照其zxid的先后顺序进行排序和处理。</p>
<h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><ol>
<li><p>在zookeeper集群中，数据副本的传递策略就是采用消息广播模式。zookeeper中农数据副本的同步方式与二段提交相似，但是却又不同。二段提交要求协调者必须等到所有的参与者全部反馈ACK确认消息后，再发送commit消息。要求所有的参与者要么全部成功，要么全部失败。二段提交会产生严重的阻塞问题。</p>
</li>
<li><p>Zab协议中 Leader 等待 Follower 的ACK反馈消息是指“只要半数以上的Follower成功反馈即可，不需要收到全部Follower反馈”</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302170013.png" alt="消息广播流程图"></p>
</li>
</ol>
<h4 id="消息广播具体步骤"><a href="#消息广播具体步骤" class="headerlink" title="消息广播具体步骤"></a>消息广播具体步骤</h4><ol>
<li>客户端发起一个写操作请求。</li>
<li>Leader 服务器将客户端的请求转化为事务 Proposal 提案，同时为每个 Proposal 分配一个全局的ID，即zxid。</li>
<li>Leader 服务器为每个 Follower 服务器分配一个单独的队列，然后将需要广播的 Proposal 依次放到队列中取，并且根据 FIFO 策略进行消息发送。</li>
<li>Follower 接收到 Proposal 后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向 Leader 反馈一个 Ack 响应消息。</li>
<li>Leader 接收到超过半数以上 Follower 的 Ack 响应消息后，即认为消息发送成功，可以发送 commit 消息。</li>
<li>Leader 向所有 Follower 广播 commit 消息，同时自身也会完成事务提交。Follower 接收到 commit 消息后，会将上一条事务提交。</li>
</ol>
<p><strong>zookeeper 采用 Zab 协议的核心，就是只要有一台服务器提交了 Proposal，就要确保所有的服务器最终都能正确提交 Proposal。这也是 CAP/BASE 实现最终一致性的一个体现。</strong></p>
<p><strong>Leader 服务器与每一个 Follower 服务器之间都维护了一个单独的 FIFO 消息队列进行收发消息，使用队列消息可以做到异步解耦。 Leader 和 Follower 之间只需要往队列中发消息即可。如果使用同步的方式会引起阻塞，性能要下降很多。</strong></p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p><strong>一旦 Leader 服务器出现崩溃或者由于网络原因导致 Leader 服务器失去了与过半 Follower 的联系，那么就会进入崩溃恢复模式。</strong></p>
<p>在 Zab 协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的 Leader 服务器。因此 Zab 协议需要一个高效且可靠的 Leader 选举算法，从而确保能够快速选举出新的 Leader 。</p>
<p>Leader 选举算法不仅仅需要让 Leader 自己知道自己已经被选举为 Leader ，同时还需要让集群中的所有其他机器也能够快速感知到选举产生的新 Leader 服务器。</p>
<p>崩溃恢复主要包括两部分：<strong>Leader选举</strong> 和 <strong>数据恢复</strong></p>
<h4 id="Zab-协议保证数据一致性"><a href="#Zab-协议保证数据一致性" class="headerlink" title="Zab 协议保证数据一致性"></a>Zab 协议保证数据一致性</h4><p><strong>Zab 协议崩溃恢复要求满足以下两个要求</strong>：</p>
<ol>
<li><p><strong>确保已经被 Leader 提交的 Proposal 必须最终被所有的 Follower 服务器提交</strong>。</p>
</li>
<li><p><strong>确保丢弃已经被 Leader 提出的但是没有被提交的 Proposal</strong>。</p>
</li>
</ol>
<p>根据上述要求</p>
<p>Zab协议需要保证选举出来的Leader需要满足以下条件：</p>
<ol>
<li><p><strong>新选举出来的 Leader 不能包含未提交的 Proposal</strong> 。</p>
<p> 即新选举的 Leader 必须都是已经提交了 Proposal 的 Follower 服务器节点。</p>
</li>
<li><p><strong>新选举的 Leader 节点中含有最大的 zxid</strong> 。<br> 这样做的好处是可以避免 Leader 服务器检查 Proposal 的提交和丢弃工作。</p>
</li>
</ol>
<h4 id="Zab-数据同步"><a href="#Zab-数据同步" class="headerlink" title="Zab 数据同步"></a>Zab 数据同步</h4><ol>
<li>完成 Leader 选举后（新的 Leader 具有最高的zxid），在正式开始工作之前（接收事务请求，然后提出新的 Proposal），Leader 服务器会首先确认事务日志中的所有的 Proposal 是否已经被集群中过半的服务器 Commit。</li>
<li>Leader 服务器需要确保所有的 Follower 服务器能够接收到每一条事务的 Proposal ，并且能将所有已经提交的事务 Proposal 应用到内存数据中。等到 Follower 将所有尚未同步的事务 Proposal 都从 Leader 服务器上同步过啦并且应用到内存数据中以后，Leader 才会把该 Follower 加入到真正可用的 Follower 列表中。</li>
</ol>
<h4 id="Zab-数据同步过程中，如何处理需要丢弃的-Proposal"><a href="#Zab-数据同步过程中，如何处理需要丢弃的-Proposal" class="headerlink" title="Zab 数据同步过程中，如何处理需要丢弃的 Proposal"></a>Zab 数据同步过程中，如何处理需要丢弃的 Proposal</h4><p>在 Zab 的事务编号 zxid 设计中，zxid是一个64位的数字。</p>
<p>其中低32位可以看成一个简单的单增计数器，针对客户端每一个事务请求，Leader 在产生新的 Proposal 事务时，都会对该计数器加1。而<font color=red>高32位则代表了 Leader 周期的 epoch 编号</font>。</p>
<blockquote>
<p>epoch 编号可以理解为当前集群所处的年代，或者周期。每次Leader变更之后都会在 epoch 的基础上加1，这样旧的 Leader 崩溃恢复之后，其他Follower 也不会听它的了，因为 Follower 只服从epoch最高的 Leader 命令。</p>
</blockquote>
<p>每当选举产生一个新的 Leader ，就会从这个 <font color=red>Leader 服务器上取出本地事务日志充最大编号 Proposal 的 zxid，并从 zxid 中解析得到对应的 epoch 编号，然后再对其加1，之后该编号就作为新的 epoch 值，并将低32位数字归零，由0开始重新生成zxid</font>。</p>
<p><strong>Zab 协议通过 epoch 编号来区分 Leader 变化周期</strong>，能够有效避免不同的 Leader 错误的使用了相同的 zxid 编号提出了不一样的 Proposal 的异常情况。</p>
<h1 id="Zab实现原理"><a href="#Zab实现原理" class="headerlink" title="Zab实现原理"></a>Zab实现原理</h1><p><strong>Zab 节点有三种状态</strong>：</p>
<ul>
<li>Following：当前节点是跟随者，服从 Leader 节点的命令。</li>
<li>Leading：当前节点是 Leader，负责协调事务。</li>
<li>Election/Looking：节点处于选举状态，正在寻找 Leader。</li>
</ul>
<p>代码实现中，多了一种状态：Observing 状态<br>这是 Zookeeper 引入 Observer 之后加入的，Observer 不参与选举，是只读节点，跟 Zab 协议没有关系。</p>
<p><strong>节点的持久状态</strong>：</p>
<ul>
<li>history：当前节点接收到事务 Proposal 的Log</li>
<li>acceptedEpoch：Follower 已经接受的 Leader 更改 epoch 的 newEpoch 提议。</li>
<li>currentEpoch：当前所处的 Leader 年代</li>
<li>lastZxid：history 中最近接收到的Proposal 的 zxid（最大zxid）</li>
</ul>
<h2 id="Zab-的四个阶段"><a href="#Zab-的四个阶段" class="headerlink" title="Zab 的四个阶段"></a>Zab 的四个阶段</h2><h3 id="选举阶段（Leader-Election"><a href="#选举阶段（Leader-Election" class="headerlink" title="选举阶段（Leader Election"></a>选举阶段（Leader Election</h3><p>节点在一开始都处于选举节点，只要有一个节点得到超过半数节点的票数，它就可以当选准 Leader，只有到达第三个阶段（也就是同步阶段），这个准 Leader 才会成为真正的 Leader。<strong>Zookeeper 规定所有有效的投票都必须在同一个 轮次 中，每个服务器在开始新一轮投票时，都会对自己维护的 logicalClock 进行自增操作</strong>。</p>
<p>每个服务器在广播自己的选票前，会将自己的投票箱（recvset）清空。该投票箱记录了所受到的选票。</p>
<p>例如：Server_2 投票给 Server_3，Server_3 投票给 Server_1，则Server_1的投票箱为(2,3)、(3,1)、(1,1)。（每个服务器都会默认给自己投票）</p>
<p>前一个数字表示投票者，后一个数字表示被选举者。票箱中只会记录每一个投票者的最后一次投票记录，如果投票者更新自己的选票，则其他服务器收到该新选票后会在自己的票箱中更新该服务器的选票。</p>
<p><strong>这一阶段的目的就是为了选出一个准 Leader ，然后进入下一个阶段。</strong></p>
<p>协议并没有规定详细的选举算法，后面会提到实现中使用的 Fast Leader Election。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302171418.png" alt="选举流程"></p>
<h3 id="发现阶段（Descovery）"><a href="#发现阶段（Descovery）" class="headerlink" title="发现阶段（Descovery）"></a>发现阶段（Descovery）</h3><p>在这个阶段，Followers 和上一轮选举出的准 Leader 进行通信，同步 Followers 最近接收的事务 Proposal 。</p>
<p>一个 Follower 只会连接一个 Leader，如果一个 Follower 节点连接另一个 Follower 节点，则会在尝试连接时被拒绝。被拒绝之后，该节点就会进入 Leader Election阶段。</p>
<p><strong>这个阶段的主要目的是发现当前大多数节点接收的最新 Proposal，并且准 Leader 生成新的 epoch ，让 Followers 接收，更新它们的 acceptedEpoch</strong>。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302171535.png" alt="发现流程"></p>
<h3 id="同步阶段（Synchronization）"><a href="#同步阶段（Synchronization）" class="headerlink" title="同步阶段（Synchronization）"></a>同步阶段（Synchronization）</h3><p><strong>同步阶段主要是利用 Leader 前一阶段获得的最新 Proposal 历史，同步集群中所有的副本</strong>。<br>只有当 quorum（超过半数的节点） 都同步完成，准 Leader 才会成为真正的 Leader。Follower 只会接收 zxid 比自己 lastZxid 大的 Proposal。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302171702.png" alt="同步流程"></p>
<h3 id="广播阶段（Broadcast）"><a href="#广播阶段（Broadcast）" class="headerlink" title="广播阶段（Broadcast）"></a>广播阶段（Broadcast）</h3><p>到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 Leader 可以进行消息广播。同时，如果有新的节点加入，还需要对新节点进行同步。</p>
<p>需要注意的是，Zab 提交事务并不像 2PC 一样需要全部 Follower 都 Ack，只需要得到 quorum（超过半数的节点）的Ack 就可以。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302171740.png" alt="广播流程"></p>
<h1 id="Zab协议实现"><a href="#Zab协议实现" class="headerlink" title="Zab协议实现"></a>Zab协议实现</h1><p>选举阶段使用 java版本实现的是Fast Leader Election算法，实际的实现将<strong>发现和同步阶段合并为 Recovery Phase（恢复阶段）</strong>，所以，Zab 的实现实际上有三个阶段。</p>
<p>Zab协议三个阶段：</p>
<ol>
<li><strong>选举（Fast Leader Election）</strong></li>
<li><strong>恢复（Recovery Phase）</strong></li>
<li><strong>广播（Broadcast Phase）</strong></li>
</ol>
<h2 id="Fast-Leader-Election（快速选举）"><a href="#Fast-Leader-Election（快速选举）" class="headerlink" title="Fast Leader Election（快速选举）"></a>Fast Leader Election（快速选举）</h2><p> FLE 会选举拥有最新Proposal history （lastZxid最大）的节点作为 Leader，这样就省去了发现最新提议的步骤。<strong>这是基于拥有最新提议的节点也拥有最新的提交记录</strong></p>
<h3 id="成为-Leader-的条件："><a href="#成为-Leader-的条件：" class="headerlink" title="成为 Leader 的条件："></a>成为 Leader 的条件：</h3><ol>
<li>选 epoch 最大的</li>
<li>若 epoch 相等，选 zxid 最大的</li>
<li>若 epoch 和 zxid 相等，选择 server_id 最大的（<strong>zoo.cfg中的myid</strong>）</li>
</ol>
<p>节点在选举开始时，都默认投票给自己，当接收其他节点的选票时，会根据上面的 <strong>Leader条件</strong> 判断并且更改自己的选票，然后重新发送选票给其他节点。<strong>当有一个节点的得票超过半数，该节点会设置自己的状态为 Leading ，其他节点会设置自己的状态为 Following</strong>。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302172451.png" alt="选举过程"></p>
<h2 id="Recovery-Phase（恢复阶段）"><a href="#Recovery-Phase（恢复阶段）" class="headerlink" title="Recovery Phase（恢复阶段）"></a>Recovery Phase（恢复阶段）</h2><p>这一阶段 Follower 发送他们的 <strong>lastZxid</strong> 给 Leader，Leader 根据 lastZxid 决定如何同步数据。这里的实现跟前面的 Phase 2 有所不同：Follower 收到 TRUNC 指令会终止L.lastCommitedZxid 之后的 Proposal ，收到 DIFF 指令会接收新的 Proposal。</p>
<blockquote>
<p>history.lastCommitedZxid：最近被提交的 Proposal zxid</p>
<p>history.oldThreshold：被认为已经太旧的已经提交的 Proposal zxid</p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302172728.png" alt="恢复阶段"></p>
<h1 id="Zab特殊情况下需要解决的两个问题："><a href="#Zab特殊情况下需要解决的两个问题：" class="headerlink" title="Zab特殊情况下需要解决的两个问题："></a>Zab特殊情况下需要解决的两个问题：</h1><h2 id="已经被处理的事务请求（proposal）不能丢（commit的）"><a href="#已经被处理的事务请求（proposal）不能丢（commit的）" class="headerlink" title="已经被处理的事务请求（proposal）不能丢（commit的）"></a>已经被处理的事务请求（proposal）不能丢（commit的）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当 leader 收到合法数量 follower 的 ACKs 后，就向各个 follower 广播 COMMIT 命令，同时也会在本地执行 COMMIT 并向连接的客户端返回「成功」。但是如果在各个 follower 在收到COMMIT 命令前 leader 就挂了，导致剩下的服务器并没有执行都这条消息。</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ol>
<li><p>选举拥有 proposal 最大值（即 zxid 最大） 的节点作为新的 leader。</p>
<blockquote>
<p>由于所有提案被 COMMIT 之前必须有<font color=red>合法数量的 follower ACK，即必须有合法数量的服务器的事务日志上有该提案的 proposal</font>，因此，zxid最大也就是数据最新的节点保存了所有被 COMMIT 消息的 proposal 状态。</p>
</blockquote>
</li>
<li><p>新的 leader 将自己事务日志中 proposal 但未 COMMIT 的消息处理。</p>
</li>
<li><p>新的 leader 与 follower 建立先进先出的队列， 先将自身有而 follower 没有的 proposal</p>
<p> 发送给 follower，再将这些 proposal 的 COMMIT 命令发送给 follower，以保证所有的</p>
<p> follower 都保存了所有的 proposal、所有的 follower 都处理了所有的消息</p>
</li>
</ol>
<h2 id="没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？"><a href="#没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？" class="headerlink" title="没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？"></a>没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>当 leader 接收到消息请求生成 proposal 后就挂了，其他 follower 并没有收到此 proposal，因此经过恢复模式重新选了 leader 后，这条消息是被跳过的。 此时，之前挂了的 leader 重新启动并注册成了 follower，他保留了被跳过消息的 proposal 状态，与整个系统的状态是不一致的，需要将其删除。</p>
<h3 id="解决方式-1"><a href="#解决方式-1" class="headerlink" title="解决方式"></a>解决方式</h3><p><strong>Zab 通过巧妙的设计 zxid 来实现这一目的。</strong></p>
<p>一个 zxid 是64位，高 32 是纪元（epoch）编号，每经过一次 leader 选举产生一个新的 leader，新 leader 会将 epoch 号 +1。低 32 位是消息计数器，每接收到一条消息这个值 +1，新 leader 选举后这个值重置为 0。</p>
<p>这样设计的好处是旧的 leader 挂了后重启，它不会被选举为 leader，因为此时它的 zxid 肯定小于当前的新 leader。当旧的 leader 作为 follower 接入新的 leader 后，新的 leader 会让它将所有的拥有旧的 epoch 号的未被 COMMIT 的 proposal 清除。</p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
        <category>Zab</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
        <tag>ZAB</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性协议——paxos算法</title>
    <url>/posts/fe45d335/</url>
    <content><![CDATA[<h1 id="paxos目的"><a href="#paxos目的" class="headerlink" title="paxos目的"></a>paxos目的</h1><p>Paxos算法是<font color=red>基于消息传递且具有高度容错特性的一致性算法</font>，是目前公认的解决分布式一致性问题最有效的算法之一，其<font color=red>解决的问题就是在分布式系统中如何就某个值（决议）达成一致</font>。</p>
<p>Paxos算法的前提假设是不存在拜占庭将军问题，即： <font color=red>信道是安全的（信道可靠），发出的信号不会被篡改，因为Paxos算法是基于消息传递的</font>。：如下图所示</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302154508.png" alt="image-20210302154508699"></p>
<h1 id="paxos算法角色划分：三种类型"><a href="#paxos算法角色划分：三种类型" class="headerlink" title="paxos算法角色划分：三种类型"></a>paxos算法角色划分：三种类型</h1><ul>
<li><p>提议者（Proposer）：提出提案；</p>
</li>
<li><p>接受者（Acceptor）：对提案作出裁决；</p>
</li>
<li><p>告知者（Learner）：被告知投票的结果，<strong>不参与投票过程</strong>。</p>
<blockquote>
<p><font color=blue>提案（Proposal）</font>。最终要达成一致的value就在提案里。只要Proposer发的提案被Acceptor接受（半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。只要Acceptor接受了某个提案，Acceptor就任务该提案里的value被选定了。</p>
</blockquote>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210302155514.png" alt="image-20210302155514766"></p>
</li>
</ul>
<p><strong>优势</strong>：为了避免单点问题：会有一个acceptor集合，proposer向该集合发送提案，acceptor集合中所有成员都有可能接受提案，并且只能批准一个提案，当有半数以上的成员同意，那么就同意批准该提案</p>
<h1 id="paxos算法过程"><a href="#paxos算法过程" class="headerlink" title="paxos算法过程"></a>paxos算法过程</h1><ul>
<li>阶段一（prepare阶段）：</li>
</ul>
<p>(a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。Pareper（N）</p>
<p>(b) 如果一个Acceptor收到一个编号为N的Prepare请求，如果小于它已经响应过的请求，则拒绝，不回应或回复error。若N大于该Acceptor已经响应过的所有Prepare请求的编号（maxN），那么它就会将它已经接受过（已经经过第二阶段accept的提案）的编号最大的提案（如果有的话，如果还没有的accept提案的话返回{pok，null，null}）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案</p>
<ul>
<li>阶段二（accept阶段）：</li>
</ul>
<p>(a) 如果一个Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value（某个acceptor响应的它已经通过的{acceptN，acceptV}），如果响应中不包含任何提案，那么V就由Proposer自己决定。</p>
<p>(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。如果N小于Acceptor以及响应的prepare请求，则拒绝，不回应或回复error（当proposer没有收到过半的回应，那么他会重新进入第一阶段，递增提案号，重新提出prepare请求）。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302154726.png" alt="image-20210302154726554"></p>
<h1 id="paxos优缺点"><a href="#paxos优缺点" class="headerlink" title="paxos优缺点"></a>paxos优缺点</h1><p>优点：paxos算法的优点很明显，按照此方法可以对多个数据值达到一致，收敛较好。</p>
<p>缺点：paxos算法的缺点是会出现活锁问题：考虑到一种极端的情况下，有两个proposer依次提出了一系列编号递增的议案，但是最终paxos无法形成最终的议案。具体场景如下：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302154914.png"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302154927.png"><strong>解决办法</strong>：</p>
<p>通过<strong>选取主Proposer</strong>，就可以保证Paxos算法的活性。选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来，<font color=red>只要主Proposer和过半的Acceptor能够正常进行网络通信，那么肯定会有一个提案被批准（第二阶段的accept），则可以解决死循环导致的活锁问题</font>。</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p><strong>通过选择一个主Proposer，并规定只能由主Proposer才能提出议案，整个paxos算法就可以保持活性。</strong></p>
<h1 id="Paxos算法的过半依据"><a href="#Paxos算法的过半依据" class="headerlink" title="Paxos算法的过半依据"></a>Paxos算法的过半依据</h1><p>在Paxos算法中，采用了“过半”理念，也就是少数服从多数，这使Paxos算法具有很好的容错性</p>
<h2 id="Paxos基于的过半数学原理"><a href="#Paxos基于的过半数学原理" class="headerlink" title="Paxos基于的过半数学原理"></a>Paxos基于的过半数学原理</h2><p>大多数（过半）进程组成的集合为法定集合，<font color=red> 两个法定（过半）集合必然存在非空交集，即至少有一个公共进程，称为法定集合性质</font>。 例如A,B,C,D,F进程组成的全集，法定集合Q1包括进程A,B,C，Q2包括进程B,C,D，那么Q1和Q2的交集必然不在空，C就是Q1，Q2的公共进程。如果要说Paxos最根本的原理是什么，那么就是这个简单性质。也就是说：<font color=red>两个过半的集合必然存在交集，也就是肯定是相等的，也就是肯定达成了一致</font>。</p>
<p>Paxos是基于消息传递的具有高度容错性的分布式一致性算法。<font color=red>Paxos算法引入了过半的概念，解决了2PC，3PC的太过保守的缺点，且使算法具有了很好的容错性，另外Paxos算法支持分布式节点角色之间的轮换，这极大避免了分布式单点的出现，因此Paxos算法既解决了无限等待问题，也解决了脑裂问题，是目前来说最优秀的分布式一致性算法。其中，Zookeeper的ZAB算法和Raft一致性算法都是基于Paxos的</font></p>
<p>参考文档：</p>
<ol>
<li><a href="https://www.zhihu.com/question/19787937">如何浅显易懂地解说 Paxos 的算法？</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95">paxos算法</a></li>
</ol>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
        <category>panxos</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
        <tag>panxos</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0/</url>
    <content><![CDATA[<p><a href="https://dbaplus.cn/news-141-1875-1.html%E3%80%81">https://dbaplus.cn/news-141-1875-1.html、</a></p>
<p><a href="https://blog.nowcoder.net/n/e4133fa6a55c4ce098655e5600ae8b84">https://blog.nowcoder.net/n/e4133fa6a55c4ce098655e5600ae8b84</a></p>
]]></content>
  </entry>
  <entry>
    <title>ZooKeeper集群简单介绍</title>
    <url>/posts/5af4d7fe/</url>
    <content><![CDATA[<p><a href="https://zookeeper.apache.org/doc/r3.6.2/zookeeperOver.html">官方文档地址</a></p>
<h1 id="Zookeeper介绍"><a href="#Zookeeper介绍" class="headerlink" title="Zookeeper介绍"></a>Zookeeper介绍</h1><p>ZooKeeper是一个<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/19276232">分布式</a>的，开放源码的<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/9854429">分布式应用程序</a>协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<p>ZooKeeper具有<strong>高性能</strong>，<strong>高可用性</strong>，<strong>严格排序的访问</strong>的特性。ZooKeeper的<strong>高性能</strong>意味着它<strong>可以在大型的分布式系统中使用</strong>。<strong>可靠性</strong>方面使它<strong>不会产生单点故障</strong>。<strong>严格的排序</strong>意味着可以<strong>在客户端上实现复杂的同步原语</strong>。</p>
<blockquote>
<p>详细测试对比可看官方文档   ：   <a href="https://zookeeper.apache.org/doc/r3.6.2/zookeeperOver.html">官方文档地址</a></p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210228144326.png" alt="image-20210228144326215"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210228143924.png" alt="image-20210228143924298"></p>
<blockquote>
<p><a href="https://juejin.cn/post/6844903919026438158">Zookeeper顺序一致性的理解</a></p>
</blockquote>
<h1 id="Zookeeper的读写机制"><a href="#Zookeeper的读写机制" class="headerlink" title="Zookeeper的读写机制"></a>Zookeeper的读写机制</h1><ul>
<li>Zookeeper是一个由多个server组成的集群</li>
<li>一个leader，多个follower</li>
<li>每个server保存一份数据副本</li>
<li>全局数据一致</li>
<li>分布式读写</li>
<li>更新请求转发，由<strong>leader实施</strong></li>
</ul>
<h1 id="Zookeeper-的保证"><a href="#Zookeeper-的保证" class="headerlink" title="Zookeeper 的保证"></a><strong>Zookeeper 的保证</strong></h1><ul>
<li><font color=red>更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行</font></li>
<li>数据更新原子性，一次数据更新要么成功，要么失败</li>
<li>全局<strong>唯一数据视图</strong>，client无论连接到哪个server，<strong>数据视图都是一致的</strong></li>
<li>实时性，在一定事件范围内，client能读到最新数据</li>
</ul>
<h1 id="集群中的角色"><a href="#集群中的角色" class="headerlink" title="集群中的角色"></a>集群中的角色</h1><ul>
<li>领导者（leader），负责进行投票的发起和决议，更新系统状态</li>
<li>学习者（learner），包括跟随者（follower）和观察者（observer），follower用于接受客户端请求并想客户端返回结果，在选主过程中参与投票</li>
<li>Observer可以接受客户端连接，将写请求转发给leader，但<strong>observer不参加投票过程</strong>，只同步leader的状态，observer的目的是为了扩展系统，提高读取速度</li>
<li>客户端（client），请求发起方</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302102953.png" alt="183233-20160316222444771-1363762533"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302103007.jpg" alt="183233-20160316222520584-1877673765"></p>
<ul>
<li>　　Zookeeper的核心<strong>是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。</strong>当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</li>
</ul>
<ul>
<li>　为了保证事务的顺序一致性<strong>，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid</strong>。<strong>实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</strong></li>
</ul>
<p><strong>每个Server在工作过程中有三种状态：</strong></p>
<ul>
<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>
<li>LEADING：当前Server即为选举出来的leader</li>
<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>
</ul>
<p><strong>Follower主要有四个功能</strong></p>
<ol>
<li>向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</li>
<li>接收Leader消息并进行处理；</li>
<li>接收Client的请求，如果为写请求，发送给Leader进行投票；</li>
<li>返回Client结果。</li>
</ol>
<p><strong>Follower的消息循环处理如下几种来自Leader的消息：</strong></p>
<ol>
<li>PING消息： 心跳消息；</li>
<li>PROPOSAL消息：Leader发起的提案，要求Follower投票；</li>
<li>COMMIT消息：服务器端最新一次提案的信息；</li>
<li>UPTODATE消息：表明同步完成；</li>
<li>.REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</li>
<li>SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</li>
</ol>
<p>其他文档：<a href="http://www.cnblogs.com/lpshou/archive/2013/06/14/3136738.html">http://www.cnblogs.com/lpshou/archive/2013/06/14/3136738.html</a></p>
<h1 id="Zookeeper节点数据操作流程"><a href="#Zookeeper节点数据操作流程" class="headerlink" title="Zookeeper节点数据操作流程"></a>Zookeeper节点数据操作流程</h1><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302103739.png" alt="183233-20160316223234865-1124736424"></p>
<p><strong>详细说明</strong></p>
<ol>
<li>在Client向Follwer发出一个写的请求</li>
<li>Follwer把请求发送给Leader</li>
<li>Leader接收到以后开始发起投票并通知Follwer进行投票</li>
<li>Follwer把投票结果发送给Leader</li>
<li>Leader将结果汇总后如果需要写入，则开始写入同时把写入操作通知给Leader然后commit;</li>
<li>Follwer把请求结果返回给Client</li>
</ol>
<h1 id="Zookeeper集群的两种运行状态"><a href="#Zookeeper集群的两种运行状态" class="headerlink" title="Zookeeper集群的两种运行状态"></a>Zookeeper集群的两种运行状态</h1><h2 id="leader可用状态"><a href="#leader可用状态" class="headerlink" title="leader可用状态"></a>leader可用状态</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210228144112.png" alt="image-20210228144111968"></p>
<h2 id="leader不可用状态"><a href="#leader不可用状态" class="headerlink" title="leader不可用状态"></a>leader不可用状态</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210228144131.png" alt="image-20210228144131837"></p>
<p>不可用状态恢复到可用状态根据官方测试<font color=red>小于200ms</font></p>
<h1 id="Zookeeper的集群选举"><a href="#Zookeeper的集群选举" class="headerlink" title="Zookeeper的集群选举"></a>Zookeeper的集群选举</h1><p>Leader选举是ZooKeeper中最重要的技术之一，也是保证分布式数据一致性的关键所在。</p>
<p> <a href="https://blog.csdn.net/qq_39554452/article/details/109988266">zookeeper集群搭建及选举模式</a></p>
<h2 id="服务器启动时期的选举"><a href="#服务器启动时期的选举" class="headerlink" title="服务器启动时期的选举"></a>服务器启动时期的选举</h2><h3 id="服务器启动时期的Leader选举"><a href="#服务器启动时期的Leader选举" class="headerlink" title="服务器启动时期的Leader选举"></a>服务器启动时期的Leader选举</h3><p> Leader选举的时候，需要注意的是，<strong>隐式条件便是ZooKeeper的集群规模至少是2台机器</strong>，这里我们以3台机器组成的服务器集群为例。在服务器集群初始化阶段，当有一台服务器(我们假设这台机器的myid为1，因此称其为Server1)启动的时候，它是无法完成Leader选举的。当第二胎机器(同样，我们假设这台服务器的myid是2，称其为Server2)也启动后，此时这两台机器已经能够进行互相通信，每台机器都试图找到一个Leader，于是便进入了Leader选举流程。</p>
<ol>
<li><p>每个Server会发出一个投票，由于是初始情况，因此对于Server1和Server2来说，都会将自己作为Leader服务器来进行投票，每次投票包含最基本的元素有：所推举的服务器的myid和ZXID，我们以(myid,ZXID)的形式来表示。因为是初始化阶段，因此无论是Server1还是Server2,都会投给自己，即Server1的投票为(1,0),Server2的投票为(2,0),然后各自将这个投票发给集群中其他所有机器。</p>
</li>
<li><p>接收来自各个服务器的投票，每个服务器都会接收来自其他服务器的投票。集群中的每个服务器在接收到投票后，首先会判断该投票的有效性，包括检查是否是本轮投票，是否来自LOOKING状态的服务器。</p>
</li>
<li><p>处理投票，在接收到来自其他服务器的投票后，针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK的<strong>步骤及处理流程</strong>如下：</p>
<ol>
<li><p>==统计投票==，每次投票后，服务器都会统计所有投票，判断是否已经有过半的及其接收到相同的投票信息。对于Server1和Server2服务器来说，都统计出集群中已经有两台机器接受了(2,0)这个投票信息。这里我们需要对“过半”的概念做一个简单的介绍。所有“过半”就是指大于集群机器数量的一半，即大于或等于(n/2+1)。对于这里由3台机器构成的集群，大于等于2台即为达到“过半”要求。，当<strong>选举票数机器相同</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优先检查ZXID，ZXID比较大的服务器优先作为Leader</span><br><span class="line"></span><br><span class="line">如果ZXID相同的话，那么就比较myid。myid比较大的服务器作为Leader服务器</span><br></pre></td></tr></table></figure>
</li>
<li><p>==改变服务器状态==，一旦确定Leader，每个服务器就会更新自己的状态。如果是Follower，那么就变更为FOLLOWING，如果是Leader，那么就变更为LEADING。</p>
</li>
</ol>
</li>
</ol>
<h3 id="服务器运行时期的Leader选举"><a href="#服务器运行时期的Leader选举" class="headerlink" title="服务器运行时期的Leader选举"></a>服务器运行时期的Leader选举</h3><p>在Zookeeper集群正常运行过程中，<strong>一旦选出一个Leader，那么所有服务器的集群角色一般不会再发生变化</strong>，也就是说，Leader服务器将一直作为集群的Leader，<strong>即使集群中有非Leader挂了或有新机器加入集群也不会影响Leader</strong>。但是<strong>一旦Leader所在机器挂了，那么整个集群将暂时无法对外提供服务，而是进入新一轮的Leader选举</strong>。服务器运行期间的Leader选举和启动时期的Leader选举基本过程一致的。</p>
<h1 id="Zookeeper中节点的状态信息各字段含义"><a href="#Zookeeper中节点的状态信息各字段含义" class="headerlink" title="Zookeeper中节点的状态信息各字段含义"></a>Zookeeper中节点的状态信息各字段含义</h1><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302100241.png" alt="image-20210302100241394"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stat</span> <span class="keyword">implements</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> czxid; <span class="comment">// 该数据节点被创建时的事务id</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> mzxid; <span class="comment">// 该数据节点被修改时最新的事务id（集群中会不一样）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> ctime; <span class="comment">// 该数据节点创建时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> mtime; <span class="comment">// 该数据节点最后修改时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> version; <span class="comment">// 当前节点版本号（可以理解为修改次数，每修改一次值+1）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> cversion;<span class="comment">// 子节点版本号（子节点修改次数，每修改一次值+1）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> aversion; <span class="comment">// 当前节点acl版本号（acl节点被修改次数，每修改一次值+1）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> ephemeralOwner; <span class="comment">// 临时节点标示，当前节点如果是临时节点，则存储的创建者的会话id（sessionId），如果不是，那么值=0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> dataLength;<span class="comment">// 当前节点数据长度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> numChildren; <span class="comment">// 当前节点子节点个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> pzxid; <span class="comment">// 当前节点的父级节点事务ID</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Stat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color=red>其中zxid表示的是zookeeper的事务ID，由64位数字组成，分为高32位和低32位</font></strong></p>
<p><strong>高32位</strong>：Epoch周期数，值为最新的领导的对应的id，其实就是就是一个递增的数字</p>
<p><strong>低32位</strong>：计数器，一个递增的计数器，当处理了一个事务，值+1</p>
<p>zxid生成的规则：ZxidUtils.makeZxid</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZxidUtils</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getEpochFromZxid</span><span class="params">(<span class="keyword">long</span> zxid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zxid &gt;&gt; <span class="number">32L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getCounterFromZxid</span><span class="params">(<span class="keyword">long</span> zxid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zxid &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">makeZxid</span><span class="params">(<span class="keyword">long</span> epoch, <span class="keyword">long</span> counter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (epoch &lt;&lt; <span class="number">32L</span>) | (counter &amp; <span class="number">0xffffffffL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">zxidToString</span><span class="params">(<span class="keyword">long</span> zxid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Long.toHexString(zxid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Zookeeper顺序一致性简单验证"><a href="#Zookeeper顺序一致性简单验证" class="headerlink" title="Zookeeper顺序一致性简单验证"></a>Zookeeper顺序一致性简单验证</h1><ol>
<li><p>启动三个1，2，3三个节点(共四个节点)，三个节点已经可以选举出leader</p>
<p> <code>./bin/zkServer.sh start-foreground</code></p>
<p> <strong>节点1日志</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302121105.png" alt="image-20210302121105538"></p>
<p> <strong>节点2日志</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302121316.png" alt="image-20210302121316291"></p>
<p> <strong>节点3日志</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302123647.png" alt="image-20210302123647739"></p>
</li>
<li><p>启动节点4</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302124033.png"></p>
</li>
<li><p>连接3，4节点并新增数据，会发现cZxid会自增</p>
<p> <code>./bin/zkCli.sh -server 127.0.0.1:12183</code></p>
<p> <code>./bin/zkCli.sh -server 127.0.0.1:12184</code></p>
<p> <code>create -s /ooxx/xxx</code></p>
<p> <code>get -s /ooxx/xxx</code></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302124819.png" alt="image-20210302124819564"></p>
<p> 当进行修改时，会自动在mzxid（该数据节点被修改时最新的事务id）字段加1</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302125027.png" alt="image-20210302125027621"></p>
<p> 4.在此时中断leader进程，并在4节点继续新增相关数据</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302130145.png"></p>
<p> <strong>mZxid前两次（剩余2个following节点）事务是进行了数据同步，第三次事务才是修改/ooxx节点数据</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302130252.png" alt="image-20210302130252033"></p>
<p> 5.不同客户端创建同一个节点</p>
<p> <strong>leader会在此节点进行递增，不会覆盖创建</strong>，规避数据被覆盖</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302130554.png" alt="image-20210302130554281"></p>
</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302130614.png" alt="image-20210302130614931"></p>
<p>当删除节点重新创建，但是数据名会继续递增（leade内部维护）</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302130920.png" alt="image-20210302130920351"></p>
<h1 id="Zookeeper的应用场景"><a href="#Zookeeper的应用场景" class="headerlink" title="Zookeeper的应用场景"></a>Zookeeper的应用场景</h1><ol>
<li>统一的配置管理  ————节点下可以存储1M的数据</li>
<li>分组管理              ————–Zookeeper的树结构，可以有多个节点</li>
<li>统一命名              ————-顺序一致性的能力（不会覆盖数据）</li>
<li>分布式同步          ————-临时节点<ul>
<li>分布式锁   ———临时节点下放置分布式锁（session挂掉自动消失，就会释放锁）</li>
<li>带事务(队列形式)的公平锁   ————–在持久的父节点下，建立多个同级同名(create -s  会自动的添加序列)的临时节点（可以持有多把锁），后面的锁盯住前面的锁（01-02-03）</li>
<li>HA,选主（hadoop）</li>
</ul>
</li>
<li>发布订阅</li>
</ol>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>redis集群</title>
    <url>/posts/dcfaa904/</url>
    <content><![CDATA[<h5 id="1-单节点redis的缺陷"><a href="#1-单节点redis的缺陷" class="headerlink" title="1.单节点redis的缺陷"></a>1.单节点redis的缺陷</h5><ul>
<li>单点故障导致服务不可用</li>
<li>redis的容量优先</li>
<li>redis的服务压力</li>
</ul>
<h5 id="2-集群的AKF原则"><a href="#2-集群的AKF原则" class="headerlink" title="2. 集群的AKF原则"></a>2. 集群的AKF原则</h5><p><a href="https://www.cnblogs.com/-wenli/p/13584796.html">AKF原则</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113708.png" alt="image-20210222095931709"></p>
<blockquote>
<p>x轴：全量，镜像</p>
<p>Y轴：业务，功能</p>
<p>Z轴：优先级，逻辑再拆分</p>
</blockquote>
<h6 id="2-1-redis使用AKF原则扩展为集群产生的问题"><a href="#2-1-redis使用AKF原则扩展为集群产生的问题" class="headerlink" title="2.1 redis使用AKF原则扩展为集群产生的问题"></a>2.1 redis使用AKF原则扩展为集群产生的问题</h6><p>通过AKF一变多 ：<strong>数据一致性问题</strong></p>
<p>​                            </p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113717.png" alt="image-20210222102653774"></p>
<h5 id="3-CAP原则"><a href="#3-CAP原则" class="headerlink" title="3. CAP原则"></a>3. CAP原则</h5><p><a href="https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99/5712863?fr=aladdin">CAP原则百科</a></p>
<p>CAP原则又称CAP定理，指的是在一个分布式系统中，<a href="https://baike.baidu.com/item/%E4%B8%80%E8%87%B4%E6%80%A7/9840083">一致性</a>（Consistency）、<a href="https://baike.baidu.com/item/%E5%8F%AF%E7%94%A8%E6%80%A7/109628">可用性</a>（Availability）、<a href="https://baike.baidu.com/item/%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7/23734073">分区容错性</a>（Partition tolerance）。CAP 原则指的是，这三个<a href="https://baike.baidu.com/item/%E8%A6%81%E7%B4%A0/5261200">要素</a>最多只能同时实现两点，不可能三者兼顾。</p>
<h5 id="4-Redis的复制（同步）"><a href="#4-Redis的复制（同步）" class="headerlink" title="4. Redis的复制（同步）"></a>4. Redis的复制（同步）</h5><p><a href="http://redis.cn/topics/replication.html">redis的复制</a></p>
<p>Redis使用默认的<strong>异步复制</strong>，其特点是低延迟和高性能，是绝大多数 Redis 用例的自然复制模式。但是，从 Redis 服务器会异步地确认其从主 Redis 服务器周期接收到的数据量。</p>
<h6 id="4-1-redis复制的重要细节"><a href="#4-1-redis复制的重要细节" class="headerlink" title="4.1. redis复制的重要细节"></a>4.1. redis复制的重要细节</h6><ul>
<li>Redis 使用异步复制，slave 和 master 之间异步地确认处理的数据量</li>
<li>一个 master 可以拥有多个 slave</li>
<li>slave 可以接受其他 slave 的连接。除了多个 slave 可以连接到同一个 master 之外， slave 之间也可以像层叠状的结构（cascading-like structure）连接到其他 slave 。自 Redis 4.0 起，所有的 sub-slave 将会从 master 收到完全一样的复制流。</li>
<li>Redis 复制在 master 侧是非阻塞的。这意味着 master 在一个或多个 slave 进行初次同步或者是部分重同步时，可以继续处理查询请求。</li>
<li>复制在 slave 侧大部分也是非阻塞的。当 slave 进行初次同步时，它可以使用旧数据集处理查询请求，假设你在 redis.conf 中配置了让 Redis 这样做的话。否则，你可以配置如果复制流断开， Redis slave 会返回一个 error 给客户端。但是，在初次同步之后，旧数据集必须被删除，同时加载新的数据集。 slave 在这个短暂的时间窗口内（如果数据集很大，会持续较长时间），会阻塞到来的连接请求。自 Redis 4.0 开始，可以配置 Redis 使删除旧数据集的操作在另一个不同的线程中进行，但是，加载新数据集的操作依然需要在主线程中进行并且会阻塞 slave 。</li>
<li>复制既可以被用在可伸缩性，以便只读查询可以有多个 slave 进行（例如 O(N) 复杂度的慢操作可以被下放到 slave ），或者仅用于数据安全。</li>
<li>可以使用复制来避免 master 将全部数据集写入磁盘造成的开销：一种典型的技术是配置你的 master Redis.conf 以避免对磁盘进行持久化，然后连接一个 slave ，其配置为不定期保存或是启用 AOF。但是，这个设置必须小心处理，因为重新启动的 master 程序将从一个空数据集开始：如果一个 slave 试图与它同步，那么这个 slave 也会被清空。</li>
</ul>
<h6 id="Redis-复制功能的细节过程"><a href="#Redis-复制功能的细节过程" class="headerlink" title="Redis 复制功能的细节过程"></a>Redis 复制功能的细节过程</h6><p>master 开启一个<strong>后台保存进程，以便于生产一个 RDB 文件</strong>。同时它开始缓冲所有从客户端接收到的新的写入命令。当后台保存完成时， master 将数据集文件传输给 slave， slave将之保存在磁盘上，然后加载文件到内存。再然后 master 会发送所有缓冲的命令发给 slave。这个过程以指令流的形式完成并且和 Redis 协议本身的格式相同。</p>
<p>你可以用 telnet 自己进行尝试。在服务器正在做一些工作的同时连接到 Redis 端口并发出 <a href="https://redis.io/commands/sync">SYNC</a> 命令。你将会看到一个批量传输，并且之后每一个 master 接收到的命令都将在 telnet 回话中被重新发出。事实上 SYNC 是一个旧协议，在新的 Redis 实例中已经不再被使用，但是其仍然向后兼容：但它不允许部分重同步，所以现在 <strong>PSYNC</strong> 被用来替代 SYNC。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226145730.png" alt="image-20210226145730728"></p>
<h5 id="5-Redis中哨兵sentinel"><a href="#5-Redis中哨兵sentinel" class="headerlink" title="5. Redis中哨兵sentinel"></a>5. Redis中哨兵sentinel</h5><p><a href="http://redis.cn/topics/sentinel.html">Redis 的 Sentinel 文档</a></p>
<p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p>
<ul>
<li><strong>监控（Monitoring</strong>）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong>： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis Sentinel 是一个<strong>分布式系统</strong>， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用<strong>流言协议（gossip protocols)**来接收关于主服务器是否下线的信息， 并使用</strong>投票协议**（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器</p>
<h6 id="客观下线和主观下线"><a href="#客观下线和主观下线" class="headerlink" title="客观下线和主观下线"></a>客观下线和主观下线</h6><ul>
<li>主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。</li>
<li>客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）</li>
</ul>
<p>客观下线条件<strong>只适用于主服务器</strong>： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。</p>
<p>从主观下线状态切换到客观下线状态并没有使用严格的法定人数算法（strong quorum algorithm）， 而是使用了<strong>流言协议</strong>： 如果 <strong>Sentinel 在给定的时间范围内， 从其他 Sentinel 那里接收到了足够数量的主服务器下线报告， 那么 Sentinel 就会将主服务器的状态从主观下线改变为客观下线</strong>。 如果之后其他 Sentinel 不再报告主服务器已下线， 那么客观下线状态就会被移除。</p>
<h5 id="6-Redis集群"><a href="#6-Redis集群" class="headerlink" title="6.Redis集群"></a>6.Redis集群</h5><p><a href="http://redis.cn/topics/cluster-tutorial.html">redis集群教程</a></p>
<h6 id="Redis集群的拆分方案"><a href="#Redis集群的拆分方案" class="headerlink" title="Redis集群的拆分方案"></a>Redis集群的拆分方案</h6><ul>
<li>数据可以分类，交集不多</li>
<li>数据没办法拆分,用一致性hash算法进行拆分(redis-cluster)</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226152546.png" alt="image-20210226152546200"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226153455.png" alt="image-20210226153454965"></p>
<h6 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h6><p>希算法就是将任意长度的二进制值映射为较短的固定长度的唯一的二进制值(即哈希值)。敲黑板，哈希算法的入参可以是任意长度，而出参是固定长度而且唯一。一致性哈希算法就是，先构造一个0到2^32的整数环(hash环，java中可用SortedMap实现)，根据缓存服务器名称(也可以是ip:port)计算出hash值，根据其hash值将缓存服务器放置在hash环上。每次根据要缓存的key计算得到hash值，在hash环上顺时针查找距离最近的缓存服务器节点(SortedMap.tailMap(key)实现)，进行set/set操作<br><img src="https://gitee.com/CNRF/image/raw/master/img/20210226153659.png" alt="image-20210226153659880"></p>
<p><strong>一致性hash算法的问题</strong></p>
<p>1.加减缓存服务器节点会造成hash环部分数据无法命中；</p>
<p>2.少量缓存服务器节点时，数据分布不均匀，同时缓存服务器节点变化将影响大范围数据;</p>
<p>3.普通的一致性哈希分区需要增加一倍或减掉一半缓存服务器节点才能保持数据负载均衡；</p>
<p>当只有少量缓存服务器又想尽量保证负载均衡时，我们一般采用下面的办法：将一个缓存服务器节点虚拟成一组，比如某台缓存服务器为192.168.2.1:6379，我们就可以将其虚拟成一个虚拟节点数组，为192.168.2.1:6379-1，192.168.2.1:6379-2，192.168.2.1:6379-3……然后分别计算数组里的元素的hash值并映射到hash环上，每台缓存服务器都如此处理。当不同key的缓存路由到虚拟节点时，最终都是指向真实的缓存服务器节点。通过这样增加节点的方式，可以一定概率上使数据路由均衡</p>
<h6 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis-cluster"></a>redis-cluster</h6><p> Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p> 其结构特点：<br> 1、所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。<br> 2、节点的fail是通过集群中超过半数的节点检测失效时才生效。<br> 3、客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。<br> 4、redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value。<br> 5、Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。</p>
<p><strong>a.redis cluster节点分配</strong><br> 现在我们是三个主节点分别是：A, B, C 三个节点，它们可以是一台机器上的三个端口，也可以是三台不同的服务器。那么，采用哈希槽 (hash slot)的方式来分配16384个slot 的话，它们三个节点分别承担的slot 区间是：</p>
<ul>
<li><p>节点A覆盖0－5460;</p>
</li>
<li><p>节点B覆盖5461－10922;</p>
</li>
<li><p>节点C覆盖10923－16383.</p>
<p>  获取数据:<br>   如果存入一个值，按照redis cluster哈希槽的<a href="http://lib.csdn.net/base/datastructure">算法</a>： CRC16(‘key’)384 = 6782。 那么就会把这个key 的存储分配到 B 上了。同样，当我连接(A,B,C)任何一个节点想获取’key’这个key时，也会这样的算法，然后内部跳转到B节点上获取数据</p>
<p>  新增一个主节点:<br>   新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上，我会在接下来的实践中实验。大致就会变成这样：</p>
</li>
<li><p>节点A覆盖1365-5460</p>
</li>
<li><p>节点B覆盖6827-10922</p>
</li>
<li><p>节点C覆盖12288-16383</p>
</li>
<li><p>节点D覆盖0-1364,5461-6826,10923-12287</p>
</li>
</ul>
<p>同样删除一个节点也是类似，移动完成后就可以删除这个节点了。</p>
<p><strong>b.Redis Cluster主从模式</strong><br> redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉</p>
<p>上面那个例子里, 集群有ABC三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了。A和C的slot也无法访问。</p>
<p>所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像这样, 集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。</p>
<p>B1节点替代了B节点，所以Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。</p>
<p>不过需要注意，如果<strong>节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了</strong>。</p>
<h5 id="8-Redis集群的代理"><a href="#8-Redis集群的代理" class="headerlink" title="8.Redis集群的代理"></a>8.Redis集群的代理</h5><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226154729.png" alt="image-20210226154729661"></p>
<p><a href="https://blog.csdn.net/qq_34944535/article/details/106803261?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.control&dist_request_id=46a127bd-e7dd-4660-b485-d998c0726304&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.control">redis cluster代理</a></p>
<p>目前市面上主流的代理包含：predixy、twemproxy、codis、redis-cerberus四款，这四款各有各的优势，我们逐个对比进行对比分析。</p>
<div class="table-box"><table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td><strong>特性</strong></td><td><strong>predixy</strong></td><td><strong>twemproxy</strong></td><td><strong>codis</strong></td><td><strong>redis-cerberus</strong></td></tr><tr><td>高可用</td><td>Redis Sentinel或Redis Cluster</td><td>一致性哈希</td><td>Redis Sentinel</td><td>Redis Cluster</td></tr><tr><td>可扩展</td><td>Key哈希分布或Redis Cluster</td><td>Key哈希分布</td><td>Key哈希分布</td><td>Redis Cluster</td></tr><tr><td>开发语言</td><td>C++</td><td>C</td><td>GO</td><td>C++</td></tr><tr><td>多线程</td><td>是</td><td>否</td><td>是</td><td>是</td></tr><tr><td>事务</td><td>Redis Sentinel模式单Redis组下支持</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>BLPOP/BRPOP/BLPOPRPUSH</td><td>支持</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>Pub/Sub</td><td>支持</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>Script</td><td>支持load</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>Scan</td><td>支持</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>Select DB</td><td>支持</td><td>不支持</td><td>支持</td><td>Redis Cluster只有一个DB</td></tr><tr><td>Auth</td><td>支持定义多个密码，给予不同读写及管理权限和Key访问空间</td><td>不支持</td><td>同redis</td><td>不支持</td></tr><tr><td>读从节点</td><td>支持，可定义丰富规则读指定的从节点</td><td>不支持</td><td>支持，简单规则</td><td>支持，简单规则</td></tr><tr><td>多机房支持</td><td>支持，可定义丰富规则调度流量</td><td>不支持</td><td>有限支持</td><td>有限支持</td></tr><tr><td>统计信息</td><td>丰富</td><td>丰富</td><td>丰富</td><td>简单</td></tr></tbody></table></div>

]]></content>
      <categories>
        <category>Redis</category>
        <category>一致性Hash算法</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>一致性Hash算法</tag>
      </tags>
  </entry>
  <entry>
    <title>redis持久化</title>
    <url>/posts/dcfaa904/</url>
    <content><![CDATA[<h5 id="1-redis的持久化方式"><a href="#1-redis的持久化方式" class="headerlink" title="1. redis的持久化方式"></a>1. redis的持久化方式</h5><ol>
<li><p>RDB持久化</p>
<p> 原理是将<strong>Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化</strong></p>
</li>
<li><p>AOF持久化</p>
<p> 原理是将<strong>Reids的操作日志以追加的方式写入文件</strong></p>
<p> <a href="https://www.cnblogs.com/zxs117/p/11242026.html">两种持久化方式区别</a></p>
<p> 二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。不过生产环境其实更多都是二者结合使用的。</p>
</li>
</ol>
<h5 id="2-RDB持久化"><a href="#2-RDB持久化" class="headerlink" title="2.RDB持久化"></a>2.RDB持久化</h5><p><strong>原理</strong> :在liunx系统系统中，<strong>进程之间的数据是隔离的</strong>，在使用export的环境变量，<strong>父子进程的修改都不会影响到其他进程的数据</strong></p>
<p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是<strong>fork一个子进程</strong>，先将<strong>数据集写入临时文件</strong>，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<h6 id="2-1-RDB的优缺点"><a href="#2-1-RDB的优缺点" class="headerlink" title="2.1 RDB的优缺点"></a>2.1 RDB的优缺点</h6><p><strong>优点</strong>： </p>
<ol>
<li><strong>还原速度快</strong>（类似java的对象序列化，可快速还原）</li>
<li><strong>整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的</strong>。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li>
</ol>
<p><strong>弊端</strong>：</p>
<ol>
<li>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么<strong>RDB将不是一个很好的选择。因为系统一旦在定时持久化完成之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失</strong>。</li>
<li> 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，<strong>如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</strong></li>
</ol>
<blockquote>
<p>fork命令只是创建进程，并不会在此时进行复制，因此创建进程的速度变快</p>
<p>fork出来的父子进程具有 <strong>相同但是独立的地址空间</strong>因为父进程和子进程是独立的进程，他们都有自己私有的地址空间，当父进程或者子进程单独改变时，不会影响到彼此，类似于c++的写实拷贝的形式自建一个副本</p>
<p><a href="https://blog.csdn.net/weixin_40853073/article/details/81873398?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=4254810a-f10f-43c5-8965-6b775b5a3682&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">fork命令详细说明</a></p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113700.png" alt="image-20210221233300160"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226151043.png" alt="image-20210226151042967"></p>
<h5 id="3-AOF持久化"><a href="#3-AOF持久化" class="headerlink" title="3. AOF持久化"></a>3. AOF持久化</h5><p>AOF持久化以<strong>日志的形式</strong>记录服务器所处理的<strong>每一个写、删除操作</strong>，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p>
<blockquote>
<p>当redis同时开启RDB和AOF备份，redis恢复是只会依据AOF的备份（AOF的数据丢失较少）</p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113653.png" alt="image-20210221233312115"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226151129.png" alt="image-20210226151129085"></p>
<h6 id="3-1-AOF的优缺点"><a href="#3-1-AOF的优缺点" class="headerlink" title="3.1 AOF的优缺点"></a>3.1 AOF的优缺点</h6><p><strong>优点</strong>：</p>
<p>1). 该机制可以带来<strong>更高的数据安全性，即数据持久性</strong>。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。</p>
<p>2). 由于该机制对日志文件的<strong>写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容</strong>。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以<strong>通过redis-check-aof工具来帮助我们解决数据一致性的问题。</strong></p>
<p>3). 如果<strong>日志过大，Redis可以自动启用rewrite机制</strong>。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</p>
<blockquote>
<p>redis4.0以前：rewrite其实是删除抵消的命令（创建和删除），合并重复的命名。最终会生成重复命令</p>
<p>redis4.0以后：将老的数据RDB到AOF中，将增量的以指令的方式append到aof中（实际就是混合RDB+AOF的持久化方式）</p>
</blockquote>
<p>4). <strong>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建</strong>。</p>
<p><strong>缺点</strong>：</p>
<p>1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。<strong>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</strong></p>
<p>2). 根据同步策略的不同，<strong>AOF在运行效率上往往会慢于RDB</strong>。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的消息订阅，pipeline，事务</title>
    <url>/posts/d09e787/</url>
    <content><![CDATA[<h5 id="1-Redis-管道（Pipelining）"><a href="#1-Redis-管道（Pipelining）" class="headerlink" title="1.Redis 管道（Pipelining）"></a>1.Redis 管道（Pipelining）</h5><p><a href="http://redis.cn/topics/pipelining.html">Redis 管道（Pipelining）</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113641.png" alt="image-20210220103817162"></p>
<p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将<em>多个命令</em>发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
<p><strong>重要说明</strong>: 使用管道发送命令时，服务器将被迫回复一个队列答复，占用很多内存。如果需要发送大量的命令，最好是按照合理数量分批次的处理，例如10K的命令，读回复，然后再发送另一个10k的命令，等等。这样速度几乎是相同的，但是在回复这10k命令队列需要非常大量的内存用来组织返回数据内容。</p>
<h5 id="2-redis的消息订阅"><a href="#2-redis的消息订阅" class="headerlink" title="2. redis的消息订阅"></a>2. redis的消息订阅</h5><p><a href="http://redis.cn/topics/pubsub.html">redis的消息订阅</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUBLISH  &#x2F;&#x2F;发布消息</span><br><span class="line">SUBSCRIBE foo bar</span><br><span class="line">SUBSCRIBE  &#x2F;&#x2F;接收指定队列消息</span><br><span class="line">SUBSCRIBE foo</span><br></pre></td></tr></table></figure>

<h5 id="3-redis的事务"><a href="#3-redis的事务" class="headerlink" title="3. redis的事务"></a>3. redis的事务</h5><p><a href="http://redis.cn/topics/transactions.html">redis的事务</a></p>
<p><a href="http://redis.cn/commands/multi.html">MULTI</a> 、 <a href="http://redis.cn/commands/exec.html">EXEC</a> 、 <a href="http://redis.cn/commands/discard.html">DISCARD</a> 和 <a href="http://redis.cn/commands/watch.html">WATCH</a> 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<p><a href="http://redis.cn/commands/exec.html">EXEC</a> 命令负责触发并执行事务中的所有命令：</p>
<ul>
<li>如果客户端在使用 <a href="http://redis.cn/commands/multi.html">MULTI</a> 开启了一个事务之后，却因为断线而没有成功执行 <a href="http://redis.cn/commands/exec.html">EXEC</a> ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 <a href="http://redis.cn/commands/exec.html">EXEC</a> ，那么事务中的所有命令都会被执行</li>
</ul>
<blockquote>
<p><code> AOF 方式做持久化</code>的时候，Redis 会使用单个 write(2) 命令将事务写入到磁盘中。然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p>
<p>Redis (2.2版本开始)还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作</p>
</blockquote>
<h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><p><a href="http://redis.cn/commands/multi.html">MULTI</a> 命令用于开启一个事务，它总是返回 <code>OK</code> 。 <a href="http://redis.cn/commands/multi.html">MULTI</a> 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 <a href="http://redis.cn/commands/exec.html">EXEC</a>命令被调用时， 所有队列中的命令才会被执行。</p>
<p>另一方面， 通过调用 <a href="http://redis.cn/commands/discard.html">DISCARD</a> ， 客户端可以清空事务队列， 并放弃执行事务。</p>
<p>以下是一个事务例子， 它原子地增加了 <code>foo</code> 和 <code>bar</code> 两个键的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br></pre></td></tr></table></figure>

<p><a href="http://redis.cn/commands/exec.html">EXEC</a> 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。</p>
<p>当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 <code>QUEUED</code> 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行</p>
<h6 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h6><ul>
<li>事务在执行 <a href="http://redis.cn/commands/exec.html">EXEC</a> 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 <code>maxmemory</code> 设置了最大内存限制的话）。</li>
<li>命令可能在 <a href="http://redis.cn/commands/exec.html">EXEC</a> 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。</li>
</ul>
<p>服务器会对命令入队失败的情况进行记录，并在客户端调用 <a href="http://redis.cn/commands/exec.html">EXEC</a> 命令时，<strong>拒绝执行并自动放弃这个事务</strong>。</p>
<h6 id="Redis-不支持回滚（roll-back）原因"><a href="#Redis-不支持回滚（roll-back）原因" class="headerlink" title="Redis 不支持回滚（roll back）原因"></a>Redis 不支持回滚（roll back）原因</h6><ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，<strong>失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中</strong>。</li>
<li>因为<strong>不需要对回滚进行支持</strong>，所以 Redis 的内部可以保持<strong>简单且快速</strong>。</li>
</ul>
<h5 id="4-布隆过滤器"><a href="#4-布隆过滤器" class="headerlink" title="4.布隆过滤器"></a>4.布隆过滤器</h5><p><a href="https://github.com/RedisBloom/RedisBloom">第三方实现的redis的布隆过滤器</a></p>
<blockquote>
<p>第三方实现redis的相关功能： <a href="https://redis.io/modules">https://redis.io/modules</a></p>
</blockquote>
<h5 id="5-redis的LRU（Least-Recently-Used）淘汰策略"><a href="#5-redis的LRU（Least-Recently-Used）淘汰策略" class="headerlink" title="5.redis的LRU（Least Recently Used）淘汰策略"></a>5.redis的LRU（Least Recently Used）淘汰策略</h5><p><a href="http://redis.cn/topics/lru-cache.html">将redis当做使用LRU算法的缓存来使用</a></p>
<p><strong>LRU是Redis唯一支持的回收方法</strong>，Redis的<code>maxmemory</code>指令用于将可用内存限制成一个固定大小，还包括了Redis使用的LRU算法，这个实际上只是近似的LRU。</p>
<p><strong>Redis的LRU算法并非完整的实现</strong>。这意味着<strong>Redis并没办法选择最佳候选来进行回收</strong>，也就是最久未被访问的键。相反它会尝试运行一个近似LRU的算法，<strong>通过对少量keys进行取样，然后回收其中一个最好的key（被访问时间较早的）</strong>。</p>
<h6 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h6><p>以下的策略是可用的:</p>
<ul>
<li><strong>noeviction</strong>:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</li>
<li><strong>allkeys-lru</strong>: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</li>
<li><strong>volatile-lru</strong>: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</li>
<li><strong>allkeys-random</strong>: 回收随机的键使得新添加的数据有空间存放。</li>
<li><strong>volatile-random</strong>: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li>
<li><strong>volatile-ttl</strong>: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</li>
</ul>
<h6 id="回收进程如何工作"><a href="#回收进程如何工作" class="headerlink" title="回收进程如何工作"></a><strong>回收进程如何工作</strong></h6><p>理解回收进程如何工作是非常重要的:</p>
<ul>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ul>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper的安装和简单操作</title>
    <url>/posts/b439f21c/</url>
    <content><![CDATA[<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><ol>
<li>系统：CentOS 7</li>
<li>Java环境： JDK8</li>
</ol>
<h1 id="下载及安装"><a href="#下载及安装" class="headerlink" title="下载及安装"></a>下载及安装</h1><p>　zookeeper有单机、伪集群、集群三种部署方式，我使用的zookeeper版本是：zookeeper-3.5.9</p>
<p>下载Zookeeper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;apache.claz.org&#x2F;zookeeper&#x2F;zookeeper-3.5.9&#x2F;apache-zookeeper-3.5.9-bin.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h2><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;解压到指定目录</span><br><span class="line">tar -zxvf apache-zookeeper-3.5.9-bin.tar.gz   -C &#x2F;user&#x2F;soft&#x2F;</span><br></pre></td></tr></table></figure>

<p>解压后目录</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301110436.png" alt="image-20210301110435970"></p>
<p>进入conf目录，创建一个zookeeper的配置文件zoo.cfg，可复制conf/zoo_sample.cfg作为配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>

<h3 id="配置文件说明："><a href="#配置文件说明：" class="headerlink" title="配置文件说明："></a>配置文件说明：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line"># tickTime：CS通信心跳数</span><br><span class="line"># Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。tickTime以毫秒为单位。</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"></span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">#initLimit：LF初始通信时限</span><br><span class="line"># 集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量）。</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"></span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line"># syncLimit：LF同步通信时限</span><br><span class="line"># 集群中的follower服务器与leader服务器之间请求和应答之间能容忍的最多心跳数（tickTime*syncLimit ）。</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># dataDir：数据文件目录</span><br><span class="line"># Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;apache-zookeeper-3.6.2-bin&#x2F;data</span><br><span class="line"></span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">#clientPort：客户端连接端口</span><br><span class="line">#客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"></span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#最大连接数</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#保留数量3</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"></span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#清理时间间隔1小时</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br><span class="line"></span><br><span class="line">## Metrics Providers</span><br><span class="line">#</span><br><span class="line"># https:&#x2F;&#x2F;prometheus.io Metrics Exporter</span><br><span class="line">#metricsProvider.className&#x3D;org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span><br><span class="line">#metricsProvider.httpPort&#x3D;7000</span><br><span class="line">#metricsProvider.exportJvmInfo&#x3D;true</span><br><span class="line"></span><br><span class="line"> # 服务器名称与地址：集群信息（服务器编号，服务器地址，LF通信端口，选举端口）</span><br><span class="line"># 这个配置项的书写格式比较特殊，规则如下：</span><br><span class="line"># server.N&#x3D;YYY:A:B   </span><br><span class="line"># 其中N表示服务器编号，YYY表示服务器的IP地址，A为LF通信端口，表示该服务器与集群中的leader交换的信息的端口。B为选举端口，表示选举新leader时服务器间相互通信的端口（当leader挂掉时，其余服务器会相互通信，选择出新的leader）。一般来说，集群中每个服务器的A端口都是一样，每个服务器的B端口也是一样。但是当所采用的为伪集群时，IP地址都一样，只能时A端口和B端口不一样。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="启动及停止服务"><a href="#启动及停止服务" class="headerlink" title="启动及停止服务"></a>启动及停止服务</h3><p>可以不修改zoo.cfg，默认配置就行，进去zookeeper安装目录，启动ZooKeeper</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动命令：</span></span><br><span class="line">./bin/zkServer.sh start</span><br><span class="line"><span class="comment">#在前端启动，可看启动日志</span></span><br><span class="line">./bin/zkServer.sh start-foreground</span><br><span class="line"><span class="comment">#停止命令：</span></span><br><span class="line">./bin/zkServer.sh stop　　</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启命令：</span></span><br><span class="line">./bin/zkServer.sh restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#状态查看命令：</span></span><br><span class="line">./bin/zkServer.sh status</span><br></pre></td></tr></table></figure>

<h2 id="伪集群模式"><a href="#伪集群模式" class="headerlink" title="伪集群模式"></a>伪集群模式</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在同一台主机上，通过复制得到三个zookeeper实例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp -r  /usr/soft/zookeeper/Zookeeper   /usr/soft/zookeeper/Zookeeper2</span><br></pre></td></tr></table></figure>



<h3 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h3><p>zookeeper1配置文件conf/zoo.cfg修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper1&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper1&#x2F;logs</span><br><span class="line">clientPort&#x3D;12181</span><br><span class="line"></span><br><span class="line">server.1&#x3D;127.0.0.1:12888:13888</span><br><span class="line">server.2&#x3D;127.0.0.1:14888:15888</span><br><span class="line">server.3&#x3D;127.0.0.1:16888:17888</span><br></pre></td></tr></table></figure>

<p>注：server.1中的数字1为<strong>服务器的ID</strong>，需要与<strong>myid文件中的id一致</strong>，下一步将配置myid</p>
<p>zookeeper1的data/myid配置，使用如下命令（即新建一个文件data/myid，在其中添加内容为：1）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1&#x27;</span> &gt; data/myid</span><br></pre></td></tr></table></figure>

<p>zookeeper2配置文件conf/zoo.cfg修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper2&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper2&#x2F;logs</span><br><span class="line">clientPort&#x3D;12182</span><br><span class="line"></span><br><span class="line">server.1&#x3D;127.0.0.1:12888:13888</span><br><span class="line">server.2&#x3D;127.0.0.1:14888:15888</span><br><span class="line">server.3&#x3D;127.0.0.1:16888:17888</span><br></pre></td></tr></table></figure>

<p>zookeeper2的data/myid配置，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;2&#39; &gt; data&#x2F;myid</span><br></pre></td></tr></table></figure>

<p>zookeeper3配置文件conf/zoo.cfg修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper3&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper3&#x2F;logs</span><br><span class="line">clientPort&#x3D;12183</span><br><span class="line"></span><br><span class="line">server.1&#x3D;127.0.0.1:12888:13888</span><br><span class="line">server.2&#x3D;127.0.0.1:14888:15888</span><br><span class="line">server.3&#x3D;127.0.0.1:16888:17888</span><br></pre></td></tr></table></figure>

<p>zookeeper3的data/myid配置，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;3&#39; &gt; data&#x2F;myid</span><br></pre></td></tr></table></figure>

<p>分别启动三个zookeeper节点</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301134558.png" alt="image-20210301134558405"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301134626.png" alt="image-20210301134626147"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301134728.png" alt="image-20210301134728171"></p>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>参考伪集群模式</p>
<p>　　　　1、在三台机器上分别部署1个ZooKeeper实例</p>
<p>　　　　2、zookeeper配置文件conf/zoo.cfg，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper1&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper1&#x2F;logs</span><br><span class="line">clientPort&#x3D;12181</span><br><span class="line"></span><br><span class="line">server.1&#x3D;127.0.0.1:12888:13888</span><br><span class="line">&#x2F;&#x2F;修改为2，3节点的ip</span><br><span class="line">server.2&#x3D;127.0.0.1:14888:15888</span><br><span class="line">server.3&#x3D;127.0.0.1:16888:17888</span><br></pre></td></tr></table></figure>

<p>3、zookeeper的data/myid配置，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 echo &#39;1&#39; &gt; data&#x2F;myid</span><br></pre></td></tr></table></figure>

<p>zookeeper1 对应的是 1，zookeeper2 对应的是 2，zookeeper3 对应的是 3</p>
<p>　　4、分别启动三个zookeeper节点，即完成对ZooKeeper集群的安装</p>
<h1 id="Zookeeper简单操作"><a href="#Zookeeper简单操作" class="headerlink" title="Zookeeper简单操作"></a>Zookeeper简单操作</h1><p>a、使用客户端连接ZooKeeper服务</p>
<p>　命令：<code>./bin/zkCli.sh -server 127.0.0.1:12181</code></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301140944.png" alt="image-20210301140944047"></p>
<p>b、使用 ls 命令来查看当前 ZooKeeper 中所包含的内容：<br>命令：<font color=blue>ls /</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301141124.png" alt="image-20210301141124292"></p>
<p>c 、创建节点</p>
<p>命令 ：<font color=blue>create /zk myData</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301141402.png" alt="image-20210301141402229"></p>
<p>d、获取节点‘zk’</p>
<p>命令：<font color=blue>get /zk</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301141449.png" alt="image-20210301141449291"></p>
<p>e、删除znode节点“ zk </p>
<p>命令：<font color=blue>delete /zk</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301141725.png" alt="image-20210301141725018"></p>
<p>f、退出客户端</p>
<p>命令：<font color=blue>quit</font></p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性理论，CAP，BASE理论</title>
    <url>/posts/6afaddd1/</url>
    <content><![CDATA[<h1 id="分布式的问题"><a href="#分布式的问题" class="headerlink" title="分布式的问题"></a>分布式的问题</h1><p>分布式因为<strong>网络的不确定性</strong>，<strong>节点故障等情况</strong>，会带来各种复杂的问题。我们在学习分布式的相关理论时，一定要明确这样一个<strong>道理</strong>，就是：网络不可靠，网络分区以及节点宕机是常态，另外网络带宽资源是及其珍贵的，我们<font color=red>必须在网络不可靠、分区以及节点宕机的前提下，构建高性能、高可用的分布式系统</font>。</p>
<h2 id="分布式环境的问题"><a href="#分布式环境的问题" class="headerlink" title="分布式环境的问题"></a>分布式环境的问题</h2><ol>
<li><strong>通信异常</strong>：从集中式向分布式演变过程中，必然会引入网络因素，而由于网络本身的不可靠性，因此也引入了额外的问题。<strong>分布式系统需要在各个节点之间进行网络通信，因此当网络通信设备故障就会导致无法顺利完成一次网络通信，就算各节点的网络通信正常，但是消息丢失和消息延时也是非常普遍的事情</strong>。</li>
<li><strong>网络分区（脑裂）</strong>：网络发生异常情况导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点，只有部分节点能够正常通行，而另一些节点则不能。我们称这种情况叫做网络分区（脑裂），当网络分区出现时，<strong>分布式系统会出现多个局部小集群（多个小集群可能又会产生多个master节点），所以分布式系统要求这些小集群要能独立完成原本需要整个分布式系统才能完成的功能</strong>，这就对分布式一致性提出了非常大的挑战。</li>
<li><strong>节点故障</strong>：节点宕机是分布式环境中的常态，每个节点都有可能会出现宕机或僵死的情况，并且每天都在发生。</li>
<li><strong>三态</strong>：由于网络不可靠的原因，因此<strong>分布式系统的每一次请求，都存在特有的“三态”概念，即：成功，失败与超时</strong>。在集中式单机部署中，由于没有网络因素，所以程序的每一次调用都能得到“成功”或者“失败”的响应，但是在分布式系统中，网络不可靠，可能就会出现超时的情况。<strong>可能在消息发送时丢失或者在响应过程中丢失，当出现超时情况时，网络通信的发起方是无法确定当前请求是否被成功处理的，所以这也是分布式事务的难点</strong>。</li>
</ol>
<h1 id="分布式数据一致性问题"><a href="#分布式数据一致性问题" class="headerlink" title="分布式数据一致性问题"></a>分布式数据一致性问题</h1><p>在分布式系统中，<strong>节点宕机是常态</strong>，为了高可用性，我们一般会部署多台服务器，势必就会存在<strong>数据的复制问题</strong>，分布式系统对于数据的复制需求一般来自于以下两个原因：</p>
<blockquote>
<ul>
<li>高可用：将数据复制到分布式部署的多台机器中，可以消除单点故障，防止系统由于某台（些）机器宕机导致的不可用。</li>
<li>性能：通过负载均衡技术，能够让分布在不同地方的数据副本全都对外提供服务。有效提高系统性能。</li>
</ul>
</blockquote>
<p><strong>在分布式系统引入复制机制后，不同的数据节点之间由于网络延时等原因很容易产生数据不一致的情况</strong>。复制机制的目的是为了保证数据的一致性。但是数据复制面临的主要难题也是如何保证多个副本之间的数据一致性。其中，常见的就是主从数据库之间的复制延时问题。</p>
<blockquote>
<p>Zookeeper就是分布式一致性问题的工业解决方案，paxos是理论算法，其中zab，raft和众多开源算法是对paxos的工业级实现。Zookeeper使用zab来保证其自身系统的高可用与数据一致性的。</p>
</blockquote>
<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p>
<p>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</p>
<p>可用性（A）：保证每个请求不管成功或者失败都有响应。</p>
<p>分区容忍性（P）：系统中任意信息的丢失或失败不会影响系统的继续运作。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302163013.png" alt="image-20210302163013412"></p>
<p>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足</p>
<h2 id="一致性与可用性的决择编辑"><a href="#一致性与可用性的决择编辑" class="headerlink" title="一致性与可用性的决择编辑"></a>一致性与可用性的决择编辑</h2><p>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以<font color=red>分区容忍性是我们必须需要实现的</font>。所以我们<font color=red>只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点</font>。</p>
<p>CAP三个特性只能满足其中两个，那么取舍的策略就共有三种：</p>
<p><strong><font color=red>CA without P</font>：</strong>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。<strong>传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</strong></p>
<p><strong><font color=red>CP without A </font>：</strong>如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，<strong>最典型的就是分布式数据库，如Redis、HBase等</strong>。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p>
<p> <strong><font color=red>AP wihtout C</font>：</strong>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，<font color=red>其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）</font></p>
<h2 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h2><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</p>
<ul>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</li>
<li>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ul>
<p>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据听不的过程存在延时。</p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>最终一致性强调的是<font color=red>系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态</font>。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
        <category>CAP</category>
        <category>BASE理论</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
        <tag>CAP</tag>
        <tag>BASE理论</tag>
      </tags>
  </entry>
  <entry>
    <title>win10添加新建文件md方式以及设置md模版</title>
    <url>/posts/558e0cc4/</url>
    <content><![CDATA[<p><strong><em>务必先创建系统还原点或者备份注册表</em></strong></p>
<h1 id="添加新建方式步骤"><a href="#添加新建方式步骤" class="headerlink" title="添加新建方式步骤"></a>添加新建方式步骤</h1><p>新建<code>temp.txt</code>输入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@&#x3D;&quot;.md&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;&#x3D;&quot;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>把<code>temp.txt</code>改名为<code>temp.reg</code></p>
</li>
<li><p>双击运行，就ok了，有问题记得先重启，如果不行，就采用下面这个</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@&#x3D;&quot;typora.md&quot;</span><br><span class="line">&quot;icon&quot;&#x3D;&quot;E:\\Typora\\bin\\typora.exe&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\OpenWithProgids]</span><br><span class="line">&quot;Typora.md&quot;&#x3D;&quot;&quot;</span><br><span class="line">&quot;VSCode.md&quot;&#x3D;&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;&#x3D;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="配置md文件模版"><a href="#配置md文件模版" class="headerlink" title="配置md文件模版"></a>配置md文件模版</h1><p>1、使用<code>notepad++</code>新建<code>新建 Markdown.md</code>文件，填入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">tags: []</span><br><span class="line">categories:</span><br><span class="line">- []</span><br><span class="line">- []</span><br><span class="line">description: </span><br><span class="line">updated: </span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>将文件移动到不会<strong>轻易删除的文件夹</strong></p>
<p>打开注册表，按如下(没有就创建)</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226105517.png" alt="image-20210226105516945"></p>
]]></content>
      <categories>
        <category>Typora</category>
        <category>Win10</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Win10</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+NexT博客归档/标签/分类页美化</title>
    <url>/posts/be9758cd/</url>
    <content><![CDATA[<p>NexT自带的<code>归档</code>、<code>标签</code>、<code>分类</code>页的样式比较单一，我们可以在样式文件中添加一些<code>css</code>配置来将我们想要的样式添加到这些页面中，本文就来介绍如何添加或修改这些页面的样式。</p>
<h1 id="彩色标签页"><a href="#彩色标签页" class="headerlink" title="彩色标签页"></a>彩色标签页</h1><ol>
<li>在 /themes/next/layout/ 目录下，新增 tag-color.swig 文件，填入如下内容:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">     var alltags &#x3D; document.getElementsByClassName(&#39;tag-cloud-tags&#39;);</span><br><span class="line">     var tags &#x3D; alltags[0].getElementsByTagName(&#39;a&#39;);</span><br><span class="line">     for (var i &#x3D; tags.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">       var r&#x3D;Math.floor(Math.random()*75+130);</span><br><span class="line">       var g&#x3D;Math.floor(Math.random()*75+100);</span><br><span class="line">       var b&#x3D;Math.floor(Math.random()*75+80);</span><br><span class="line">       tags[i].style.background &#x3D; &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    &#x2F;*font-family: Helvetica, Tahoma, Arial;*&#x2F;</span><br><span class="line">    &#x2F;*font-weight: 100;*&#x2F;</span><br><span class="line">    text-align: center;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a&#123;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin: 8px 5px 0px 0px;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a:before&#123;</span><br><span class="line">    content: &quot;🔖&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags a:hover&#123;</span><br><span class="line">     box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4);</span><br><span class="line">     transform: scale(1.1);</span><br><span class="line">     &#x2F;*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*&#x2F;</span><br><span class="line">     transition-duration: 0.15s;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在同级目录的 page.swig 中引入 tag-color.swig</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tag-cloud&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 目前共计xxx个标签</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tag-cloud-title&quot;</span>&gt;</span><br><span class="line">            &#123;&#123; _p(<span class="string">&#x27;counter.tag_cloud&#x27;</span>, site.tags.length) &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        --&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tag-cloud-tags&quot;</span>&gt;</span><br><span class="line">          &#123;&#123; tagcloud(&#123;<span class="attr">min_font</span>: <span class="number">10</span>, <span class="attr">max_font</span>: <span class="number">15</span>, <span class="attr">amount</span>: <span class="number">300</span>, <span class="attr">color</span>: <span class="literal">true</span>, <span class="attr">start_color</span>: <span class="string">&#x27;#ccc&#x27;</span>, <span class="attr">end_color</span>: <span class="string">&#x27;#111&#x27;</span>&#125;) &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">+     &#123;% include <span class="string">&#x27;tag-color.swig&#x27;</span> %&#125;</span><br><span class="line">    </span><br><span class="line">    &#123;% elif page.type === <span class="string">&#x27;categories&#x27;</span> %&#125;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;category-all-page&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;category-all-title&quot;</span>&gt;</span><br><span class="line">            &#123;&#123; _p(<span class="string">&#x27;counter.categories&#x27;</span>, site.categories.length) &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;category-all&quot;</span>&gt;</span><br><span class="line">          &#123;&#123; list_categories() &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>以下是文章底部的标签样式（代码拷入 /themes/next/source/css/_schemes/(自己选择的主题)/index.styl 即可）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*文章底部标签样式*&#x2F;</span><br><span class="line">.posts-expand .post-tags a &#123;</span><br><span class="line">  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, .12), 0 1px 2px rgba(0, 0, 0, .24);</span><br><span class="line">  -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, .12), 0 1px 2px rgba(0, 0, 0, .24);</span><br><span class="line">  box-shadow: 0 1px 3px rgba(0, 0, 0, .12), 0 1px 2px rgba(0, 0, 0, .24);</span><br><span class="line">  font-family: &#39;Comic Sans MS&#39;, sans-serif;</span><br><span class="line">  transition: .2s ease-out;</span><br><span class="line">  padding: 3px 5px;</span><br><span class="line">  margin: 5px;</span><br><span class="line">  background: #f5f5f5;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-radius: 15px;</span><br><span class="line"></span><br><span class="line">  +mobile()&#123;</span><br><span class="line">    padding: 1px 3px;</span><br><span class="line">    font-size: 8px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    background: rgba(100,154,182,0.902);</span><br><span class="line">    color: #fff;</span><br><span class="line">    -webkit-box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);</span><br><span class="line">    -moz-box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);</span><br><span class="line">    box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226130811.png" alt="image-20210226130811067"></p>
<h1 id="归档页美化"><a href="#归档页美化" class="headerlink" title="归档页美化"></a>归档页美化</h1><ol>
<li>修改 /themes/next/ layout/_ macro/post collapse.swig 后的代码如下:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% macro render(posts) %&#125;</span><br><span class="line">&#123;%- set current_year &#x3D; &#39;1970&#39; %&#125;</span><br><span class="line">&#123;%- for post in posts.toArray() %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- set year &#x3D; date(post.date, &#39;YYYY&#39;) %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- if year !&#x3D;&#x3D; current_year %&#125;</span><br><span class="line">    &#123;%- set current_year &#x3D; year %&#125;</span><br><span class="line">    &lt;div class&#x3D;&quot;collection-year&quot;&gt;</span><br><span class="line">      &lt;&#123;%- if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;%- endif %&#125; class&#x3D;&quot;collection-header&quot;&gt;&#123;&#123; current_year &#125;&#125;&lt;&#x2F;&#123;%- if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;%- endif %&#125;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;article class&#x3D;&quot;my-post post-type-&#123;&#123; post.type | default(&#39;normal&#39;) &#125;&#125;&quot; itemscope itemtype&#x3D;&quot;http:&#x2F;&#x2F;schema.org&#x2F;Article&quot;&gt;</span><br><span class="line">    &lt;header class&#x3D;&quot;my-post-header&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div class&#x3D;&quot;my-post-meta&quot;&gt;</span><br><span class="line">        &lt;time class&#x3D;&quot;my-post-time&quot; itemprop&#x3D;&quot;dateCreated&quot;</span><br><span class="line">              datetime&#x3D;&quot;&#123;&#123; moment(post.date).format() &#125;&#125;&quot;</span><br><span class="line">              content&#x3D;&quot;&#123;&#123; date(post.date, config.date_format) &#125;&#125;&quot;&gt;</span><br><span class="line">          &#123;&#123; date(post.date, &#39;MM-DD&#39;) &#125;&#125;</span><br><span class="line">        &lt;&#x2F;time&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;&#123;%- if theme.seo %&#125;h3&#123;% else %&#125;h2&#123;%- endif %&#125; class&#x3D;&quot;my-post-title&quot;&gt;</span><br><span class="line">        &#123;%- if post.link %&#125;&#123;# Link posts #&#125;</span><br><span class="line">          &lt;a class&#x3D;&quot;my-post-title-link post-title-link-external&quot; target&#x3D;&quot;_blank&quot; href&#x3D;&quot;&#123;&#123; url_for(post.link) &#125;&#125;&quot; itemprop&#x3D;&quot;url&quot;&gt;</span><br><span class="line">            &#123;&#123; post.title or post.link &#125;&#125;</span><br><span class="line">            &lt;i class&#x3D;&quot;fa fa-external-link&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">          &lt;&#x2F;a&gt;</span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">          &lt;a class&#x3D;&quot;my-post-title-link&quot; href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; itemprop&#x3D;&quot;url&quot;&gt;</span><br><span class="line">            &#123;% if post.type &#x3D;&#x3D;&#x3D; &#39;picture&#39; %&#125;</span><br><span class="line">              &#123;&#123; post.content &#125;&#125;</span><br><span class="line">            &#123;% else %&#125;</span><br><span class="line">              &lt;span itemprop&#x3D;&quot;name&quot;&gt;&#123;&#123; post.title or __(&#39;post.untitled&#39;) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">          &lt;&#x2F;a&gt;</span><br><span class="line">        &#123;%- endif %&#125;</span><br><span class="line">      &lt;&#x2F;&#123;%- if theme.seo %&#125;h3&#123;% else %&#125;h2&#123;%- endif %&#125;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;header&gt;</span><br><span class="line">  &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">&#123;%- endfor %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure>

<p>主要修改：一是将 post-meta这个div移到前面header 标签下；二是将所有的 class 属性都加上 my-，例如 my-post-meta，这样改动是为了不影响其它页面引用的样式。</p>
<ol>
<li>在 /themes/next/source/css/_schemes/(自己选择的主题)/index.styl 新增如下样式：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 归档页样式 began *&#x2F;</span><br><span class="line">.page-archive .archive-page-counter &#123;</span><br><span class="line">  font-size: 18px;</span><br><span class="line">  background-color: #49b1f5;</span><br><span class="line">  padding-left: 10px;</span><br><span class="line">  padding-right: 10px;</span><br><span class="line">  border-radius: 8px;</span><br><span class="line">  color: #fff;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.my-post-time&#123;</span><br><span class="line">  font-size: 11px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  color: #fff;</span><br><span class="line">  background-color: #49b1f5;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">  padding-left: 5px;</span><br><span class="line">  padding-right: 5px;</span><br><span class="line">  margin-left: 15px;</span><br><span class="line">&#125;</span><br><span class="line">.mypost&#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  margin-bottom: 1rem;</span><br><span class="line">  -webkit-transition: all .2s ease-in-out;</span><br><span class="line">  -moz-transition: all .2s ease-in-out;</span><br><span class="line">  -o-transition: all .2s ease-in-out;</span><br><span class="line">  -ms-transition: all .2s ease-in-out;</span><br><span class="line">  transition: all .2s ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line">a.my-post-title-link:before&#123;</span><br><span class="line">  top: 10px;</span><br><span class="line">  width: 18px;</span><br><span class="line">  height: 18px;</span><br><span class="line">  content: &quot;📚&quot;;</span><br><span class="line">  margin-right: 5px;</span><br><span class="line">  font: normal normal normal 14px&#x2F;1 FontAwesome;</span><br><span class="line">  font-size: 15px;</span><br><span class="line">  line-height: 18px;</span><br><span class="line">&#125;</span><br><span class="line">.my-post:hover&#123;</span><br><span class="line">  transform: scale(1.1);</span><br><span class="line">  box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);</span><br><span class="line">  border-radius: 30px;</span><br><span class="line">  width: 400px;</span><br><span class="line">  padding: 1px 10px;</span><br><span class="line">  margin-left: 25px;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  transition-duration: 0.15s;</span><br><span class="line">  +mobile()&#123;</span><br><span class="line">    width: 260px;</span><br><span class="line">    margin-left: 18px;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;display:flex;</span><br><span class="line">&#125;</span><br><span class="line">a.my-post-title-link&#123;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  font-size: 15px;</span><br><span class="line">  font-weight: 400;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.my-post-title&#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin-left: 4.5rem;</span><br><span class="line">  color: #4c4948;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  font-size: .8rem;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    &#x2F;&#x2F;margin-left: 4rem;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.my-post-header&#123;</span><br><span class="line">  position: top;</span><br><span class="line">  margin-bottom: 1rem;</span><br><span class="line">  -webkit-transition: all .2s ease-in-out;</span><br><span class="line">  -moz-transition: all .2s ease-in-out;</span><br><span class="line">  -o-transition: all .2s ease-in-out;</span><br><span class="line">  -ms-transition: all .2s ease-in-out;</span><br><span class="line">  transition: all .2s ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;.my-post-title-link&#123;</span><br><span class="line">&#x2F;&#x2F;  font-size: 16px;</span><br><span class="line">&#x2F;&#x2F;  font-weight: 500;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">.my-post-meta&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  color: #99a9bf;</span><br><span class="line">  width: 80px;</span><br><span class="line">  color: #114142;</span><br><span class="line">&#125;</span><br><span class="line">div.post-block.tag .collection-title h2 &#123;</span><br><span class="line">  border-width: 1px;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: #3f3f3f;</span><br><span class="line">  border-radius: 20px;</span><br><span class="line">  font-size: 22px;</span><br><span class="line">  background-color: #b4e8fa;</span><br><span class="line">  padding: 2px 15px;</span><br><span class="line">  letter-spacing: 1.5px;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  color: #3f3f3f;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin: 10px 0 10px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  +mobile()&#123;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 归档页样式 end *&#x2F;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><a href="https://img-blog.csdnimg.cn/20200720163209724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTY5Mzgz,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200720163209724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTY5Mzgz,size_16,color_FFFFFF,t_70" alt="img"></a></p>
<h1 id="分类页美化"><a href="#分类页美化" class="headerlink" title="分类页美化"></a>分类页美化</h1><p>在 /themes/next/source/css/_schemes/(自己选择的主题)/index.styl 新增如下样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 分类页样式 began *&#x2F;</span><br><span class="line">.category-list-link:hover&#123;</span><br><span class="line">  transform: scale(1.1);</span><br><span class="line">  box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);</span><br><span class="line">  border-radius: 15px;</span><br><span class="line">  padding: 6px 16px;</span><br><span class="line">  margin-left: 0px;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  transition-duration: 0.15s;</span><br><span class="line">  &#x2F;&#x2F;display:flex;</span><br><span class="line">&#125;</span><br><span class="line">a.category-list-link:before&#123;</span><br><span class="line">  top: 10px;</span><br><span class="line">  width: 18px;</span><br><span class="line">  height: 18px;</span><br><span class="line">  content: &quot;📚&quot;;</span><br><span class="line">  margin-right: 5px;</span><br><span class="line">  font: normal normal normal 14px&#x2F;1 FontAwesome;</span><br><span class="line">  font-size: 15px;</span><br><span class="line">  line-height: 18px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 分类页样式 end *&#x2F;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><a href="https://img-blog.csdnimg.cn/20200720172136778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTY5Mzgz,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200720172136778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTY5Mzgz,size_16,color_FFFFFF,t_70" alt="img"></a></p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>修复点击目录无法跳转</title>
    <url>/posts/14f8dec7/</url>
    <content><![CDATA[<p>在 themes/next/source/js/util.js 中增加两行代码，删除两行代码。保存，hexo clean &amp; hexo g &amp; hexo s 即可解决。（如果还是不行就删除浏览器缓存重试）</p>
<p><a href="https://github.com/theme-next/hexo-theme-next/pull/1540/files">中文目录层级无法跳转</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210225115114.png" alt="image-20210225115114883"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">registerSidebarTOC: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> navItems = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.post-toc li&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> sections = [...navItems].map(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> link = element.querySelector(<span class="string">&#x27;a.nav-link&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(<span class="built_in">decodeURI</span>(link.getAttribute(<span class="string">&#x27;href&#x27;</span>)).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    <span class="comment">// TOC item animation navigate.</span></span><br><span class="line">    link.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">      <span class="comment">// var target = document.getElementById(event.currentTarget.getAttribute(&#x27;href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;));</span></span><br><span class="line">      <span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br><span class="line">      <span class="built_in">window</span>.anime(&#123;</span><br><span class="line">        targets  : <span class="built_in">document</span>.scrollingElement,</span><br><span class="line">        duration : <span class="number">500</span>,</span><br><span class="line">        easing   : <span class="string">&#x27;linear&#x27;</span>,</span><br><span class="line">        scrollTop: offset + <span class="number">10</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">    <span class="comment">// return document.getElementById(link.getAttribute(&#x27;href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;));</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客优化Next7主题优化</title>
    <url>/posts/33ffdf26/</url>
    <content><![CDATA[<h5 id="1-设置站点名等"><a href="#1-设置站点名等" class="headerlink" title="1.设置站点名等"></a>1.设置站点名等</h5><p>打开<strong>根目录下的<code>_config.yml</code></strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">三才生的个人笔记</span>   <span class="comment">#标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">三才生的个人笔记</span>  <span class="comment">#标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">三才生的个人笔记</span> <span class="comment">#标题</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">CNRF</span>     <span class="comment">#作者名称</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>  <span class="comment">#设置简体中文</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">UTC</span>	<span class="comment">#设置时区</span></span><br></pre></td></tr></table></figure>



<h5 id="2-选择scheme"><a href="#2-选择scheme" class="headerlink" title="2.选择scheme"></a>2.选择scheme</h5><p>在主目录的\source_data\next.yml中，,查找<code>scheme</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>

<h5 id="3-设置菜单及对应页面"><a href="#3-设置菜单及对应页面" class="headerlink" title="3. 设置菜单及对应页面"></a>3. 设置菜单及对应页面</h5><p>在主目录的\source_data\next.yml中，查找<code>menu</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">heartbeat</span></span><br></pre></td></tr></table></figure>

<p>去掉<code>#</code>注释即可显示对应的菜单项，也可自定义新的菜单项。 <code>||</code>之前的值是目标链接，之后的是分类页面的图标，图标名称来自于FontAwesome icon。若没有配置图标，默认会使用问号图标。</p>
<p>新添加的菜单需要翻译对应的中文<br>打开<code>hexo/theme/next/languages/zh-CN.yml</code>，在menu下自定义，如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">资源</span></span><br></pre></td></tr></table></figure>

<p>配置新增的菜单</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;commonweal&quot;</span><br></pre></td></tr></table></figure>

<p>在<strong>主目录下source</strong>新建404.html</p>
<blockquote>
<p><strong>Hexo 默认会渲染所有的 HTML 和 Markdown 文件</strong>。</p>
</blockquote>
<p>因此我们可以简单地在文件开头加上 <code>layout: false</code> 一行来避免渲染：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+layout: false</span><br><span class="line">+---</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>404<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">homePageUrl</span>=<span class="string">&quot;/&quot;</span> <span class="attr">homePageName</span>=<span class="string">&quot;返回&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="4-设定站点建立时间"><a href="#4-设定站点建立时间" class="headerlink" title="4. 设定站点建立时间"></a>4. 设定站点建立时间</h5><p>打开**<code>themes/next/</code>下的<code>_config.yml</code>**，查找<code>since</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup.</span></span><br><span class="line">  <span class="comment"># If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2015</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如果不设置，默认显示当前年份</strong>。</p>
<h5 id="5-设置头像"><a href="#5-设置头像" class="headerlink" title="5.设置头像"></a>5.设置头像</h5><p>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>avatar</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar111.png</span>  <span class="comment"># 设置头像资源的位置</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span>            <span class="comment"># 开启圆形头像</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1</span>               <span class="comment"># 不透明的比例：0就是完全透明</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span>           <span class="comment"># 不开启旋转</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224210106.png" alt="image-20210224210106776"></p>
<p><code>avatar</code>的值是<strong>图片的链接地址</strong>(完整的URI 或者 站内的相对地址皆可)</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>完整的URI</td>
<td><a href="http://example.com/avatar.png">http://example.com/avatar.png</a></td>
</tr>
<tr>
<td>站点内地址</td>
<td>图片放至<code>themes/next/source/images/</code>配置为：<code>avatar: /images/图片名</code></td>
</tr>
<tr>
<td>站点内地址</td>
<td>图片放至<strong>根目录下</strong><code>source/uploads/</code>(初始无uploads文件夹，自行创建)目录下配置为：<code>avatar: /uploads/图片名</code></td>
</tr>
</tbody></table>
<h5 id="6-网站图标设置"><a href="#6-网站图标设置" class="headerlink" title="6. 网站图标设置"></a>6. 网站图标设置</h5><ul>
<li><p>图标素材网站：<a href="https://www.iconfont.cn/">iconfont</a>；<a href="https://www.easyicon.net/">easyicon</a></p>
</li>
<li><p>下载16x16以及32x32大小的<strong>PNG格式图标</strong>，置于<code>/themes/next/source/images/</code>下</p>
</li>
<li><p>打开**<code>source/_data</code>下的<code>next.yml</code>**，查找<code>favicon</code></p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>

<p>  修改small和medium的路径为下载的图标路径</p>
</li>
</ul>
<h5 id="7-配置hexo本地搜索"><a href="#7-配置hexo本地搜索" class="headerlink" title="7.配置hexo本地搜索"></a>7.配置hexo本地搜索</h5><h6 id="7-1-本地搜索的原理"><a href="#7-1-本地搜索的原理" class="headerlink" title="7.1 本地搜索的原理"></a>7.1 本地搜索的原理</h6><p>对于动态网站来说，可以通过 php 实现。但是，Hexo 博客是静态网站，用不了 php。</p>
<p>NexT 主题已经实现这个功能，它用了 Hexo 的拓展包 <code>hexo-generator-searchdb</code>，预先生成了一个文本库 <code>search.xml</code>，然后传到了网站里面。在本地搜索的时候，NexT 直接用 javascript 调用了这个文件，从而实现了静态网站的本地搜索。</p>
<h6 id="7-2-设置过程"><a href="#7-2-设置过程" class="headerlink" title="7.2 设置过程"></a>7.2 设置过程</h6><p>安装插件:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save #安装 hexo-generator-search</span><br><span class="line">npm install hexo-generator-searchdb --save #安装 hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p>然后我们修改站点配置<code>_config.yml</code> 文件，添加如下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<ul>
<li>path：索引文件的路径，相对于站点根目录</li>
<li>field：搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面</li>
<li>limit：限制搜索的条目数</li>
</ul>
<p>然后修改主题配置文件next.yml`：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h5 id="8-配置-hexo-站点的-footer-信息"><a href="#8-配置-hexo-站点的-footer-信息" class="headerlink" title="8 配置 hexo 站点的 footer 信息"></a>8 配置 hexo 站点的 footer 信息</h5><p>底部 <code>footer</code> 可以开关显示 hexo 信息、theme 信息、建站时间等个性化配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span>        <span class="comment"># 建站开始时间</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span>       <span class="comment"># 设置 建站初始时间和至今时间中间的图标，默认是一个&#x27;小人像&#x27;，更改user为heart可以变成一个心</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span> <span class="comment"># 更改图标的颜色，红色为&#x27;#ff0000&#x27;</span></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>     <span class="comment"># 开启hexo驱动</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span>    <span class="comment"># 开启hexo版本号</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>     <span class="comment"># 开启主题驱动</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span>    <span class="comment"># 开启主题版本号</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">Hosted</span> <span class="string">by</span> <span class="string">&lt;a</span> <span class="string">target=&quot;_blank&quot;</span> <span class="string">rel=&quot;external</span> <span class="string">nofollow&quot;</span> <span class="string">href=&quot;https://pages.coding.me&quot;&gt;&lt;b&gt;Coding</span> <span class="string">Pages&lt;/b&gt;&lt;/a&gt;</span> <span class="comment"># 这里的底部标识是为了添加coding page服务时的版权声明 打开注释就可以看到底部有一个 hosted by coding pages</span></span><br></pre></td></tr></table></figure>

<h6 id="9-首页文章不展示全文显示摘要"><a href="#9-首页文章不展示全文显示摘要" class="headerlink" title="9. 首页文章不展示全文显示摘要"></a>9. 首页文章不展示全文显示摘要</h6><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">true</span>      <span class="comment"># 点击阅读全文后是否跳到&lt;!--more--&gt;标记处,设为false时点击阅读全文可以从头阅读</span></span><br><span class="line"></span><br><span class="line"><span class="attr">save_scroll:</span> <span class="literal">false</span>        <span class="comment"># 自动保存每篇文章或页面上一次滚动的地方</span></span><br><span class="line"></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span> <span class="comment"># 自动在首页对文章进行摘要描述作为前言文本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">auto_excerpt:</span>   <span class="comment"># 是否自动截取摘要</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># 设置为true则自动截取150字当做首页摘要</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span>   <span class="comment"># 自动截取的字数</span></span><br></pre></td></tr></table></figure>

<p>注意需要在md文件前面加<strong>yaml front matter</strong>中相关元素</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">centos安装redis</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-01 23:47:44</span> </span><br><span class="line"><span class="attr">categories:</span> <span class="string">&quot;redis&quot;</span> </span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line">     <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">标签二</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;centos7 安装redis&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="9-首页文章属性"><a href="#9-首页文章属性" class="headerlink" title="9. 首页文章属性"></a>9. 首页文章属性</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">false</span>    <span class="comment"># 设为true 可以一行显示，文章的所有属性</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span>    <span class="comment"># 显示创建时间</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>     <span class="comment"># 显示修改的时间</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span> <span class="comment"># 设true时，如果创建时间和修改时间一样则显示一个时间</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span>    <span class="comment"># 显示分类信息</span></span><br></pre></td></tr></table></figure>

<h5 id="10-页面阅读统计"><a href="#10-页面阅读统计" class="headerlink" title="10. 页面阅读统计"></a>10. 页面阅读统计</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>              <span class="comment"># 设true 开启</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>       <span class="comment"># 总阅读人数（uv数）</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span>  <span class="comment"># 阅读总人数的图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>          <span class="comment"># 总阅读次数（pv数）</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span>      <span class="comment"># 阅读总次数的图标</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>           <span class="comment"># 开启内容阅读次数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span>       <span class="comment"># 内容页阅读数的图标</span></span><br></pre></td></tr></table></figure>

<h5 id="11-字数统计、阅读时长"><a href="#11-字数统计、阅读时长" class="headerlink" title="11. 字数统计、阅读时长"></a>11. 字数统计、阅读时长</h5><p>首先安装插件：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-<span class="built_in">time</span> --save #运行一次会报错导致配置不生效</span><br><span class="line">npm install hexo-symbols-count-<span class="built_in">time</span> --save</span><br></pre></td></tr></table></figure>

<p>主题配置文件<code>_config.yml</code> 修改如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>  <span class="comment"># false会显示一行</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>  <span class="comment"># 显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span> <span class="comment"># 底部footer是否显示字数统计属性文字</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>                <span class="comment"># 计算字数的一个设置,没设置过</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>              <span class="comment"># 一分钟阅读的字数</span></span><br></pre></td></tr></table></figure>

<p>站点配置文件<code>next.yml</code> 新增如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"> <span class="comment">#文章内是否显示</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line"> <span class="comment"># 网页底部是否显示</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h5 id="12-内容页里的代码块新增复制按钮"><a href="#12-内容页里的代码块新增复制按钮" class="headerlink" title="12. 内容页里的代码块新增复制按钮"></a>12. 内容页里的代码块新增复制按钮</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>      <span class="comment"># 增加复制按钮的开关</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">false</span> <span class="comment"># 点击复制完后是否显示 复制成功 结果提示</span></span><br></pre></td></tr></table></figure>

<h5 id="13-鼠标点击特效"><a href="#13-鼠标点击特效" class="headerlink" title="13. 鼠标点击特效"></a>13. 鼠标点击特效</h5><p>鼠标的点击红心特效<br>在/themes/next/source/js/src下新建文件clicklove.js ，接着把下面的代码拷贝粘贴到 clicklove.js 文件中：7.8 next没有src文件夹，先建一个src文件夹</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">&quot;left:&quot;</span>+d[e].x+<span class="string">&quot;px;top:&quot;</span>+d[e].y+<span class="string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="string">&quot;,&quot;</span>+d[e].scale+<span class="string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">&quot;function&quot;</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;div&quot;</span>);a.className=<span class="string">&quot;heart&quot;</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX-<span class="number">5</span>,<span class="attr">y</span>:e.clientY-<span class="number">5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;style&quot;</span>);a.type=<span class="string">&quot;text/css&quot;</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">&quot;rgb(&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;)&quot;</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">setTimeout</span>(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在\themes\next\layout_layout.swig文件末尾添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/src/clicklove.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224214118.png" alt="image-20210224214118864"></p>
<h5 id="14-添加网页顶部进度加载条"><a href="#14-添加网页顶部进度加载条" class="headerlink" title="14. 添加网页顶部进度加载条"></a>14. 添加网页顶部进度加载条</h5><p>在主目录下载安装Progress module，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-pace source&#x2F;lib&#x2F;pace</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="comment">#theme: minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">pace-theme-minimal</span></span><br></pre></td></tr></table></figure>

<h5 id="15-Footer-页脚设置"><a href="#15-Footer-页脚设置" class="headerlink" title="15. Footer / 页脚设置"></a>15. Footer / 页脚设置</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2015</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="comment">## 图标的一个动画效果，类似于心跳</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="comment"># 图标颜色，可格局需要自行修改</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Powered by Hexo 字样，不喜欢可以设置为 false</span></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 主题字样，不喜欢可以 false</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Beian ICP and gongan information for Chinese users. See: http://www.beian.miit.gov.cn, http://www.beian.gov.cn</span></span><br><span class="line">  <span class="comment"># 备案信息，如果网站有备案号，可以在这里填写备案号</span></span><br><span class="line">  <span class="attr">beian:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">icp:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="16-Creative-Commons-文章版权"><a href="#16-Creative-Commons-文章版权" class="headerlink" title="16. Creative Commons / 文章版权"></a>16. Creative Commons / 文章版权</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span></span><br><span class="line"><span class="comment"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<p>在文章 .md 文件中的上部，添加 copyright: true。</p>
<h5 id="17-开启文章目录"><a href="#17-开启文章目录" class="headerlink" title="17.开启文章目录"></a>17.开启文章目录</h5><p>修改主题配置文件<strong>next.ym</strong>l</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Table of Contents in the Sidebar</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front-matter.</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="18-GitHub-Fork-Me"><a href="#18-GitHub-Fork-Me" class="headerlink" title="18. GitHub Fork Me"></a>18. GitHub Fork Me</h5><p>修改主题配置文件<strong>next.ym</strong>l</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/CNRF</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="19-bookmark"><a href="#19-bookmark" class="headerlink" title="19.bookmark"></a>19.bookmark</h5><p>Bookmark是一个插件，允许用户保存他们的阅读进度。用户只需单击页面左上角的书签图标即可保存滚动位置。当他们下次访问您的博客时，他们可以自动恢复每个页面的最后滚动位置。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bookmark:</span>	</span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize the color of the bookmark.	</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#222&quot;</span>	</span><br><span class="line">  <span class="comment"># If auto, save the reading progress when closing the page or clicking the bookmark-icon.	</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.	</span></span><br><span class="line">  <span class="attr">save:</span> <span class="string">auto</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="20-添加lazyload"><a href="#20-添加lazyload" class="headerlink" title="20. 添加lazyload"></a>20. 添加lazyload</h5><p>对于图片进行延迟加载，访问到图片位置时才去请求图片资源，这样可以提高博客的访问速度，节省流量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-jquery-lazyload source&#x2F;lib&#x2F;jquery_lazyload</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="21-显示当前浏览进度"><a href="#21-显示当前浏览进度" class="headerlink" title="21.显示当前浏览进度"></a>21.显示当前浏览进度</h5><p>修改主题配置文件<strong>next.ym</strong>l</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Scroll percent label in b2t button.# # 是否显示页面浏览百分比</span></span><br><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224220253.png" alt="image-20210224220253001"></p>
<h5 id="22-支持数学公式"><a href="#22-支持数学公式" class="headerlink" title="22. 支持数学公式"></a>22. 支持数学公式</h5><p>可能在一些情况下我们需要写一个公式，makdown是支持的，next也支持。</p>
<p>Next 主题提供了两个渲染引擎，分别是 mathjax 和katex，后者相对前者来说渲染速度更快，而且不需要 JavaScript 的额外支持，但后者支持的功能现在还不如前者丰富，具体的对比可以看官方文档：<a href="https://theme-next.org/docs/third-party-services/math-equations%E3%80%82">https://theme-next.org/docs/third-party-services/math-equations。</a></p>
<p>这里选择 mathjax ,通过修改配置即可启用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm uninstall hexo-renderer-marked --save</span><br><span class="line">sudo npm install hexo-renderer-kramed --save</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>注意：使用的时候需要在 <strong>文章开头加上mathjax: true</strong></p>
<h5 id="23-添加音乐和视频"><a href="#23-添加音乐和视频" class="headerlink" title="23.添加音乐和视频"></a>23.添加音乐和视频</h5><h6 id="2-3-2-网易云"><a href="#2-3-2-网易云" class="headerlink" title="2.3.2 网易云"></a>2.3.2 网易云</h6><p>打开网易云，找到你想要添加的歌曲或者歌单，点生成<code>外链播放器</code> 然后复制代码</p>
<p>将代码放到…<code>/themes/hexo-theme-next/layout/_macro/sidebar.swig</code>文件下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--新增163播放器--&gt;</span><br><span class="line">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;298 height&#x3D;52 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;0&amp;id&#x3D;756579097&amp;auto&#x3D;0&amp;height&#x3D;32&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210225094310.png" alt="image-20210225094310438"></p>
<h6 id="2-3-1-视频"><a href="#2-3-1-视频" class="headerlink" title="2.3.1 视频"></a>2.3.1 视频</h6><p>1）直接用 HTML 的标签，写法如下：</p>
<p>复制<br>Your browser does not support the video tag.<br>2）用插件，可支持弹幕，首先在站点文件夹根目录安装插件：</p>
<p>复制<br>npm install hexo-tag-dplayer –save<br>然后文章中的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% dplayer “url&#x3D;https:&#x2F;&#x2F;什么什么什么.mp4” “https:&#x2F;&#x2F;封面图.jpg” “api&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer&#x2F;” “id&#x3D;” “loop&#x3D;false” %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% dplayer &quot;url&#x3D;https:&#x2F;&#x2F;moeplayer.b0.upaiyun.com&#x2F;dplayer&#x2F;hikarunara.mp4&quot; &quot;api&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer3&#x2F;&quot; &quot;addition&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer3&#x2F;v2&#x2F;bilibili?aid&#x3D;120040&quot; &quot;pic&#x3D;https:&#x2F;&#x2F;moeplayer.b0.upaiyun.com&#x2F;dplayer&#x2F;hikarunara.jpg&quot; &quot;id&#x3D;9E2E3368B56CDBB4&quot; &quot;loop&#x3D;yes&quot; &quot;theme&#x3D;#FADFA3&quot; &quot;autoplay&#x3D;false&quot; &quot;token&#x3D;tokendemo&quot; %&#125;  </span><br><span class="line">&#123;% dplayer &#39;url&#x3D;some.mp4&#39; &quot;id&#x3D;someid&quot; &quot;api&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer&#x2F;&quot; &quot;addition&#x3D;&#x2F;some.json&quot; &#39;code&#x3D;player.on(&quot;loadstart&quot;,function()&#123;console.log(&quot;loadstart&quot;)&#125;)&#39; &quot;autoplay&quot; %&#125;</span><br></pre></td></tr></table></figure>

<p>要使用弹幕，必须有api和id两项，并且若使用的是官方的 api 地址（即上面的），id 的值不能与这个列表的值一样。id 的值自己随便取，唯一要求就是前面这点。如果唯一要求难倒了你，可以使用这个工具将一段与众不同的文字?生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。</p>
<p>要使用弹幕，必须有api和id两项，并且若使用的是官方的 api 地址（即上面的），id 的值不能与这个列表的值一样。id 的值自己随便取，唯一要求就是前面这点。如果唯一要求难倒了你，可以使用这个工具将一段与众不同的文字?生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。</p>
<p>当然，这个插件的功能还有很多，可以去 README 和这插件的「母亲」Dplayer 的官方文档看看。</p>
<h5 id="24-文章末尾统一添加“本文结束”标记"><a href="#24-文章末尾统一添加“本文结束”标记" class="headerlink" title="24. 文章末尾统一添加“本文结束”标记"></a>24. 文章末尾统一添加“本文结束”标记</h5><p>修改主题配置文件<strong>next.ym</strong>l</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">postBodyEnd:</span> <span class="string">source/_data/post-body-end.swig</span></span><br></pre></td></tr></table></figure>

<p>在路径 /source/_data 下创建/修改 post-body-end.swig文件，并添加以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">&quot;text-align:center;color: #ccc;font-size:14px;&quot;</span>&gt;-------------本文结束&lt;i class=<span class="string">&quot;fa fa-paw&quot;</span>&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h5 id="25-主题及标题栏背景图"><a href="#25-主题及标题栏背景图" class="headerlink" title="25.主题及标题栏背景图"></a>25.主题及标题栏背景图</h5><p>首先主题配置文件取消注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: <span class="built_in">source</span>/_data/styles.styl</span><br></pre></td></tr></table></figure>

<p>在主目录source/_data创建/修改 <strong>styles.styl</strong>文件，并添加以下内容</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  background: url(https://source.unsplash.com/random/1600x900?wallpapers);//自己喜欢的图片地址</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>:fixed; <span class="comment">//不重复</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;      <span class="comment">//填充</span></span><br><span class="line">  <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//博客内容透明化</span></span><br><span class="line"><span class="comment">//文章内容的透明度设置</span></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单栏的透明度设置</span></span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索框（local-search）的透明度设置</span></span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="26-修改文章底部的-号的标签，改为图标"><a href="#26-修改文章底部的-号的标签，改为图标" class="headerlink" title="26.  修改文章底部的#号的标签，改为图标"></a>26.  修改文章底部的#号的标签，改为图标</h5><p>修改模板<code>/themes/next/layout/_macro/post.swig</code></p>
<p>搜索 rel=”tag”，修改此行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;a href&#x3D;&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel&#x3D;&quot;tag&quot;&gt;&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">替换为</span><br><span class="line"> &lt;a href&#x3D;&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel&#x3D;&quot;tag&quot;&gt;&lt;i class&#x3D;&quot;fa fa-tag&quot;&gt;&lt;&#x2F;i&gt; &#123;&#123; tag.name &#125;&#125;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h5 id="27-修改文章链接"><a href="#27-修改文章链接" class="headerlink" title="27.修改文章链接"></a>27.修改文章链接</h5><p>在做次优化之前，hexo-next文章链接默认的生成规则是：<code>:year/:month/:day/:title</code>，是按照年、月、日、标题来生成的。<br>比如：<code>https://zxiaoxuan.github.io/2019/08/12/hello-world/</code> 这样，如果文章标题是中文的话，URL链接是也会是中文，</p>
<p><strong>安装插件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行此命令可能会不成功，提示你缺少相应的依赖，比如babel-eslint、mini-css-extract-plugin、webpack-cli…<br>使用npm命令安装即可，比如npm install <a href="mailto:&#x65;&#115;&#x6c;&#105;&#110;&#116;&#x40;&#x34;&#46;&#x78;">&#x65;&#115;&#x6c;&#105;&#110;&#116;&#x40;&#x34;&#46;&#x78;</a> babel-eslint@8 –save-dev</p>
</blockquote>
<p>修改根目录站点配置文件<code>config.yml</code>，改为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">	<span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">	<span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>生成的链接将会是这样的(官方样例)：<br><strong>四种可供选择</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;66c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;65535.html</span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;8ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;1690090958.html</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<p>生成完后，原<code>md</code>文件的<code>Front-matter</code> 内会增加<code>abbrlink</code> 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。</p>
<h5 id="28-设置tag界面彩色标签"><a href="#28-设置tag界面彩色标签" class="headerlink" title="28. 设置tag界面彩色标签"></a>28. 设置tag界面彩色标签</h5><p>在<code>/themes/next/layout/</code>目录下，新增<code>tag-color.swig</code>文件，加入下方代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">     <span class="keyword">var</span> alltags = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;tag-cloud-tags&#x27;</span>);</span><br><span class="line">     <span class="keyword">var</span> tags = alltags[<span class="number">0</span>].getElementsByTagName(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = tags.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">       <span class="keyword">var</span> r=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">75</span>+<span class="number">130</span>);</span><br><span class="line">       <span class="keyword">var</span> g=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">75</span>+<span class="number">100</span>);</span><br><span class="line">       <span class="keyword">var</span> b=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">75</span>+<span class="number">80</span>);</span><br><span class="line">       tags[i].style.background = <span class="string">&quot;rgb(&quot;</span>+r+<span class="string">&quot;,&quot;</span>+g+<span class="string">&quot;,&quot;</span>+b+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    <span class="comment">/*font-family: Helvetica, Tahoma, Arial;*/</span></span><br><span class="line">    <span class="comment">/*font-weight: 100;*/</span></span><br><span class="line">    text-align: center;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a&#123;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin: 8px 5px 0px 0px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags a:hover&#123;</span><br><span class="line">     box-shadow: 0px 5px 15px 0px rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.4</span>);</span><br><span class="line">     transform: scale(<span class="number">1.1</span>);</span><br><span class="line">     <span class="comment">/*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*/</span></span><br><span class="line">     transition-duration: <span class="number">0.</span>15s;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在/themes/next/layout/page.swig/中引入tag-color.swig：</p>
<p>在下方加上 <code>&#123;% include 'tag-color.swig' %&#125;</code> 代码</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224235234.png" alt="image-20210224235234310"></p>
<h6 id="把标签放到首页"><a href="#把标签放到首页" class="headerlink" title="把标签放到首页"></a>把标签放到首页</h6><p>在路径：<code>/themes/next/layout/index.swig</code> 中<code>&#123;% block content %&#125;</code>下面添加下方代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;tag-cloud&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;tag-cloud-tags&quot; id&#x3D;&quot;tags&quot;&gt;</span><br><span class="line">	&#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &#39;#fff&#39;, end_color: &#39;#fff&#39;&#125;) &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&#123;% include &#39;tag-color.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224235556.png" alt="image-20210224235556099"></p>
<h5 id="29-归档页面增加月份归档"><a href="#29-归档页面增加月份归档" class="headerlink" title="29.归档页面增加月份归档"></a>29.归档页面增加月份归档</h5><p>在==themes/next/source/css/_common/components/post/post-collapse.styl==新增代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置也月份样式</span></span><br><span class="line">.collection-month &#123; <span class="comment">//属性不一定是这个名字，具体和你在swig文件中为其配置的class值有关，照着它来</span></span><br><span class="line">  font-size: $font-size-largest;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  margin: 60px <span class="number">0</span>;</span><br><span class="line">  position: relative;</span><br><span class="line"></span><br><span class="line">  &amp;::before &#123;</span><br><span class="line">    background: $grey;</span><br><span class="line">    border-radius: <span class="number">50</span>%;</span><br><span class="line">    content: <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    height: 8px;</span><br><span class="line">    left: <span class="number">0</span>;</span><br><span class="line">    margin-left: -4px;</span><br><span class="line">    margin-top: -4px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">50</span>%;</span><br><span class="line">    width: 8px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在==themes/next/layout/_macro/post-collapse.swig==中新增代码，位置如图</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">===========================================</span><br><span class="line">     &#123;%- set current_month = <span class="string">&#x27;0&#x27;</span> %&#125;</span><br><span class="line">===========================================</span><br><span class="line"> &#123;%- set month = date(post.date, <span class="string">&#x27;MMM&#x27;</span>) %&#125;</span><br><span class="line">  &#123;%- <span class="keyword">if</span> month !== current_month %&#125;</span><br><span class="line">    &#123;%- set current_month = month %&#125;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;collection-month&quot;</span>&gt;</span><br><span class="line">      &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;collection-header&quot;</span>&gt;&#123;&#123; current_month &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226093409.png" alt="image-20210226093408957"></p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署第三方主题next 7.8版本</title>
    <url>/posts/d23fb963/</url>
    <content><![CDATA[<h5 id="1-next-7-8-主题安装"><a href="#1-next-7-8-主题安装" class="headerlink" title="1. next 7.8 主题安装"></a>1. next 7.8 主题安装</h5><p><a href="https://github.com/theme-next/hexo-theme-next/archive/v7.8.0.zip">7.8.0版本下载连接</a></p>
<ol>
<li><p>将下载好的主题文件解压到hexo主目录下的themes文件夹下</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224204119.png" alt="image-20210224204118992"></p>
</li>
<li><p>在主目录的source下新建<strong>_data</strong>目录，将<strong>第三方主题</strong>中的<strong>_config.yml</strong>文件复制到该目录下重命名为next.yml,并修改文件中<strong>override为true</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224203110.png" alt="image-20210224203110673"></p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">override:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主目录的<strong>_config.yml</strong>文件，启用主题</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224203236.png" alt="image-20210224203236580"></p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成next主题开启的界面</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224203417.png"></p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo new page home</span><br><span class="line">hexo new page archives</span><br><span class="line">hexo new page about</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page commonweal</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>win10的搭建hexo博客</title>
    <url>/posts/1bab7c20/</url>
    <content><![CDATA[<h5 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h5><p><strong>安装前准备</strong></p>
<ul>
<li>git</li>
<li>Nodejs</li>
</ul>
<h5 id="2、Hexo安装"><a href="#2、Hexo安装" class="headerlink" title="2、Hexo安装"></a>2、Hexo安装</h5><ol>
<li><p>首先配置npm的<strong>淘宝源</strong>,安装完成后可通过npm info hexo查看是否配置淘宝源成功</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装hexo</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定安装的hexo目录</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo init test</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> test     </span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试安装是否成功</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean      #清除缓存</span><br><span class="line">hexo g      #生成静态网页</span><br><span class="line">hexo s      #启动本地服务</span><br></pre></td></tr></table></figure>

<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224200606.png" alt="image-20210224200605821"></p>
</li>
</ol>
<h5 id="3-Gtihub相关配置"><a href="#3-Gtihub相关配置" class="headerlink" title="3. Gtihub相关配置"></a>3. Gtihub相关配置</h5><p>New repository创建新仓库，仓库名应该为：<strong>用户名</strong>.<a href="https://link.zhihu.com/?target=http://github.io">http://github.io</a> 这个<strong>用户名</strong>使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224200752.png" alt="image-20210224200752872"></p>
<h5 id="4-hexo配置远程部署"><a href="#4-hexo配置远程部署" class="headerlink" title="4. hexo配置远程部署"></a>4. hexo配置远程部署</h5><p>修改根目录下的<strong>_config.yml</strong> 文件中配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/CNRF/CNRF.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>使用相关命令进行部署</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d  # 第一次部署会提示输入github的账号和密码</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>redis入门</title>
    <url>/posts/eca8b4a8/</url>
    <content><![CDATA[<h4 id="1-redis相关介绍"><a href="#1-redis相关介绍" class="headerlink" title="1.redis相关介绍"></a>1.redis相关介绍</h4><p><a href="http://redis.cn/">redis中文网</a></p>
<h5 id="1-1-redis的介绍"><a href="#1-1-redis的介绍" class="headerlink" title="1.1 redis的介绍"></a>1.1 redis的介绍</h5><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113311.png" alt="image-20210211203040301"></p>
<h5 id="1-2-redis和memcached的区别"><a href="#1-2-redis和memcached的区别" class="headerlink" title="1.2  .redis和memcached的区别"></a>1.2  .redis和memcached的区别</h5><p>redis和memcached相比本质是解耦，用大数据说法是计算向数据移动</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113409.png" alt="image-20210218095611832"></p>
<h5 id="1-3-liunx下常见的redis命令"><a href="#1-3-liunx下常见的redis命令" class="headerlink" title="1.3 . liunx下常见的redis命令"></a>1.3 . liunx下常见的redis命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#连接redis</span><br><span class="line">redis-cli</span><br><span class="line">#连接redis是6379端口的8号库 指定库(不同库数据不可见)</span><br><span class="line">redis-cli -p 6379 -n 8</span><br><span class="line">#连接redis后使用help进行查询</span><br><span class="line">help </span><br></pre></td></tr></table></figure>

<h4 id="2-redis相关数据的操作常见命令"><a href="#2-redis相关数据的操作常见命令" class="headerlink" title="2.redis相关数据的操作常见命令"></a>2.redis相关数据的操作常见命令</h4><p>在redis客户端中使用help命令进行相关查询相关命令</p>
<h5 id="2-1-Strings类型"><a href="#2-1-Strings类型" class="headerlink" title="2.1 Strings类型"></a>2.1 Strings类型</h5><p><a href="https://redis.io/commands#string">Strings 数据操作相关文档</a></p>
<h6 id="2-1-1-查看string类型帮助命令"><a href="#2-1-1-查看string类型帮助命令" class="headerlink" title="2.1.1 查看string类型帮助命令"></a>2.1.1 查看string类型帮助命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help @string</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113419.png" alt="image-20210219155031906"></p>
<h6 id="2-1-2-string数据类型及相关的应用场景"><a href="#2-1-2-string数据类型及相关的应用场景" class="headerlink" title="2.1.2  string数据类型及相关的应用场景"></a>2.1.2  string数据类型及相关的应用场景</h6><ol>
<li><p>字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set设置key的value</span><br><span class="line">set k1 ooxx nx  （带nx，xx可用在分布式锁中）</span><br><span class="line">set k1 ooxx xx</span><br><span class="line">#mset批量设置</span><br><span class="line">mset k3 k3mest k4 k4mest</span><br><span class="line">#get获取key的value</span><br><span class="line">get k1</span><br><span class="line">#mget批量获取</span><br><span class="line">mget k3 k4</span><br><span class="line">#APPEND在字符串后面追加</span><br><span class="line">append k1 &quot; world&quot;</span><br><span class="line">#GETRANGE获取指定范围数据</span><br><span class="line">getrange k1 5 10</span><br><span class="line">#strlen获取字符串长度</span><br><span class="line">strlen k1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113426.png" alt="image-20210219155108071"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113517.png" alt="image-20210219160021217"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113555.png" alt="image-20210219160343269"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113600.png" alt="image-20210219160751857"></p>
</li>
<li><p>数值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">incr  将value的整数型+1</span><br><span class="line">incrby 将value的整数型加指定数</span><br><span class="line">decr </span><br><span class="line">descby</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>  <strong>应用场景</strong> ： 抢购，秒杀，详情页，点赞，评论规避并发下，对数据库的事务操作完全由redis内存操作代替，避免因数据库事务导致响应时间超时，<strong>但在银行等金融涉及金额不要放在redis中进行相关计算</strong></p>
<ol start="3">
<li><p>bitmap</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setbit  &#x2F;&#x2F;设置bit数值</span><br><span class="line">bitcount  </span><br><span class="line">bitpos</span><br><span class="line">bitop</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>应用场景</strong> ：</p>
<pre><code>1. 统计用户登陆天数

    方案：用户id为key，设计长度为9bit的数据即可存储用户当年所有登陆天数数据，当天登陆为1，即可统计指定时间段的相关数据

2. 统计当天所有用户登陆情况

    方案：日期为Key，设计一个合适长度的数据存储，每一位对应一位客户，登陆则为1，统计时直接进行二进制与运算，则可以去重，统计那些用户登陆
</code></pre>
<h5 id="2-2-Lists类型"><a href="#2-2-Lists类型" class="headerlink" title="2.2  Lists类型"></a>2.2  Lists类型</h5><h6 id="2-2-1-Lists常见命令"><a href="#2-2-1-Lists常见命令" class="headerlink" title="2.2.1 Lists常见命令"></a>2.2.1 Lists常见命令</h6><p><a href="https://redis.io/commands#list">Lists数据相关操作命令</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#lpush 存放顺序为f e d c b a</span><br><span class="line">lpush k1 a b c d e f</span><br><span class="line">#rpush 存放顺序为a b c d e f</span><br><span class="line">rpush k2 a b c d e f</span><br><span class="line">#取数据 lpop</span><br><span class="line">lpop k1 </span><br><span class="line">#lrange按照范围取</span><br><span class="line">lrange k1 0 -1（取全部）</span><br><span class="line">#lindex</span><br><span class="line">#lset</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113620.png" alt="image-20210219205233457"></p>
<h6 id="2-2-2应用场景"><a href="#2-2-2应用场景" class="headerlink" title="2.2.2应用场景"></a>2.2.2应用场景</h6><ol>
<li>使用lpush模拟栈，后进先出</li>
<li>使用rpush模拟队列，先进先出（买票排队问题）</li>
<li>lindex模拟数组，直接根据下标取相关数据</li>
<li>blpop模拟阻塞单播队列（blpop会让对应key有则弹出value，没有会阻塞等待key有值，并且只会弹出一次，当多个客户端同时对一个key使用blpop则可以实现阻塞单播）</li>
</ol>
<h5 id="2-3-hashes类型"><a href="#2-3-hashes类型" class="headerlink" title="2.3 hashes类型"></a>2.3 hashes类型</h5><p>类似java中的hashmap（key，hashmap（key，value））。这里面第一个key是hashes的key，hashmap（key，value）才是value</p>
<h6 id="2-3-1-hashes常见命令"><a href="#2-3-1-hashes常见命令" class="headerlink" title="2.3.1 hashes常见命令"></a>2.3.1 hashes常见命令</h6><p><a href="https://redis.io/commands#hash">hashes常见的命令</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdel</span><br><span class="line">hget</span><br><span class="line">hset</span><br><span class="line">hlen</span><br><span class="line">hincrbyfloat</span><br></pre></td></tr></table></figure>

<h6 id="2-3-2-应用场景："><a href="#2-3-2-应用场景：" class="headerlink" title="2.3.2 应用场景："></a>2.3.2 应用场景：</h6><ol>
<li>对员工薪水进行统计</li>
</ol>
<h5 id="2-4-sets数据类型"><a href="#2-4-sets数据类型" class="headerlink" title="2.4 sets数据类型"></a>2.4 sets数据类型</h5><p>Redis Set 是 String 的无序排列。<code>SADD</code> 指令把新的元素添加到 set 中。对 set 也可做一些其他的操作，比如测试一个给定的元素是否存在，对不同 set 取交集，并集或差，等等。</p>
<h6 id="2-4-1常见命令"><a href="#2-4-1常见命令" class="headerlink" title="2.4.1常见命令"></a>2.4.1常见命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sadd &#x2F;&#x2F;添加元素</span><br><span class="line">sadd myset 1 2 3</span><br><span class="line">smembers &#x2F;&#x2F;读取集合元素</span><br><span class="line">smembers myset</span><br><span class="line">sismember &#x2F;&#x2F;判断元素存在</span><br><span class="line">sismember myset 3 &#x2F;&#x2F;存在返回1，不存在为0</span><br><span class="line"> SINTER  &#x2F;&#x2F;获取多个集合的交集</span><br><span class="line"> SUNIONSTORE  &#x2F;&#x2F;多个集合取并集</span><br></pre></td></tr></table></figure>

<h6 id="2-4-2-应用场景"><a href="#2-4-2-应用场景" class="headerlink" title="2.4.2 应用场景"></a>2.4.2 应用场景</h6><ol>
<li><p>公平抽奖(随机事件) ：  SRANDMEMBER key count（用户作为value）</p>
<p> ​                        正数：取出一个去重的结果集（不能超过已有集）</p>
<p> ​                        负数：取出一个带重复的结果集，一定满足你要的数量如果：</p>
<p> ​                        0，不返回</p>
</li>
</ol>
<h5 id="2-5-sorted-sets数据类型"><a href="#2-5-sorted-sets数据类型" class="headerlink" title="2.5 sorted sets数据类型"></a>2.5 sorted sets数据类型</h5><h6 id="2-5-1-常见命令"><a href="#2-5-1-常见命令" class="headerlink" title="2.5.1 常见命令"></a>2.5.1 常见命令</h6><p><a href="https://redis.io/commands#sorted_set">sorted sets常见命令</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zadd</span><br><span class="line">zmenmber</span><br><span class="line">zinter</span><br><span class="line">zscore &#x2F;&#x2F;按照什么排序</span><br></pre></td></tr></table></figure>

<h6 id="2-5-2-排序底层实现"><a href="#2-5-2-排序底层实现" class="headerlink" title="2.5.2 排序底层实现"></a>2.5.2 排序底层实现</h6><p>通过Skip list（跳跃表）实现增删查改</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113634.png" alt="image-20210220102659707"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>安装redis出现的问题</title>
    <url>/posts/5e07a887/</url>
    <content><![CDATA[<p><strong>操作系统为centOs7  redis为6.0.8版本</strong></p>
<h3 id="1-当Make命令提示无cc环境时需要进行安装Gcc安装包重新安装，同时需要执行make-distclean清理相关文件，再执行make命令"><a href="#1-当Make命令提示无cc环境时需要进行安装Gcc安装包重新安装，同时需要执行make-distclean清理相关文件，再执行make命令" class="headerlink" title="1.当Make命令提示无cc环境时需要进行安装Gcc安装包重新安装，同时需要执行make distclean清理相关文件，再执行make命令"></a>1.当Make命令提示无cc环境时需要进行安装Gcc安装包重新安装，同时需要执行make distclean清理相关文件，再执行make命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一般错误为gcc套装错误</span><br><span class="line">yum install cpp</span><br><span class="line">yum install binutils</span><br><span class="line">yum install glibc</span><br><span class="line">yum install glibc-kernheaders</span><br><span class="line">yum install glibc-common</span><br><span class="line">yum install glibc-devel</span><br><span class="line">yum install gcc</span><br><span class="line">yum install make</span><br><span class="line">&#x2F;&#x2F;清理错误文件</span><br><span class="line">make distclean</span><br><span class="line">&#x2F;&#x2F;重新安装</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/m0_37952284/article/details/109012324">server.c:5307:31: 错误:‘struct redisServer’没有名为‘server_xxx’的成员</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113217.png" alt="image-20201103103148896"></p>
<ol start="2">
<li><h3 id="下载了redis版本6-0-6，正常解压，Centos用的7-6，make安装时报错"><a href="#下载了redis版本6-0-6，正常解压，Centos用的7-6，make安装时报错" class="headerlink" title="下载了redis版本6.0.6，正常解压，Centos用的7.6，make安装时报错:"></a>下载了redis版本6.0.6，正常解压，Centos用的7.6，make安装时报错:</h3></li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113232.png" alt="image-20201103104749570"></p>
<p>原因是redies用了c语言编写，centos7.6应该也有以下版本，默认安装的gcc4.8.5版本较低，需要在5.3以上版本，现更换为9.3，先查看当前版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<p>开始更换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>重连shell</strong>(不重连gcc版本不变)，重新make，即成功了</p>
<h3 id="3-安装Redis-6-0-6-install-server-sh报错"><a href="#3-安装Redis-6-0-6-install-server-sh报错" class="headerlink" title="3.安装Redis 6.0.6 ./install_server.sh报错"></a>3.安装Redis 6.0.6 ./install_server.sh报错</h3><p>产生原因:gcc9版本校验更加严格导致</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113249.png" alt="image-20201103111330639"></p>
<p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi .&#x2F;install_server.sh</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113254.png" alt="image-20201103111506170"></p>
<p><strong>注释掉代码</strong>重新运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#bail if this system is managed by systemd</span><br><span class="line">#_pid_1_exe&#x3D;&quot;$(readlink -f &#x2F;proc&#x2F;1&#x2F;exe)&quot;</span><br><span class="line">#if [ &quot;$&#123;_pid_1_exe##*&#x2F;&#125;&quot; &#x3D; systemd ]</span><br><span class="line">#then</span><br><span class="line">#       echo &quot;This systems seems to use systemd.&quot;</span><br><span class="line">#       echo &quot;Please take a look at the provided example service unit files in this directory, and adapt and install them. Sorry!&quot;</span><br><span class="line">#       exit 1</span><br><span class="line">#fi</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装redis</title>
    <url>/posts/725846d4/</url>
    <content><![CDATA[<p><strong>操作系统为centOS7  redis为6.0.8版本</strong></p>
<ol>
<li>安装wget命令 </li>
</ol>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure>

<p>   <img src="https://gitee.com/CNRF/image/raw/master/img/20210223112933.png" alt="image-20201026172631943"></p>
<ol start="2">
<li><p>安装GCC包（redis是c语言编写，liunx需要安装相关软件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223112947.png" alt="image-20201026172608587"></p>
</li>
<li><p>在指定目录获取安装包（或者下载之后移动到指定目录  ）</p>
<p><a href="https://redis.io/download%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%85%B3%E7%89%88%E6%9C%AC%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8B%E8%BD%BD6.0%E7%89%88%E6%9C%AC">https://redis.io/download获取相关版本连接，这里下载6.0版本</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-6.0.8.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113024.png" alt="image-20201026172901823"></p>
</li>
<li><p>解压gz包（下载的是源码）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xf redis-6.0.8.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据解压包中文件的REDME.md文档进行相关操作（重要：安装其他软件同理）</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113031.png" alt="image-20201103102727621"></p>
</li>
<li><p>使用make相关命令进行安装程序</p>
</li>
<li><p>安装可执行到指定目录（分离源码）</p>
<p>查看/home/redis-6.0.8/INSTALL，根据文档安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install PREFIX&#x3D;&#x2F;home&#x2F;redis6</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册redis为服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;执行vi &#x2F;etc&#x2F;profile命令，在文件最后新增内容</span><br><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line">&#x2F;&#x2F;REDIS_HOME的路径为第七步的安装路径</span><br><span class="line">export REDIS_HOME&#x3D;&#x2F;home&#x2F;redis6</span><br><span class="line">export PATH&#x3D;$PATH:$REDIS_HOME&#x2F;bin</span><br><span class="line">&#x2F;&#x2F;使配置文件生效</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">&#x2F;&#x2F;验证是否添加成功</span><br><span class="line">echo $PATH</span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">&#x2F;home&#x2F;redis-6.0.8&#x2F;utils&#x2F;install_server.sh脚本注册为服务</span><br><span class="line">.&#x2F;install_server.sh</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113126.png" alt="image-20201103103148896"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113145.png" alt="image-20201103112714896">   </p>
<ol start="9">
<li><p>修改配置文件，安装需求修改相关配置</p>
<p>redis常见配置参见<a href="https://blog.csdn.net/suprezheng/article/details/90679790">https://blog.csdn.net/suprezheng/article/details/90679790</a></p>
</li>
<li><p>将redis_6379(根据生成的配置文件名称)设置为开启</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;init.d</span><br><span class="line">  #init.d没有redis_6379文件的可以在源文件中找到redis.conf文件进行修改</span><br><span class="line">  chkconfig --add redis_6379</span><br><span class="line">  chkconfig redis_6379 on</span><br><span class="line">  #查看开机自启的列表</span><br><span class="line">  chkconfig --list</span><br><span class="line">  #重启redis</span><br><span class="line">  service redis_6379 restart</span><br><span class="line">  #手动启用</span><br><span class="line">  redis-server &#x2F;etc&#x2F;redis&#x2F;6379.conf</span><br><span class="line">  chkconfig --list的参数意义</span><br><span class="line">  1表示：单用户模式</span><br><span class="line">  2表示：无网络连接的多用户命令行模式</span><br><span class="line">  3表示：有网络连接的多用户命令行模式</span><br><span class="line">  4表示：不可用</span><br><span class="line">  5表示：带图形界面的多用户模式</span><br><span class="line">  6表示：重新启动</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
