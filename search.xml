<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL的常见命令</title>
    <url>/posts/4ae76812/</url>
    <content><![CDATA[<h2 id="操作数据库：CRUD"><a href="#操作数据库：CRUD" class="headerlink" title="操作数据库：CRUD"></a>操作数据库：CRUD</h2><h3 id="C-Create-：创建"><a href="#C-Create-：创建" class="headerlink" title="C(Create)：创建"></a>C(Create)：创建</h3><ul>
<li><p>创建数据库：</p>
<ul>
<li>create database 数据库名称;</li>
</ul>
</li>
<li><p>创建数据库，判断不存在，再创建：</p>
<ul>
<li>create database if not exists 数据库名称;</li>
</ul>
</li>
<li><p>创建数据库，并指定字符集</p>
<ul>
<li>create database 数据库名称 character set 字符集名;</li>
</ul>
</li>
<li><p>例子： 创建db4数据库，判断是否存在，并制定字符集为utf8</p>
<ul>
<li>create database if not exists db4 character set utf8mb4;</li>
</ul>
</li>
</ul>
<h3 id="R-Retrieve-：查询"><a href="#R-Retrieve-：查询" class="headerlink" title="R(Retrieve)：查询"></a>R(Retrieve)：查询</h3><ul>
<li><p>查询所有数据库的名称:</p>
<ul>
<li>show databases;</li>
</ul>
</li>
<li><p>查询某个数据库的字符集:查询某个数据库的创建语句</p>
<ul>
<li>show create database 数据库名称;</li>
</ul>
</li>
</ul>
<h3 id="U-Update-：修改"><a href="#U-Update-：修改" class="headerlink" title="U(Update)：修改"></a>U(Update)：修改</h3><ul>
<li>修改数据库的字符集<ul>
<li>alter database 数据库名称 character set 字符集名称;</li>
</ul>
</li>
</ul>
<h3 id="D-Delete-：删除"><a href="#D-Delete-：删除" class="headerlink" title="D(Delete)：删除"></a>D(Delete)：删除</h3><ul>
<li>删除数据库<ul>
<li>drop database 数据库名称;</li>
</ul>
</li>
<li>判断数据库存在，存在再删除<ul>
<li>drop database if exists 数据库名称;</li>
</ul>
</li>
</ul>
<h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><ul>
<li>查询当前正在使用的数据库名称<ul>
<li>select database();</li>
</ul>
</li>
<li>使用数据库<ul>
<li>use 数据库名称;</li>
</ul>
</li>
</ul>
<h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><h3 id="C-Create-：创建-1"><a href="#C-Create-：创建-1" class="headerlink" title="C(Create)：创建"></a>C(Create)：创建</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	列名<span class="number">1</span> 数据类型<span class="number">1</span>,</span><br><span class="line">	列名<span class="number">2</span> 数据类型<span class="number">2</span>,</span><br><span class="line">	....</span><br><span class="line">	列名n 数据类型n</span><br><span class="line">);</span><br><span class="line">#注意：最后一列，不需要加逗号（,）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h4><ul>
<li><p>int：整数类型  age int,</p>
</li>
<li><p>double:小数类型  score double(5,2)</p>
</li>
<li><p>date:日期，只包含年月日，yyyy-MM-dd</p>
</li>
<li><p>datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss</p>
</li>
<li><p>timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss</p>
<p>  <strong>如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</strong></p>
</li>
<li><p>varchar：字符串</p>
<p>  name varchar(20):姓名最大20个字符</p>
<p>  zhangsan 8个字符  张三 2个字符</p>
<h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`  (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `account` <span class="type">varchar</span>(<span class="number">50</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">50</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">  `mobile` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `create_time` datetime(<span class="number">0</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `creator` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">  `operator` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改人&#x27;</span>,</span><br><span class="line">  `operat_time` datetime(<span class="number">0</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `create_ip` <span class="type">varchar</span>(<span class="number">512</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建记录ip&#x27;</span>,</span><br><span class="line">  `operat_ip` <span class="type">varchar</span>(<span class="number">512</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改记录的ip&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">2</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数据状态：1-启用， 2-屏蔽（页面可以显示，可以恢复）， 3-禁用(页面不显示该条数据)&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> MyISAM AUTO_INCREMENT <span class="operator">=</span> <span class="number">3</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> COMPACT;</span><br></pre></td></tr></table></figure>
<h4 id="创建表-1"><a href="#创建表-1" class="headerlink" title="创建表"></a>创建表</h4>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#复制表结构及数据到新表(新表中没有了旧表的<span class="keyword">primary</span> key、Extra（auto_increment）等属性)</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 新表<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 旧表</span><br><span class="line">#只复制表结构到新表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 新表<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 旧表<span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 <span class="keyword">like</span> 被复制的表名;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> usertest <span class="keyword">like</span> <span class="keyword">user</span>;</span><br><span class="line">#复制旧表的数据到新表(假设两个表结构一样)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 新表<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 旧表</span><br><span class="line">复制旧表的数据到新表(假设两个表结构不一样)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 新表(字段<span class="number">1</span>,字段<span class="number">2</span>,.......) <span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段<span class="number">2</span>,...... <span class="keyword">FROM</span> 旧表</span><br><span class="line">#可以将表<span class="number">1</span>结构复制到表<span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">INTO</span> 表<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span></span><br><span class="line">#可以将表<span class="number">1</span>内容全部复制到表<span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">INTO</span> 表<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"># <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 旧表;</span><br><span class="line">将旧表的创建命令列出。我们只需要将该命令拷贝出来，更改<span class="keyword">table</span>的名字，就可以建立一个完全一样的表</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 旧表;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="R-Retrieve-：查询-1"><a href="#R-Retrieve-：查询-1" class="headerlink" title="R(Retrieve)：查询"></a>R(Retrieve)：查询</h3><h4 id="查询某个数据库中所有的表名称"><a href="#查询某个数据库中所有的表名称" class="headerlink" title="查询某个数据库中所有的表名称"></a>查询某个数据库中所有的表名称</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure>

<h4 id="查询表结构"><a href="#查询表结构" class="headerlink" title="查询表结构"></a>查询表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名;</span><br><span class="line"><span class="keyword">desc</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure>

<h3 id="U-Update-：修改-1"><a href="#U-Update-：修改-1" class="headerlink" title="U(Update)：修改"></a>U(Update)：修改</h3><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 rename <span class="keyword">to</span> 新的表名;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> usertest rename <span class="keyword">to</span> user_test;</span><br></pre></td></tr></table></figure>

<h4 id="修改表的字符集"><a href="#修改表的字符集" class="headerlink" title="修改表的字符集"></a>修改表的字符集</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="type">character</span> <span class="keyword">set</span> 字符集名称;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_test <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure>

<h4 id="添加一列"><a href="#添加一列" class="headerlink" title="添加一列"></a>添加一列</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_test <span class="keyword">add</span> test <span class="keyword">DOUBLE</span>;</span><br></pre></td></tr></table></figure>

<h4 id="修改列名称-类型"><a href="#修改列名称-类型" class="headerlink" title="修改列名称 类型"></a>修改列名称 类型</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 列名 新列别 新数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 列名 新数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_test change test test1 <span class="type">int</span>;</span><br></pre></td></tr></table></figure>

<h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_test <span class="keyword">drop</span> test1;</span><br></pre></td></tr></table></figure>

<h3 id="D-Delete-：删除-1"><a href="#D-Delete-：删除-1" class="headerlink" title="D(Delete)：删除"></a>D(Delete)：删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span>  if <span class="keyword">exists</span> 表名 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span>  if <span class="keyword">exists</span> user_test ;</span><br></pre></td></tr></table></figure>

<h2 id="操作表中数据"><a href="#操作表中数据" class="headerlink" title="操作表中数据"></a>操作表中数据</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#列名和值要一一对应，除了数字类型，其他类型需要使用引号(单双都可以)引起来</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>,...列名n) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...值n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`(`id`, `account`, `password`, `name`, `mobile`, `create_time`, `creator`, `operator`, `operat_time`, `create_ip`, `operat_ip`, `status`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, <span class="string">&#x27;管理员&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;2020-03-12 10:35:57&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;2020-03-12 10:36:06&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#如果不加任何条件，则会将表中所有记录全部修改。</span><br><span class="line">update 表名 <span class="keyword">set</span> 列名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>, 列名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span>,... [<span class="keyword">where</span> 条件];</span><br><span class="line">UPDATE `khxttest`.`<span class="keyword">user</span>` <span class="keyword">SET</span> `account` <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span>, `password` <span class="operator">=</span> <span class="string">&#x27;123456&#x27;</span>, `name` <span class="operator">=</span> <span class="string">&#x27;管理员&#x27;</span>, `mobile` <span class="operator">=</span> <span class="keyword">NULL</span>, `create_time` <span class="operator">=</span> <span class="string">&#x27;2020-03-12 10:35:57&#x27;</span>, `creator` <span class="operator">=</span> <span class="number">0</span>, `operator` <span class="operator">=</span> <span class="number">0</span>, `operat_time` <span class="operator">=</span> <span class="string">&#x27;2020-03-12 10:36:06&#x27;</span>, `create_ip` <span class="operator">=</span> <span class="string">&#x27;127.0.0.1&#x27;</span>, `operat_ip` <span class="operator">=</span> <span class="string">&#x27;127.0.0.1&#x27;</span>, `status` <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `khxttest`.`<span class="keyword">user</span>` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">29</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>delete from 表名; – 不推荐使用。有多少条记录就会执行多少次删除操作</p>
<p>TRUNCATE TABLE 表名; – 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</p>
</blockquote>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄大于20岁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄等于20岁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄不等于20岁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄大于等于20 小于等于30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="operator">&amp;&amp;</span>  age <span class="operator">&lt;=</span><span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">AND</span>  age <span class="operator">&lt;=</span><span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄22岁，18岁，25岁的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">18</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">25</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="number">22</span>,<span class="number">18</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询英语成绩为null</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english <span class="operator">=</span> <span class="keyword">NULL</span>; <span class="comment">-- 不对的。null值不能使用 = （!=） 判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询英语成绩不为null</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english  <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="comment">-- 查询姓马的有哪些？ like</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;马%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询姓名第二个字是化的人</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> &quot;_化%&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓名是3个字的人</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;___&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询姓名中包含德的人</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%德%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>where子句后跟条件</p>
<ul>
<li><strong>&lt;  &lt;=  &gt;=   =     &lt;&gt;</strong></li>
<li>BETWEEN…AND  </li>
<li>IN( 集合) </li>
<li>LIKE：模糊查询<ul>
<li>占位符：<ol>
<li>_:单个任意字符</li>
<li>%：多个任意字符</li>
</ol>
</li>
</ul>
</li>
<li>IS NULL  </li>
<li>and  或 &amp;&amp;</li>
<li>or  或 || </li>
<li>not  或 !</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的安装与卸载</title>
    <url>/posts/5a759233/</url>
    <content><![CDATA[<p><strong>相关环境</strong></p>
<p>操作系统：centos7</p>
<p>mysql版本：mysql 5.7</p>
<h2 id="MySQL-5-7-的安装"><a href="#MySQL-5-7-的安装" class="headerlink" title="MySQL 5.7 的安装"></a>MySQL 5.7 的安装</h2><h4 id="检测系统是否自带安装mysql"><a href="#检测系统是否自带安装mysql" class="headerlink" title="检测系统是否自带安装mysql"></a>检测系统是否自带安装mysql</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list installed | grep mysql</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309101055.png" alt="image-20210309101055184"></p>
<h4 id="删除系统自带的mysql及其依赖（防止冲突）"><a href="#删除系统自带的mysql及其依赖（防止冲突）" class="headerlink" title="删除系统自带的mysql及其依赖（防止冲突）"></a>删除系统自带的mysql及其依赖（防止冲突）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">此处对应的是自身版本</span></span><br><span class="line">yum -y remove mysql-libs.x86_64</span><br></pre></td></tr></table></figure>

<h4 id="安装wget命名"><a href="#安装wget命名" class="headerlink" title="安装wget命名"></a>安装wget命名</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install wget -y </span><br></pre></td></tr></table></figure>

<h4 id="下载并安装MySQL官方的-Yum-Repository"><a href="#下载并安装MySQL官方的-Yum-Repository" class="headerlink" title="下载并安装MySQL官方的 Yum Repository"></a>下载并安装MySQL官方的 Yum Repository</h4><p>由于CentOS 的yum源中没有mysql，需要到mysql的官网下载yum repo配置文件。并进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm</span><br><span class="line"> yum install mysql-community-release-el6-5.noarch.rpm -y</span><br></pre></td></tr></table></figure>

<h4 id="使用yum安装mysql"><a href="#使用yum安装mysql" class="headerlink" title="使用yum安装mysql"></a>使用yum安装mysql</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install mysql-community-server -y</span><br></pre></td></tr></table></figure>

<h4 id="启动mysql服务并设置开机启动"><a href="#启动mysql服务并设置开机启动" class="headerlink" title="启动mysql服务并设置开机启动"></a>启动mysql服务并设置开机启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动之前需要生成临时密码，需要用到证书，可能证书过期，需要进行更新操作</span></span><br><span class="line">yum update -y</span><br><span class="line"><span class="meta">#</span><span class="bash">启动mysql服务</span></span><br><span class="line">service mysqld start</span><br><span class="line"><span class="meta">#</span><span class="bash">设置mysql开机启动</span></span><br><span class="line">chkconfig mysqld on</span><br></pre></td></tr></table></figure>

<h4 id="获取mysql的临时密码"><a href="#获取mysql的临时密码" class="headerlink" title="获取mysql的临时密码"></a>获取mysql的临时密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;password&quot; /var/log/mysqld.log</span><br><span class="line"><span class="meta">#</span><span class="bash">没有获取到说明没有密码可以直接登陆</span></span><br></pre></td></tr></table></figure>

<h4 id="使用临时密码登录"><a href="#使用临时密码登录" class="headerlink" title="使用临时密码登录"></a>使用临时密码登录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p 密码</span><br></pre></td></tr></table></figure>

<h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">#上面这条命令不行时，使用下面这条命令</span><br><span class="line">#<span class="number">6</span>BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 对应<span class="number">123456</span></span><br><span class="line">#也可以通过 <span class="keyword">select</span> password(<span class="string">&#x27;123456&#x27;</span>)获取</span><br><span class="line"> <span class="keyword">set</span> password<span class="operator">=</span><span class="string">&#x27; 6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309103437.png"></p>
<h4 id="允许远程连接数据库"><a href="#允许远程连接数据库" class="headerlink" title="允许远程连接数据库"></a>允许远程连接数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h4 id="设置字符集为utf-8"><a href="#设置字符集为utf-8" class="headerlink" title="设置字符集为utf-8"></a>设置字符集为utf-8</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在[mysqld]部分添加：</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="meta">#</span><span class="bash">在文件末尾新增[client]段，并在[client]段添加：</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line"><span class="meta">#</span><span class="bash">重启mysql</span></span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309103825.png" alt="image-20210309103825273"></p>
<h2 id="Linux下mysql的彻底卸载"><a href="#Linux下mysql的彻底卸载" class="headerlink" title="Linux下mysql的彻底卸载"></a>Linux下mysql的彻底卸载</h2><h4 id="查看mysql的安装情况"><a href="#查看mysql的安装情况" class="headerlink" title="查看mysql的安装情况"></a>查看mysql的安装情况</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep -i mysql</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309104128.png" alt="image-20210309104128079"></p>
<h4 id="删除上图安装的软件"><a href="#删除上图安装的软件" class="headerlink" title="删除上图安装的软件"></a>删除上图安装的软件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ev mysql-community-libs-5.6.51-2.el6.x86_64</span><br><span class="line">rpm -ev mysql-community-server-5.6.51-2.el6.x86_64</span><br><span class="line">rpm -ev mysql-community-release-el6-5.noarch</span><br><span class="line">rpm -ev mysql-community-common-5.6.51-2.el6.x86_64</span><br><span class="line">rpm -ev  mysql-community-client-5.6.51-2.el6.x86_64</span><br></pre></td></tr></table></figure>

<h4 id="都删除成功之后，查找相关的mysql的文件"><a href="#都删除成功之后，查找相关的mysql的文件" class="headerlink" title="都删除成功之后，查找相关的mysql的文件"></a>都删除成功之后，查找相关的mysql的文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name mysql</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309104242.png" alt="image-20210309104242918"></p>
<h4 id="删除全部文件"><a href="#删除全部文件" class="headerlink" title="删除全部文件"></a>删除全部文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /etc/logrotate.d/mysql</span><br><span class="line">rm -rf /etc/selinux/targeted/active/modules/100/mysql</span><br><span class="line">rm -rf /var/lib/mysql</span><br><span class="line">rm -rf /var/lib/mysql/mysql</span><br><span class="line">rm -rf /usr/bin/mysql</span><br><span class="line">rm -rf /usr/lib64/mysql</span><br><span class="line">rm -rf /usr/share/mysql</span><br></pre></td></tr></table></figure>

<h4 id="再次执行命令"><a href="#再次执行命令" class="headerlink" title="再次执行命令"></a>再次执行命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep -i mysql</span><br><span class="line"><span class="meta">#</span><span class="bash">如果没有显式则表示卸载完成</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的事务</title>
    <url>/posts/d2eae622/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309135338.jpg" alt="16a3e7b7a6894434"></p>
<h2 id="为什么要有事务"><a href="#为什么要有事务" class="headerlink" title="为什么要有事务"></a>为什么要有事务</h2><p><strong>数据库引入事务的主要目的是事务会把数据库会从一种一致状态转换到另一种一致状态，数据库提交工作时可以确保要么所有修改都保存，要么所有修改都不保存。</strong></p>
<h3 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h3><ul>
<li><strong>A(Atomicity) 原子性</strong></li>
<li><strong>C(Consistency) 一致性</strong></li>
<li><strong>I(Isolation) 隔离性</strong></li>
<li><strong>D(Durability) 持久性</strong></li>
</ul>
<h4 id="A-Atomicity-原子性"><a href="#A-Atomicity-原子性" class="headerlink" title="A(Atomicity) 原子性"></a>A(Atomicity) 原子性</h4><p>原子性是<strong>整个数据库事务是不可分割的工作单位</strong>，只有<font color=red>事务中的所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL执行失败，已经执行成功的SQL语句也必须撤销，回到执行事务的之前的状态</font>。</p>
<h4 id="C-Consistency-一致性"><a href="#C-Consistency-一致性" class="headerlink" title="C(Consistency) 一致性"></a>C(Consistency) 一致性</h4><p>一致性是指事务将数据库从一种一致性状态变为下一种一致性状态。<font  color=red>在事务开始之前和之后，数据库的完整性约束没有被破坏。</font></p>
<h4 id="I-Isolation-隔离性"><a href="#I-Isolation-隔离性" class="headerlink" title="I(Isolation) 隔离性"></a>I(Isolation) 隔离性</h4><p>隔离性要求<font color=red>每个读写事务对其他事务的操作对象能相互分离。</font></p>
<h4 id="D-Durability-持久性"><a href="#D-Durability-持久性" class="headerlink" title="D(Durability) 持久性"></a>D(Durability) 持久性</h4><p>持久性指<font color=red>事务一旦提交，其结果就是永久性的。</font></p>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>事务的实现就是如何实现ACID特性，下面一图下概况下：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309140003.png" alt="image-20210309140003622"></p>
<p><font color=red>事务的实现通过 redo_log 和 undo_log， 以及锁实现，锁实现事务的</font></p>
<p><font color=blue>redo_log 实现持久化和原子性，而undo_log实现一致性，二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</font></p>
<h3 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log 重做日志"></a>redo log 重做日志</h3><p><strong>redo_log 重做日志上面已经提到实现持久化和原子性</strong>，重做日志由两部分组成，<font color=red>一是内存中的重做日志缓存(redo log buffer)，这部分是容易丢失的。二是重做日志文件(redo log file)，这部分是持久的</font></p>
<h4 id="redo-log更新流程"><a href="#redo-log更新流程" class="headerlink" title="redo log更新流程"></a>redo log更新流程</h4><p>redo log的更新流程如下图，以一次Update 操作为例。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309140424.png" alt="image-20210309140424737"></p>
<ol>
<li>执行update操作。</li>
<li>先将原始数据从磁盘读取到内存，修改内存中的数据。</li>
<li>生成一条重做日志写入redo log buffer，记录数据被修改后的值。</li>
<li>当事务提交时，需要将redo log buffer中的内容刷新到redo log file。</li>
<li>事务提交后，也会将内存中修改数据的值写入磁盘。</li>
</ol>
<blockquote>
<p>为了确保每次日志都写入重做日志文件，<font color=red>InnoDB存储引擎会调用一次fsync操作。</font></p>
</blockquote>
<h4 id="存储格式内容"><a href="#存储格式内容" class="headerlink" title="存储格式内容"></a>存储格式内容</h4><h5 id="mysql的binlog与redo-log区别"><a href="#mysql的binlog与redo-log区别" class="headerlink" title="mysql的binlog与redo log区别"></a>mysql的binlog与redo log区别</h5><ol>
<li>首先2者都是记录数据的改变，不同的是，binlog是记录所有数据的改变信息，而innodb的redo log只是记录所有innodb表数据的变化。</li>
<li>binlog是记录已经提交完毕之后的dml以及ddl sql语句，而innodb  redo log是正在执行中的dml以及ddl语句</li>
<li>binlog可以作为恢复数据使用 ，redo log可以作为异常down机或者介质故障后的数据恢复使用</li>
<li>在db文件目录下，也分属于不同的日志文件中。</li>
</ol>
<h5 id="mysql的binlog与redo-log的写入方式"><a href="#mysql的binlog与redo-log的写入方式" class="headerlink" title="mysql的binlog与redo log的写入方式"></a>mysql的binlog与redo log的写入方式</h5><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309141112.png" alt="image-20210309141112695"></p>
<p>binlog是每次事务才写入，所以<strong>每个事务只会有一条日志，记录的逻辑日志，也可以说记录的就是SQL语句。</strong></p>
<p>redo log是事务开始就开始写入，*<strong>T1表示事务提交</strong>。<strong>记录的是物理格式日志</strong>，即每个页的修改。</p>
<p>redo log默认是以block(块)的方式为单位进行存储，每个块是512个字节。不同的数据库引擎有对应的重做日志格式，Innodb的存储管理是基于页的，所以其重做日志也是基于页的。</p>
<p>redo log格式:</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309141251.png" alt="image-20210309141251321"></p>
<ul>
<li>redo_log_type 重做日志类型</li>
<li>space 表空间的ID</li>
<li>page_no 页的偏移量</li>
<li>redo_log_body 存储内容</li>
</ul>
<p>执行一条插入语句，重做日志大致为:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">2</span>;</span><br><span class="line">           <span class="operator">|</span></span><br><span class="line">page(<span class="number">2</span>,<span class="number">3</span>), <span class="keyword">offset</span> <span class="number">32</span>, <span class="keyword">value</span> <span class="number">1</span>,<span class="number">2</span> # 主键索引</span><br><span class="line">page(<span class="number">2</span>,<span class="number">4</span>), <span class="keyword">offset</span> <span class="number">64</span>, <span class="keyword">value</span> <span class="number">2</span>   # 辅助索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="恢复机制"><a href="#恢复机制" class="headerlink" title="恢复机制"></a>恢复机制</h4><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309141428.png" alt="image-20210309141428811"></p>
<p><strong>LSN(Log Sequence Number) 日志序列号</strong>，Innodb里，LSN占8个字节，且是单调递增的，<strong>代表的含义</strong>有: 重做日志写入的总量、checkpoint的位置、页的版本。</p>
<p>假设在LSN=10000的时候数据库出现故障，磁盘中checkpoint为10000，表示磁盘已经刷新到10000这个序列号，当前redolog的checkpoint是13000，则需要恢复10000-13000的数据。</p>
<h4 id="redo-log为什么可以实现事务的原子性和持久性。"><a href="#redo-log为什么可以实现事务的原子性和持久性。" class="headerlink" title="redo log为什么可以实现事务的原子性和持久性。"></a>redo log为什么可以实现事务的原子性和持久性。</h4><ul>
<li>原子性，是redo log记录了事务期间操作的物理日志，事务提交之前，并没有写入磁盘，保存在内存里，如果事务失败，数据库磁盘不会有影响，回滚掉事务内存部分即可。</li>
<li>持久性，redo log 会在事务提交时将日志存储到磁盘redo log file，保证日志的持久性。</li>
</ul>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>redo log一旦提交意味着持久化了，但是有时候需要对其进行rollback操作，那就需要undo log。</p>
<p>undo log是逻辑日志，只是将数据库逻辑的恢复到原来的样子。并不能将数据库物理地恢复到执行语句或者事务之前的样子。虽然所有的逻辑修改均被取消了，但是数据结构和页本身在回滚前后可能不一样了。</p>
<p>既然是逻辑日志，可以<font color=red>理解为它存储的是SQL, 在事务中使用的每一条 INSERT 都对应了一条 DELETE，每一条 UPDATE 也都对应一条相反的 UPDATE 语句。</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309141731.png" alt="image-20210309141731783"></p>
<ul>
<li><p>undo log 存放在数据库内部的一个特殊段(segment)中，也叫undo段，存在于共享表空间中。</p>
</li>
<li><p>undo log实现了事务的一致性，可以通过undo log恢复到事务之前的逻辑状态，保证一致性。</p>
</li>
<li><p>undo log 还可以实现MVCC（Multi-Version Concurrency Control ，多版本并发控制），<font color=red>多版本并发控制其实可以通过 undo log 形成一个事务执行过程中的版本链，每一个写操作会产生一个版本，数据库发生读的并发访问时，读操作访问版本链，返回最合适的结果直接返回</font>。从而读写操作之间没有冲突，提高了性能。</p>
</li>
</ul>
<h2 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309143119.png" alt="image-20210309143119908"></p>
<blockquote>
<p>set transaction 修改事务隔离级别，比如修改会话级别的事务:</p>
<p><strong>set session transaction isolation level read committed;</strong></p>
</blockquote>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309143218.png" alt="image-20210309143218209"></p>
<p>四种隔离级别，按READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE顺序，隔离级别是从低到高<strong>，InnoDB默认是REPEATABLE-READ级别，此级别在其余数据库中是会引起幻读问题，InnoDB采用Next-Key Lock锁算法避免了此问题</strong></p>
<h3 id="READ-UNCOMMITTED"><a href="#READ-UNCOMMITTED" class="headerlink" title="READ-UNCOMMITTED"></a>READ-UNCOMMITTED</h3><p>READ-UNCOMMITTED 中文叫<strong>未提交读</strong>，即一个事务读到了另一个未提交事务修改过的数据，整个过程如下图:</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309143631.png" alt="image-20210309143630946"></p>
<p><font color=red>SessionA和SessionB分别开启一个事务，SessionB中的事务先将id为1的记录的name列更新为’lisi’，然后Session 中的事务再去查询这条id为1的记录，那么在未提交读的隔离级别下，查询结果由’zhangsan’变成了’lisi’，也就是说某个事务读到了另一个未提交事务修改过的记录。但是如果SessionB中的事务稍后进行了回滚，那么SessionA中的事务相当于读到了一个不存在的数据，这种现象也称为脏读。</font>可见READ-UNCOMMITTED是非常不安全</p>
<h3 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h3><p>READ COMMITTED 中文叫<strong>已提交读，或者叫不可重复读</strong>。<font color=red>即一个事务能读到另一个已经提交事务修改后的数据，如果其他事务均对该数据进行修改并提交，该事务也能查询到最新值。</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309143845.png" alt="image-20210309143845407"></p>
<p><font color=red>SessionB 修改后，如果未提交，SessionA是读不到，但SessionB一旦提交后，SessionA即可读到SessionB修改的内容。</font>不可重复读是违反事务的隔离性的。</p>
<h3 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h3><p>REPEATABLE READ 中文叫可重复读，<font color=red>即事务能读到另一个已经提交的事务修改过的数据，但是第一次读过某条记录后，即使后面其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据。</font>如下图:</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309144051.png" alt="image-20210309144051799"></p>
<p>InnoDB默认是这种隔离级别，SessionB无论怎么修改id=1的值，SessionA读到依然是自己开启事务第一次读到的内容。</p>
<h3 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a>SERIALIZABLE</h3><p>SERIALIZABLE 叫串行化， 上面三种隔离级别可以进行 读-读 或者 读-写、写-读三种并发操作，而<font color=red>SERIALIZABLE不允许读-写，写-读的并发操作</font>。 如下图:</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309144203.png" alt="image-20210309144203252"></p>
<p>SessionB 对 id=1 进行修改的时候，SessionA 读取id=1则需要等待 SessionB 提交事务。可以理解SessionB在更新的时候加了锁。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>分布式事务指<strong>允许多个独立的事务资源参与到一个全局的事务中。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚。</strong></p>
<h3 id="InnoDB-分布式事务"><a href="#InnoDB-分布式事务" class="headerlink" title="InnoDB 分布式事务"></a>InnoDB 分布式事务</h3><p>InnoDB 是支持分布式事务，由一个或多个资源管理器（Resource Managers），一个事务管理器(Transaction Manager)，以及一个应用程序(Application Program)组成。</p>
<ul>
<li>资源管理器（Resource Managers），提供访问事务资源的方法，一般一个数据库就是一个资源管理器。</li>
<li>事务管理器(Transaction Manager)，协调参与全局事务中的各个事务，需要和参与全局事务的所有资源管理器进行通信。</li>
<li>应用程序(Application Program) 定义事务的边界，指定全局事务中的操作。</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309144336.png" alt="image-20210309144336352"></p>
<p>应用程序向一个或多个数据库执行事务操作，<strong>事务管理器进行管理事务，通过二段式提交，第一阶段所有参与的全局事务的节点都开始准备，告诉事务管理器都准备好了，可以提交了。第二阶段，事务管理器告诉每一个资源管理器是执行Commit 还是 Rollback。如果任何一个节点显示不能提交，则所有的节点被告知需要回滚</strong>。</p>
<h3 id="TCC分布式事务"><a href="#TCC分布式事务" class="headerlink" title="TCC分布式事务"></a>TCC分布式事务</h3><p><strong>InnoDB的分布式是数据库实现的, 数据库外常见的分布式事务是TCC分布式事务</strong></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309144458.png" alt="image-20210309144458126"></p>
<p>上图描述了TCC分布式事务的流程，假设电商业务中，支付后需要修改库存，积分，物流仓储的数据，如果一个失败则全部回滚。</p>
<p>TCC分布式事务，有三个阶段，Try，Confirm, Cancel。也就是说每个参与事务的服务都需要实现这三个接口，库存、积分、仓储都需要实现这三个接口。</p>
<p>第一阶段，Try，业务应用调取各个服务的Try接口，告诉他们给我预留一个商品，有人要购买，可以理解为冻结，每一步都不执行成功，只是标记更新状态。</p>
<p>第二阶段，Confirm，确认阶段，即事务协调器调取每个服务Confirm执行事务操作，如果某一个服务的Confirm失败，则有第三个阶段。如果成功则结束事务。</p>
<p>第三个阶段，Cancel，如果在第二个阶段有一个事务提交失败，则事务协调器调取所有业务的Cancel接口，回滚事务，将第一阶段冻结的商品恢复。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的优化</title>
    <url>/posts/f1e1e97a/</url>
    <content><![CDATA[<p><a href="https://dev.mysql.com/doc/refman/8.0/en/optimization.html">MySQL优化官网参考</a></p>
<h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2><ul>
<li>设计数据库时：数据库表、字段的设计，存储引擎</li>
<li>利用好MySQL自身提供的功能，如索引等</li>
<li>横向扩展：MySQL集群、负载均衡、读写分离</li>
<li>SQL语句的优化（收效甚微）</li>
</ul>
<h2 id="字段设计"><a href="#字段设计" class="headerlink" title="字段设计"></a>字段设计</h2><blockquote>
<p>字段类型的选择，设计规范，范式，常见设计案例</p>
</blockquote>
<h3 id="存储IP地址"><a href="#存储IP地址" class="headerlink" title="存储IP地址"></a>存储IP地址</h3><p><strong>常规做法</strong>： varchar（15）</p>
<p><strong>优化选择</strong>：int unsigned，占用4个字节，节省空间，IP运算速度块</p>
<blockquote>
<p>inet_aton；</p>
<p>inet_ntoa;</p>
<p>a—address,n—-number</p>
</blockquote>
<h3 id="尽量使用整数去表示字符串"><a href="#尽量使用整数去表示字符串" class="headerlink" title="尽量使用整数去表示字符串"></a>尽量使用整数去表示字符串</h3><p><strong>整型的优势</strong>：存储空间固定。往往是少量空间,运算速度块</p>
<blockquote>
<p>MySQL 内部的枚举（单选）类型和集合（多选）类型但是，<strong>实操的时候enum和set很少用</strong></p>
<p><strong>原因</strong>：维护成本高</p>
<p><strong>使用的替代方案</strong>：关联表</p>
</blockquote>
<h3 id="存储金额"><a href="#存储金额" class="headerlink" title="存储金额"></a>存储金额</h3><p><strong>金额，价格，统计数据的存储</strong>：对数据的精度要求高,</p>
<p><strong>优化选择</strong>：</p>
<ol>
<li><p><strong>price decimal（8，2）</strong>；定点数，有两位小数的定点数。</p>
</li>
<li><p>price int ，bigint，整数，小单位–&gt;大数额，如<strong>9.01   在数据库中存储2为901，在程序中进行相关处理</strong></p>
<blockquote>
<p>注意：定点数，支持很大的数，</p>
<p>转成小单位后，整数存储不了！</p>
</blockquote>
</li>
</ol>
<h3 id="定长数据类型和变长数据类型的选择"><a href="#定长数据类型和变长数据类型的选择" class="headerlink" title="定长数据类型和变长数据类型的选择"></a>定长数据类型和变长数据类型的选择</h3><p><strong>定点数和浮点数的选择</strong></p>
<p><strong>定点数</strong>：不会精度丢失。 占用空间随者数字的增加而增加</p>
<p><strong>浮点数</strong>：导致精度丢失 。占用固定的存储空间，无论存储多大的数据，占用的空间是固定的（类似于int）</p>
<p><strong>定长类型</strong>：存储空间固定：int，float,double.char,date,time,datetime,year,timestamp</p>
<p><strong>变长类型</strong>：存储空间可变：varchar,decimal,text</p>
<h3 id="字符串类型的选择"><a href="#字符串类型的选择" class="headerlink" title="字符串类型的选择"></a>字符串类型的选择</h3><p><strong>使用varchar</strong></p>
<blockquote>
<p>char(10) 如果你存abc，需要空间为10，3个存abc，7个存空字符，因为char是固定长度</p>
<p>varchar(10)如果你存abc，需要空间为4，3个存abc，1个存长度，varchar是可变长度</p>
<p><strong>超过10的部分，都会被截断</strong></p>
</blockquote>
<p><strong>text,类型独立存储，不占用字段总空间</strong></p>
<h3 id="尽可能选择小的数据类型和指定短的长度"><a href="#尽可能选择小的数据类型和指定短的长度" class="headerlink" title="尽可能选择小的数据类型和指定短的长度"></a>尽可能选择小的数据类型和指定短的长度</h3><h3 id="尽可能使用-not-null"><a href="#尽可能使用-not-null" class="headerlink" title="尽可能使用 not null"></a>尽可能使用 not null</h3><p><strong>非<code>null</code>字段的处理要比<code>null</code>字段的处理高效些</strong>！且不需要判断是否为<code>null</code>。</p>
<p><code>null</code>在MySQL中，不好处理，<strong>存储需要额外空间，运算也需要特殊的运算符</strong>。如<code>select null = null</code>和<code>select null &lt;&gt; null</code>（<code>&lt;&gt;</code>为不等号）有着同样的结果，只能通过<code>is null</code>和<code>is not null</code>来判断字段是否为<code>null</code>。</p>
<blockquote>
<p>MySQL中每条记录都需要额外的存储空间，表示每个字段是否为<code>null</code>。因此通常使用特殊的数据进行占位，比如<code>int not null default 0</code>、<code>string not null default ‘’</code></p>
</blockquote>
<h3 id="字段注释要完整，见名知意"><a href="#字段注释要完整，见名知意" class="headerlink" title="字段注释要完整，见名知意"></a>字段注释要完整，见名知意</h3><h3 id="单表字段不宜过多"><a href="#单表字段不宜过多" class="headerlink" title="单表字段不宜过多"></a>单表字段不宜过多</h3><blockquote>
<p>当单表字段字段过多，可以考虑拆成多张表，将小长度的字段放在一张表，其余的放在其他表中</p>
</blockquote>
<h3 id="可以预留字段"><a href="#可以预留字段" class="headerlink" title="可以预留字段"></a>可以预留字段</h3><blockquote>
<p>优先满足业务，可以预留一些字段</p>
</blockquote>
<h2 id="关联表的设计"><a href="#关联表的设计" class="headerlink" title="关联表的设计"></a>关联表的设计</h2><blockquote>
<p>外键<code>foreign key</code>只能实现一对一或一对多的映射</p>
</blockquote>
<h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><blockquote>
<p>使用外键</p>
</blockquote>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><blockquote>
<p>使用中间表存储两表之间的关联关系</p>
</blockquote>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><blockquote>
<p>如商品的基本信息（<code>item</code>）和商品的详细信息（<code>item_intro</code>），通常使用相同的主键或者增加一个外键字段（<code>item_id</code>）</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote>
<p>关键字与数据的映射关系称为索引（==包含关键字和对应的记录在磁盘中的地址==）。关键字是从数据当中提取的用于标识、检索数据的特定内容。</p>
</blockquote>
<h3 id="索引检索为什么快"><a href="#索引检索为什么快" class="headerlink" title="索引检索为什么快"></a>索引检索为什么快</h3><ol>
<li><p>关键字相对于数据本身，==数据量小==</p>
</li>
<li><p>关键字是==有序==的，二分查找可快速确定位置</p>
<blockquote>
<p>图书馆为每本书都加了索引号（类别-楼层-书架）、字典为词语解释按字母顺序编写目录等都用到了索引。</p>
</blockquote>
</li>
</ol>
<h3 id="MySQL中索引类型"><a href="#MySQL中索引类型" class="headerlink" title="MySQL中索引类型"></a>MySQL中索引类型</h3><ol>
<li><strong>普通索引</strong>（<code>key</code>）</li>
<li><strong>唯一索引</strong>（<code>unique key</code>）</li>
<li><strong>主键索引</strong>（<code>primary key</code>）</li>
<li><strong>全文索引</strong>（<code>fulltext key</code>）</li>
</ol>
<h4 id="索引的关键字有不同的限制："><a href="#索引的关键字有不同的限制：" class="headerlink" title="索引的关键字有不同的限制："></a>索引的关键字有不同的限制：</h4><ul>
<li><strong>普通索引：</strong>对关键字没有限制</li>
<li><strong>唯一索引：</strong>要求记录提供的关键字不能重复</li>
<li><strong>主键索引：</strong>要求关键字唯一且不为null</li>
</ul>
<h3 id="索引管理语法"><a href="#索引管理语法" class="headerlink" title="索引管理语法"></a>索引管理语法</h3><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看建表语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">CREATE</span> <span class="keyword">table</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="comment">--查看表中字段</span></span><br><span class="line"><span class="keyword">desc</span> 表名;</span><br><span class="line"><span class="keyword">desc</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="comment">--查看表中所有索引</span></span><br><span class="line"><span class="keyword">SHOW</span> index <span class="keyword">FROM</span> `表名`</span><br><span class="line"><span class="keyword">SHOW</span> keys <span class="keyword">FROM</span> `表名`;</span><br><span class="line"><span class="keyword">SHOW</span> index <span class="keyword">FROM</span> `user_index`;</span><br><span class="line"><span class="keyword">SHOW</span> keys <span class="keyword">FROM</span> `user_index`;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210312094403.png" alt="image-20210312094403347"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210312094416.png" alt="image-20210312094416711"></p>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><h5 id="创建表之后建立索引"><a href="#创建表之后建立索引" class="headerlink" title="创建表之后建立索引"></a>创建表之后建立索引</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> user_index(</span><br><span class="line">	id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">	first_name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">	last_name <span class="type">VARCHAR</span>(<span class="number">16</span>),</span><br><span class="line">	id_card <span class="type">VARCHAR</span>(<span class="number">18</span>),</span><br><span class="line">	information text</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个first_name和last_name的复合索引，并命名为name</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">add</span> key name (first_name,last_name),</span><br><span class="line"><span class="comment">-- 创建一个id_card的唯一索引，默认以字段名作为索引名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">add</span> <span class="keyword">UNIQUE</span> KEY (id_card),</span><br><span class="line"><span class="comment">-- 鸡肋，全文索引不支持中文</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">add</span> FULLTEXT KEY (information);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="创建表时指定索引"><a href="#创建表时指定索引" class="headerlink" title="创建表时指定索引"></a>创建表时指定索引</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_index2 (</span><br><span class="line">	id <span class="type">INT</span> auto_increment <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	first_name <span class="type">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">	last_name <span class="type">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">	id_card <span class="type">VARCHAR</span> (<span class="number">18</span>),</span><br><span class="line">	information text,</span><br><span class="line">	KEY name (first_name, last_name),</span><br><span class="line">	FULLTEXT KEY (information),</span><br><span class="line">	<span class="keyword">UNIQUE</span> KEY (id_card)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><h5 id="删除普通索引、唯一索引、全文索引"><a href="#删除普通索引、唯一索引、全文索引" class="headerlink" title="删除普通索引、唯一索引、全文索引"></a>删除普通索引、唯一索引、全文索引</h5><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-----删除普通索引、唯一索引、全文索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> KEY 索引名</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY name;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY id_card;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY information;</span><br></pre></td></tr></table></figure>

<h5 id="删除主键索引"><a href="#删除主键索引" class="headerlink" title="删除主键索引"></a>删除主键索引</h5><p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">---删除主键索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">primary</span> key</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">primary</span> key</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210312100733.png" alt="image-20210312100733734"></p>
<p><strong>需要取消自增长</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--取消主键自增</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `表名` MODIFY <span class="keyword">COLUMN</span> 字段名 字段类型（长度） <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">FIRST</span> ;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `user_index` MODIFY <span class="keyword">COLUMN</span> id <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">FIRST</span> ;</span><br><span class="line"><span class="comment">---删除主键索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">primary</span> key</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">primary</span> key</span><br></pre></td></tr></table></figure>

<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ol>
<li><p><strong>like 以%开头</strong>，索引无效；<strong>当like前缀没有%，后缀有%时，索引有效</strong>。</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104045.png" alt="image-20210312104045534"></p>
</li>
<li><p><strong>or语句前后没有同时使用索引</strong>。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104107.png" alt="image-20210312104107314"></p>
</li>
<li><p><strong>组合索引，不是使用第一列索引</strong>，索引失效。</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104314.png" alt="image-20210312104314829"></p>
</li>
<li><p><strong>数据类型出现隐式转化</strong>。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104329.png" alt="image-20210312104329349"></p>
</li>
<li><p><strong><font color=red>在索引列上使用 IS NULL 或 IS NOT NULL操作，索引不一定失效，可能在某些情况会失效</font></strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104455.png" alt="image-20210312104455798"></p>
<p> 此处我将重新创建一个emp表（<strong>此处索引为InnoDB类型索引</strong>）</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104819.png" alt="image-20210312104819712"></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104905.png" alt="image-20210312104905292"></p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">----创建新索引</span></span><br><span class="line"><span class="keyword">create</span> index test2 <span class="keyword">on</span> emp(name)</span><br></pre></td></tr></table></figure>

<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312105105.png" alt="image-20210312105105179"></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312105210.png" alt="image-20210312105210686"></p>
</li>
<li><p>**在索引字段上使用not，&lt;&gt;，!=**。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。</p>
</li>
<li><p><strong>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。</strong></p>
</li>
<li><p><strong>不要在字段中做运算</strong></p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">----下面两条SQL语句在语义上相同，(id为主键)但是第一条会使用主键索引而第二条不会。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">20</span><span class="number">-1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">+</span><span class="number">1</span> <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a>索引使用场景（重点）</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>根据<code>id</code>查询记录，因为<code>id</code>字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增加一个没有建立索引的字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> innodb1 <span class="keyword">add</span> sex <span class="type">char</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 按sex检索时可选的索引为null</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> innodb1 <span class="keyword">where</span> sex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210312103826.png" alt="image-20210312103826193"></p>
<blockquote>
<p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（<code>alter table 表名 add index(字段名)</code>），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p>
</blockquote>
<h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><ul>
<li><p><strong>该字段没有建立索引</strong></p>
<p>  将<strong>查询出的所有数据使用外部排序</strong>（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果）</p>
</li>
<li><p><strong>该字段建立索引</strong></p>
<p>  直接<strong>按照索引的顺序和映射关系逐条取出数据</strong>。而且如果分页的，那么只用<strong>取出索引表某个范围内的索引对应的数据</strong></p>
</li>
</ul>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><blockquote>
<p>对<code>join</code>语句匹配关系（<code>on</code>）涉及的字段建立索引能够提高效率</p>
</blockquote>
<h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在<code>select</code>后==只写必要的查询字段==，以增加索引覆盖的几率。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化分析思路</title>
    <url>/posts/d1898e04/</url>
    <content><![CDATA[<h2 id="调优原则"><a href="#调优原则" class="headerlink" title="调优原则"></a>调优原则</h2><p>  在性能优化时，我们必须遵循一定的原则，否则，有可能得不到正确的调优结果。主要有以下几个方面：</p>
<ul>
<li> 对性能进行分析时，要多方面分析系统的资源瓶颈所在，因为系统某一方面性能低，也许并不是它自己造成的，而是其他方面造成的。如CPU利用率是100%时，很可能是内存容量太小，因为CPU忙于处理内存调度。</li>
<li> 一次只对影响性能的某方面的一个参数进行调整，多个参数同时调整的话，很难界定性能的影响是由哪个参数造成的。</li>
<li>由于在进行系统性能分析时，性能分析工具本身会占用一定的系统资源，如CPU资源、内存资源等等。我们必须注意到这点，即分析工具本身运行可能会导致系统某方面的资源瓶颈情况更加严重。</li>
<li>必须保证调优后的程序运行正确。</li>
<li>调优过程是迭代渐进的过程，每一次调优的结果都要反馈到后续的代码开发中去。</li>
<li>性能调优不能以牺牲代码的可读性和可维护性为代价。</li>
</ul>
<h2 id="调优分析思路"><a href="#调优分析思路" class="headerlink" title="调优分析思路"></a>调优分析思路</h2><ol>
<li>很多情况下压测流量并没有完全进入到服务端，在网络上可能就会出现由于各种规格（带宽、最大连接数、新建连接数等）限制，导致压测结果达不到预期。</li>
<li>看关键指标是否满足要求，如果不满足，需要确定是哪个地方有问题，一般情况下，服务器端问题可能性比较大，也有可能是客户端问题（这种情况比较小）。</li>
<li>对于服务器端问题，需要定位的是硬件相关指标，例如CPU，Memory，Disk I/O，Network I/O，如果是某个硬件指标有问题，需要深入的进行分析。</li>
<li>如果硬件指标都没有问题，需要查看数据库相关指标，例如：等待事件、内存命中率等。</li>
<li>如果以上指标都正常，应用程序的算法、缓冲、缓存、同步或异步可能有问题，需要具体深入的分析。</li>
</ol>
<h3 id="可能的瓶颈点"><a href="#可能的瓶颈点" class="headerlink" title="可能的瓶颈点"></a>可能的瓶颈点</h3><table>
<thead>
<tr>
<th>瓶颈点</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>硬件/规格</td>
<td align="center">一般指的是CPU、内存、磁盘I/O方面的问题，分为服务器硬件瓶颈、网络瓶颈（对局域网可以不考虑）。</td>
</tr>
<tr>
<td>操作系统</td>
<td align="center">一般指的是windows、UNIX、Linux等操作系统。<br>例如，在进行性能测试出现物理内存不足时，虚拟内存设置也不合理，虚拟内存的交换效率就会大大降低，<br>从而导致行为的响应时间大大增加，这时认为操作系统上出现性能瓶颈。</td>
</tr>
<tr>
<td>数据库</td>
<td align="center">一般指的是数据库配置等方面的问题。<br>例如，由于参数配置不合理，导致数据库处理速度慢的问题，可认为是数据库层面的的问题。</td>
</tr>
</tbody></table>
<h2 id="MySQL数据库优化"><a href="#MySQL数据库优化" class="headerlink" title="MySQL数据库优化"></a>MySQL数据库优化</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309171911.png" alt="image-20210309171911716"></p>
<h3 id="连接——配置优化"><a href="#连接——配置优化" class="headerlink" title="连接——配置优化"></a>连接——配置优化</h3><p>客户端连接到服务端可能出现的问题：  服务端连接数不够导致应用程序获取不到连接</p>
<p>可以从两个方面来解决连接数不够的问题：</p>
<ol>
<li><p><strong>从服务端来说，我们可以增加服务端的可用连接数</strong>。</p>
<p> 如果有多个应用或者很多请求同时访问数据库，连接数不够的时候，我们可以：</p>
<ul>
<li><p>修改配置参数增加可用连接数，修改 max_connections 的大小</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>; <span class="comment">-- 修改最大连接数，当有多个应用连接的时候</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>及时释放不活动的连接。交互式和非交互式的客户端的默认超时时 间都是 28800 秒，8 小时，我们可以把这个值调小</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>; <span class="comment">--及时释放不活动的连接，注意不要释放连接池还在使用的连接</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>从客户端来说，可以减少从服务端获取的连接数，如果我们想要不是每一次执行 SQL 都创建一个新的连接，可以引入连接池，实现连接的重用</strong>。</p>
</li>
</ol>
<h3 id="缓存——架构优化"><a href="#缓存——架构优化" class="headerlink" title="缓存——架构优化"></a>缓存——架构优化</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>在应用系统的并发数非常大的情况下，如果没有缓存，会造成两个问题：</p>
<ol>
<li> 会给数据库带来很大的压力。</li>
<li>从应用的层面来说，操作数据的速度也会受到 影响。</li>
</ol>
<p><strong>解决方案</strong>：</p>
<p>用第三方的缓存服务来解决这个问题，例如 Redis。</p>
<h4 id="集群，主从复制"><a href="#集群，主从复制" class="headerlink" title="集群，主从复制"></a>集群，主从复制</h4><p>如果单台数据库服务满足不了访问需求，那我们可以做数据库的集群方案</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309172434.png" alt="image-20210309172434821"></p>
<p>做了<strong>主从复制的方案之后，我们只把数据写入 master 节点，而读的请求可以分担到 slave 节点。我们把这种方案叫做读写分离</strong>。</p>
<p><strong>读写分离可以一定程度低减轻数据库服务器的访问压力，但是需要特别注意主从数 据一致性的问题。</strong></p>
<h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p><strong>垂直分库，减少并发压力。水平分表，解决存储瓶颈</strong></p>
<p>垂直分库的做法，<strong>把一个数据库按照业务拆分成不同的数据库</strong>：</p>
<p>水平分库分表的做法，<strong>把单张表的数据按照一定的规则分布到多个数据库</strong>。</p>
<h3 id="优化器——SQL-语句分析与优化"><a href="#优化器——SQL-语句分析与优化" class="headerlink" title="优化器——SQL 语句分析与优化"></a>优化器——SQL 语句分析与优化</h3><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html">慢查询日志</a></p>
<h5 id="打开慢日志开关"><a href="#打开慢日志开关" class="headerlink" title="打开慢日志开关"></a>打开慢日志开关</h5><p>因为开启慢查询日志是有代价的（跟 bin log、optimizer-trace 一样），所以它默 认是关闭的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>除了这个开关，还有一个参数，控制执行超过多长时间的 SQL 才记录到慢日志，默 认是 10 秒。如果改成 0 秒的话就是记录所有的 SQL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以直接动态修改参数（重启后失效）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@global</span>.slow_query_log<span class="operator">=</span><span class="number">1</span>; <span class="comment">-- 1 开启，0 关闭，重启后失效</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@global</span>.long_query_time<span class="operator">=</span><span class="number">3</span>; <span class="comment">-- mysql 默认的慢查询时间是 10 秒，另开一个窗口后才会查到最新值</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query%&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>修改配置文件 my.cnf。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slow_query_log = ON</span><br><span class="line">long_query_time=2</span><br><span class="line">slow_query_log_file =/var/lib/mysql/localhost-slow.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="慢日志分析"><a href="#慢日志分析" class="headerlink" title="慢日志分析"></a>慢日志分析</h5><h5 id="直接查看日志内容"><a href="#直接查看日志内容" class="headerlink" title="直接查看日志内容"></a>直接查看日志内容</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;slow_queries&#x27;</span>; <span class="comment">-- 查看有多少慢查询</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query%&#x27;</span>; <span class="comment">-- 获取慢日志目录</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/lib/mysql/ localhost-slow.log</span><br></pre></td></tr></table></figure>

<h5 id="使用mysqldumpslow工具"><a href="#使用mysqldumpslow工具" class="headerlink" title="使用mysqldumpslow工具"></a>使用mysqldumpslow工具</h5><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldumpslow.html">**mysqldumpslow-**汇总慢查询日志文件</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查询用时最多的 10 条慢 SQL</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g &#x27;select&#x27; /var/lib/mysql/localhost-slow.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309173926.png" alt="image-20210309173926526"></p>
<p>Count 代表这个 SQL 执行了多少次；</p>
<p>Time 代表执行的时间，括号里面是累计时间；</p>
<p>Lock 表示锁定的时间，括号是累计；</p>
<p>Rows 表示返回的记录数，括号是累计。</p>
<h4 id="SHOW-PROFILE"><a href="#SHOW-PROFILE" class="headerlink" title="SHOW PROFILE"></a>SHOW PROFILE</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/show-profile.html">SHOW PROFILE语句</a></p>
<h5 id="查看是否开启"><a href="#查看是否开启" class="headerlink" title="查看是否开启"></a>查看是否开启</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看profiling状态</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br><span class="line">#设置开启</span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@profiling</span><span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309174257.png" alt="image-20210309174257643"></p>
<h5 id="查看-profile-统计"><a href="#查看-profile-统计" class="headerlink" title="查看 profile 统计"></a>查看 profile 统计</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309174406.png" alt="image-20210309174406930"></p>
<h5 id="查询指定query-id详细信息"><a href="#查询指定query-id详细信息" class="headerlink" title="查询指定query_id详细信息"></a>查询指定query_id详细信息</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#不指定id，默认查最后一条</span><br><span class="line"><span class="keyword">show</span> profile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309174559.png" alt="image-20210309174559267"></p>
<h4 id="使用performance-schema"><a href="#使用performance-schema" class="headerlink" title="使用performance schema"></a>使用performance schema</h4><p><a href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema-system-variables.html">performance schema</a></p>
<p><strong>MySQL的performance schema 用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况</strong>。</p>
<h5 id="performance-schema"><a href="#performance-schema" class="headerlink" title="performance schema"></a>performance schema</h5><p>在mysql的5.7版本中，性能模式是默认开启的，如果想要显式的关闭的话需要修改配置文件，不能直接进行修改，会报错Variable ‘performance_schema’ is a read only variable。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看performance_schema的属性</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;performance_schema&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name      <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">--在配置文件中修改performance_schema的属性值，on表示开启，off表示关闭</span></span><br><span class="line">[mysqld]</span><br><span class="line">performance_schema<span class="operator">=</span><span class="keyword">ON</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--切换数据库</span></span><br><span class="line">use performance_schema;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看当前数据库下的所有表,会看到有很多表存储着相关的信息</span></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="comment">--可以通过show create table tablename来查看创建表的时候的表结构</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> setup_consumers;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+---------------------------------</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>           <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                    </span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+---------------------------------</span></span><br><span class="line"><span class="operator">|</span> setup_consumers <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `setup_consumers` (</span><br><span class="line">  `NAME` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                      </span><br><span class="line">  `ENABLED` enum(<span class="string">&#x27;YES&#x27;</span>,<span class="string">&#x27;NO&#x27;</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>               </span><br><span class="line">) ENGINE<span class="operator">=</span>PERFORMANCE_SCHEMA <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span>  </span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+---------------------------------</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)                             </span><br></pre></td></tr></table></figure>

<p>​    instruments: 生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项。</p>
<p>​        consumers:消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项。</p>
<h5 id="performance-schema表的分类"><a href="#performance-schema表的分类" class="headerlink" title="performance_schema表的分类"></a>performance_schema表的分类</h5><p>performance_schema库下的表可以按照监视不同的纬度就行分组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--语句事件记录表，这些表记录了语句事件信息，当前语句事件表events_statements_current、历史语句事件表events_statements_history和长语句历史事件表events_statements_history_long、以及聚合后的摘要表summary，其中，summary表还可以根据帐号(account)，主机(host)，程序(program)，线程(thread)，用户(user)和全局(global)再进行细分)</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%statement%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--等待事件记录表，与语句事件类型的相关记录表类似：</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%wait%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--阶段事件记录表，记录语句执行的阶段事件的表</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%stage%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务事件记录表，记录事务相关的事件的表</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%transaction%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--监控文件系统层调用的表</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%file%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--监视内存使用的表</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%memory%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--动态对performance_schema进行配置的配置表</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%setup%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="performance-schema的简单配置与使用"><a href="#performance-schema的简单配置与使用" class="headerlink" title="performance_schema的简单配置与使用"></a>performance_schema的简单配置与使用</h5><p>数据库刚刚初始化并启动时，并非所有instruments(事件采集项，在采集项的配置表中每一项都有一个开关字段，或为YES，或为NO)和consumers(与采集项类似，也有一个对应的事件类型保存表配置项，为YES就表示对应的表保存性能数据，为NO就表示对应的表不保存性能数据)都启用了，所以默认不会收集所有的事件，可能你需要检测的事件并没有打开，需要进行设置，可以使用如下两个语句打开对应的instruments和consumers（行计数可能会因MySQL版本而异)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--打开等待事件的采集器配置项开关，需要修改setup_instruments配置表中对应的采集器配置项</span></span><br><span class="line">UPDATE setup_instruments <span class="keyword">SET</span> ENABLED <span class="operator">=</span> <span class="string">&#x27;YES&#x27;</span>, TIMED <span class="operator">=</span> <span class="string">&#x27;YES&#x27;</span><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;wait%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--打开等待事件的保存表配置开关，修改setup_consumers配置表中对应的配置项</span></span><br><span class="line">UPDATE setup_consumers <span class="keyword">SET</span> ENABLED <span class="operator">=</span> <span class="string">&#x27;YES&#x27;</span><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%wait%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--当配置完成之后可以查看当前server正在做什么，可以通过查询events_waits_current表来得知，该表中每个线程只包含一行数据，用于显示每个线程的最新监视事件</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> events_waits_current\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">            THREAD_ID: <span class="number">11</span></span><br><span class="line">             EVENT_ID: <span class="number">570</span></span><br><span class="line">         END_EVENT_ID: <span class="number">570</span></span><br><span class="line">           EVENT_NAME: wait<span class="operator">/</span>synch<span class="operator">/</span>mutex<span class="operator">/</span>innodb<span class="operator">/</span>buf_dblwr_mutex</span><br><span class="line">               SOURCE: </span><br><span class="line">          TIMER_START: <span class="number">4508505105239280</span></span><br><span class="line">            TIMER_END: <span class="number">4508505105270160</span></span><br><span class="line">           TIMER_WAIT: <span class="number">30880</span></span><br><span class="line">                SPINS: <span class="keyword">NULL</span></span><br><span class="line">        OBJECT_SCHEMA: <span class="keyword">NULL</span></span><br><span class="line">          OBJECT_NAME: <span class="keyword">NULL</span></span><br><span class="line">           INDEX_NAME: <span class="keyword">NULL</span></span><br><span class="line">          OBJECT_TYPE: <span class="keyword">NULL</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">67918392</span></span><br><span class="line">     NESTING_EVENT_ID: <span class="keyword">NULL</span></span><br><span class="line">   NESTING_EVENT_TYPE: <span class="keyword">NULL</span></span><br><span class="line">            OPERATION: lock</span><br><span class="line">      NUMBER_OF_BYTES: <span class="keyword">NULL</span></span><br><span class="line">                FLAGS: <span class="keyword">NULL</span></span><br><span class="line"><span class="comment">/*该信息表示线程id为11的线程正在等待buf_dblwr_mutex锁，等待事件为30880</span></span><br><span class="line"><span class="comment">属性说明：</span></span><br><span class="line"><span class="comment">	id:事件来自哪个线程，事件编号是多少</span></span><br><span class="line"><span class="comment">	event_name:表示检测到的具体的内容</span></span><br><span class="line"><span class="comment">	source:表示这个检测代码在哪个源文件中以及行号</span></span><br><span class="line"><span class="comment">	timer_start:表示该事件的开始时间</span></span><br><span class="line"><span class="comment">	timer_end:表示该事件的结束时间</span></span><br><span class="line"><span class="comment">	timer_wait:表示该事件总的花费时间</span></span><br><span class="line"><span class="comment">注意：_current表中每个线程只保留一条记录，一旦线程完成工作，该表中不会再记录该线程的事件信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">_history表中记录每个线程应该执行完成的事件信息，但每个线程的事件信息只会记录10条，再多就会被覆盖，*_history_long表中记录所有线程的事件信息，但总记录数量是10000，超过就会被覆盖掉</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> thread_id,event_id,event_name,timer_wait <span class="keyword">from</span> events_waits_history <span class="keyword">order</span> <span class="keyword">by</span> thread_id limit <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">summary表提供所有事件的汇总信息，该组中的表以不同的方式汇总事件数据（如：按用户，按主机，按线程等等）。例如：要查看哪些instruments占用最多的时间，可以通过对events_waits_summary_global_by_event_name表的COUNT_STAR或SUM_TIMER_WAIT列进行查询（这两列是对事件的记录数执行COUNT（*）、事件记录的TIMER_WAIT列执行SUM（TIMER_WAIT）统计而来）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> EVENT_NAME,COUNT_STAR <span class="keyword">FROM</span> events_waits_summary_global_by_event_name  <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">instance表记录了哪些类型的对象会被检测。这些对象在被server使用时，在该表中将会产生一条事件记录，例如，file_instances表列出了文件I/O操作及其关联文件名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> file_instances limit <span class="number">20</span>; </span><br></pre></td></tr></table></figure>

<h5 id="常用配置项的参数说明"><a href="#常用配置项的参数说明" class="headerlink" title="常用配置项的参数说明"></a>常用配置项的参数说明</h5><h6 id="启动选项"><a href="#启动选项" class="headerlink" title="启动选项"></a>启动选项</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">performance_schema_consumer_events_statements_current<span class="operator">=</span><span class="literal">TRUE</span></span><br><span class="line">是否在mysql server启动时就开启events_statements_current表的记录功能(该表记录当前的语句事件信息)，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新setup_consumers配置表中的events_statements_current配置项，默认值为<span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">performance_schema_consumer_events_statements_history<span class="operator">=</span><span class="literal">TRUE</span></span><br><span class="line">与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件短历史信息，默认为<span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">performance_schema_consumer_events_stages_history_long<span class="operator">=</span><span class="literal">FALSE</span></span><br><span class="line">与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件长历史信息，默认为<span class="literal">FALSE</span></span><br><span class="line"></span><br><span class="line">除了statement(语句)事件之外，还支持：wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个启动项分别进行配置，但这些等待事件默认未启用，如果需要在MySQL Server启动时一同启动，则通常需要写进my.cnf配置文件中</span><br><span class="line">performance_schema_consumer_global_instrumentation<span class="operator">=</span><span class="literal">TRUE</span></span><br><span class="line">是否在MySQL Server启动时就开启全局表（如：mutex_instances、rwlock_instances、cond_instances、file_instances、users、hostsaccounts、socket_summary_by_event_name、file_summary_by_instance等大部分的全局对象计数统计和事件汇总统计信息表 ）的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新全局配置项</span><br><span class="line">默认值为<span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">performance_schema_consumer_statements_digest<span class="operator">=</span><span class="literal">TRUE</span></span><br><span class="line">是否在MySQL Server启动时就开启events_statements_summary_by_digest 表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新digest配置项</span><br><span class="line">默认值为<span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">performance_schema_consumer_thread_instrumentation<span class="operator">=</span><span class="literal">TRUE</span></span><br><span class="line">是否在MySQL Server启动时就开启</span><br><span class="line"></span><br><span class="line">events_xxx_summary_by_yyy_by_event_name表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新线程配置项</span><br><span class="line">默认值为<span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">performance_schema_instrument[<span class="operator">=</span>name]</span><br><span class="line">是否在MySQL Server启动时就启用某些采集器，由于instruments配置项多达数千个，所以该配置项支持key<span class="operator">-</span><span class="keyword">value</span>模式，还支持<span class="operator">%</span>号进行通配等，如下:</span><br><span class="line"></span><br><span class="line"># [<span class="operator">=</span>name]可以指定为具体的Instruments名称（但是这样如果有多个需要指定的时候，就需要使用该选项多次），也可以使用通配符，可以指定instruments相同的前缀<span class="operator">+</span>通配符，也可以使用<span class="operator">%</span>代表所有的instruments</span><br><span class="line"></span><br><span class="line">## 指定开启单个instruments</span><br><span class="line"></span><br><span class="line"><span class="comment">--performance-schema-instrument= &#x27;instrument_name=value&#x27;</span></span><br><span class="line"></span><br><span class="line">## 使用通配符指定开启多个instruments</span><br><span class="line"></span><br><span class="line"><span class="comment">--performance-schema-instrument= &#x27;wait/synch/cond/%=COUNTED&#x27;</span></span><br><span class="line"></span><br><span class="line">## 开关所有的instruments</span><br><span class="line"></span><br><span class="line"><span class="comment">--performance-schema-instrument= &#x27;%=ON&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--performance-schema-instrument= &#x27;%=OFF&#x27;</span></span><br><span class="line"></span><br><span class="line">注意，这些启动选项要生效的前提是，需要设置performance_schema<span class="operator">=</span><span class="keyword">ON</span>。另外，这些启动选项虽然无法使用<span class="keyword">show</span> variables语句查看，但我们可以通过setup_instruments和setup_consumers表查询这些选项指定的值。</span><br></pre></td></tr></table></figure>

<h6 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%performance_schema%&#x27;</span>;</span><br><span class="line"><span class="comment">--重要的属性解释</span></span><br><span class="line">performance_schema<span class="operator">=</span><span class="keyword">ON</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制performance_schema功能的开关，要使用MySQL的performance_schema，需要在mysqld启动时启用，以启用事件收集功能</span></span><br><span class="line"><span class="comment">该参数在5.7.x之前支持performance_schema的版本中默认关闭，5.7.x版本开始默认开启</span></span><br><span class="line"><span class="comment">注意：如果mysqld在初始化performance_schema时发现无法分配任何相关的内部缓冲区，则performance_schema将自动禁用，并将performance_schema设置为OFF</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">performance_schema_digests_size<span class="operator">=</span><span class="number">10000</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制events_statements_summary_by_digest表中的最大行数。如果产生的语句摘要信息超过此最大值，便无法继续存入该表，此时performance_schema会增加状态变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">performance_schema_events_statements_history_long_size<span class="operator">=</span><span class="number">10000</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制events_statements_history_long表中的最大行数，该参数控制所有会话在events_statements_history_long表中能够存放的总事件记录数，超过这个限制之后，最早的记录将被覆盖</span></span><br><span class="line"><span class="comment">全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10000，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10000 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">performance_schema_events_statements_history_size<span class="operator">=</span><span class="number">10</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制events_statements_history表中单个线程（会话）的最大行数，该参数控制单个会话在events_statements_history表中能够存放的事件记录数，超过这个限制之后，单个会话最早的记录将被覆盖</span></span><br><span class="line"><span class="comment">全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10</span></span><br><span class="line"><span class="comment">除了statement(语句)事件之外，wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个参数分别进行存储限制配置，有兴趣的同学自行研究，这里不再赘述</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">performance_schema_max_digest_length<span class="operator">=</span><span class="number">1024</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用于控制标准化形式的SQL语句文本在存入performance_schema时的限制长度，该变量与max_digest_length变量相关(max_digest_length变量含义请自行查阅相关资料)</span></span><br><span class="line"><span class="comment">全局变量，只读变量，默认值1024字节，整型值，取值范围0~1048576</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">performance_schema_max_sql_text_length<span class="operator">=</span><span class="number">1024</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制存入events_statements_current，events_statements_history和events_statements_history_long语句事件表中的SQL_TEXT列的最大SQL长度字节数。 超出系统变量performance_schema_max_sql_text_length的部分将被丢弃，不会记录，一般情况下不需要调整该参数，除非被截断的部分与其他SQL比起来有很大差异</span></span><br><span class="line"><span class="comment">全局变量，只读变量，整型值，默认值为1024字节，取值范围为0~1048576，5.7.6版本引入</span></span><br><span class="line"><span class="comment">降低系统变量performance_schema_max_sql_text_length值可以减少内存使用，但如果汇总的SQL中，被截断部分有较大差异，会导致没有办法再对这些有较大差异的SQL进行区分。 增加该系统变量值会增加内存使用，但对于汇总SQL来讲可以更精准地区分不同的部分。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h6 id="重要配置表的相关说明"><a href="#重要配置表的相关说明" class="headerlink" title="重要配置表的相关说明"></a>重要配置表的相关说明</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">performance_timers表中记录了server中有哪些可用的事件计时器</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	timer_name:表示可用计时器名称，CYCLE是基于CPU周期计数器的定时器</span></span><br><span class="line"><span class="comment">	timer_frequency:表示每秒钟对应的计时器单位的数量,CYCLE计时器的换算值与CPU的频率相关、</span></span><br><span class="line"><span class="comment">	timer_resolution:计时器精度值，表示在每个计时器被调用时额外增加的值</span></span><br><span class="line"><span class="comment">	timer_overhead:表示在使用定时器获取事件时开销的最小周期值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_timers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">setup_timers表中记录当前使用的事件计时器信息</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	name:计时器类型，对应某个事件类别</span></span><br><span class="line"><span class="comment">	timer_name:计时器类型名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> setup_timers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">setup_consumers表中列出了consumers可配置列表项</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	NAME：consumers配置名称</span></span><br><span class="line"><span class="comment">	ENABLED：consumers是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> setup_consumers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">setup_instruments 表列出了instruments 列表配置项，即代表了哪些事件支持被收集：</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	NAME：instruments名称，instruments名称可能具有多个部分并形成层次结构</span></span><br><span class="line"><span class="comment">	ENABLED：instrumetns是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。如果设置为NO，则这个instruments不会被执行，不会产生任何的事件信息</span></span><br><span class="line"><span class="comment">	TIMED：instruments是否收集时间信息，有效值为YES或NO，此列可以使用UPDATE语句修改，如果设置为NO，则这个instruments不会收集时间信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> setup_instruments;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">setup_actors表的初始内容是匹配任何用户和主机，因此对于所有前台线程，默认情况下启用监视和历史事件收集功能</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	HOST：与grant语句类似的主机名，一个具体的字符串名字，或使用“％”表示“任何主机”</span></span><br><span class="line"><span class="comment">	USER：一个具体的字符串名称，或使用“％”表示“任何用户”</span></span><br><span class="line"><span class="comment">	ROLE：当前未使用，MySQL 8.0中才启用角色功能</span></span><br><span class="line"><span class="comment">	ENABLED：是否启用与HOST，USER，ROLE匹配的前台线程的监控功能，有效值为：YES或NO</span></span><br><span class="line"><span class="comment">	HISTORY：是否启用与HOST， USER，ROLE匹配的前台线程的历史事件记录功能，有效值为：YES或NO</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> setup_actors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">setup_objects表控制performance_schema是否监视特定对象。默认情况下，此表的最大行数为100行。</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	OBJECT_TYPE：instruments类型，有效值为：“EVENT”（事件调度器事件）、“FUNCTION”（存储函数）、“PROCEDURE”（存储过程）、“TABLE”（基表）、“TRIGGER”（触发器），TABLE对象类型的配置会影响表I/O事件（wait/io/table/sql/handler instrument）和表锁事件（wait/lock/table/sql/handler instrument）的收集</span></span><br><span class="line"><span class="comment">	OBJECT_SCHEMA：某个监视类型对象涵盖的数据库名称，一个字符串名称，或“％”(表示“任何数据库”)</span></span><br><span class="line"><span class="comment">	OBJECT_NAME：某个监视类型对象涵盖的表名，一个字符串名称，或“％”(表示“任何数据库内的对象”)</span></span><br><span class="line"><span class="comment">	ENABLED：是否开启对某个类型对象的监视功能，有效值为：YES或NO。此列可以修改</span></span><br><span class="line"><span class="comment">	TIMED：是否开启对某个类型对象的时间收集功能，有效值为：YES或NO，此列可以修改</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> setup_objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">threads表对于每个server线程生成一行包含线程相关的信息，</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	THREAD_ID：线程的唯一标识符（ID）</span></span><br><span class="line"><span class="comment">	NAME：与server中的线程检测代码相关联的名称(注意，这里不是instruments名称)</span></span><br><span class="line"><span class="comment">	TYPE：线程类型，有效值为：FOREGROUND、BACKGROUND。分别表示前台线程和后台线程</span></span><br><span class="line"><span class="comment">	PROCESSLIST_ID：对应INFORMATION_SCHEMA.PROCESSLIST表中的ID列。</span></span><br><span class="line"><span class="comment">	PROCESSLIST_USER：与前台线程相关联的用户名，对于后台线程为NULL。</span></span><br><span class="line"><span class="comment">	PROCESSLIST_HOST：与前台线程关联的客户端的主机名，对于后台线程为NULL。</span></span><br><span class="line"><span class="comment">	PROCESSLIST_DB：线程的默认数据库，如果没有，则为NULL。</span></span><br><span class="line"><span class="comment">	PROCESSLIST_COMMAND：对于前台线程，该值代表着当前客户端正在执行的command类型，如果是sleep则表示当前会话处于空闲状态</span></span><br><span class="line"><span class="comment">	PROCESSLIST_TIME：当前线程已处于当前线程状态的持续时间（秒）</span></span><br><span class="line"><span class="comment">	PROCESSLIST_STATE：表示线程正在做什么事情。</span></span><br><span class="line"><span class="comment">	PROCESSLIST_INFO：线程正在执行的语句，如果没有执行任何语句，则为NULL。</span></span><br><span class="line"><span class="comment">	PARENT_THREAD_ID：如果这个线程是一个子线程（由另一个线程生成），那么该字段显示其父线程ID</span></span><br><span class="line"><span class="comment">	ROLE：暂未使用</span></span><br><span class="line"><span class="comment">	INSTRUMENTED：线程执行的事件是否被检测。有效值：YES、NO </span></span><br><span class="line"><span class="comment">	HISTORY：是否记录线程的历史事件。有效值：YES、NO * </span></span><br><span class="line"><span class="comment">	THREAD_OS_ID：由操作系统层定义的线程或任务标识符（ID）：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> threads</span><br></pre></td></tr></table></figure>

<h5 id="performance-schema实践操作"><a href="#performance-schema实践操作" class="headerlink" title="performance_schema实践操作"></a>performance_schema实践操作</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--1、哪类的SQL执行最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,COUNT_STAR,FIRST_SEEN,LAST_SEEN <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--2、哪类SQL的平均响应时间最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,AVG_TIMER_WAIT <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--3、哪类SQL排序记录数最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_SORT_ROWS <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--4、哪类SQL扫描记录数最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_ROWS_EXAMINED <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--5、哪类SQL使用临时表最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_CREATED_TMP_TABLES,SUM_CREATED_TMP_DISK_TABLES <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--6、哪类SQL返回结果集最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_ROWS_SENT <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--7、哪个表物理IO最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> file_name,event_name,SUM_NUMBER_OF_BYTES_READ,SUM_NUMBER_OF_BYTES_WRITE <span class="keyword">FROM</span> file_summary_by_instance <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUM_NUMBER_OF_BYTES_READ <span class="operator">+</span> SUM_NUMBER_OF_BYTES_WRITE <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--8、哪个表逻辑IO最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> object_name,COUNT_READ,COUNT_WRITE,COUNT_FETCH,SUM_TIMER_WAIT <span class="keyword">FROM</span> table_io_waits_summary_by_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> sum_timer_wait <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--9、哪个索引访问最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> OBJECT_NAME,INDEX_NAME,COUNT_FETCH,COUNT_INSERT,COUNT_UPDATE,COUNT_DELETE <span class="keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUM_TIMER_WAIT <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--10、哪个索引从来没有用过？</span></span><br><span class="line"><span class="keyword">SELECT</span> OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME <span class="keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="keyword">WHERE</span> INDEX_NAME <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> COUNT_STAR <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> OBJECT_SCHEMA <span class="operator">&lt;&gt;</span> <span class="string">&#x27;mysql&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> OBJECT_SCHEMA,OBJECT_NAME;</span><br><span class="line"><span class="comment">--11、哪个等待事件消耗时间最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> EVENT_NAME,COUNT_STAR,SUM_TIMER_WAIT,AVG_TIMER_WAIT <span class="keyword">FROM</span> events_waits_summary_global_by_event_name <span class="keyword">WHERE</span> event_name <span class="operator">!=</span> <span class="string">&#x27;idle&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUM_TIMER_WAIT <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--12-1、剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息</span></span><br><span class="line"><span class="keyword">SELECT</span> EVENT_ID,sql_text <span class="keyword">FROM</span> events_statements_history <span class="keyword">WHERE</span> sql_text <span class="keyword">LIKE</span> <span class="string">&#x27;%count(*)%&#x27;</span>;</span><br><span class="line"><span class="comment">--12-2、查看每个阶段的时间消耗</span></span><br><span class="line"><span class="keyword">SELECT</span> event_id,EVENT_NAME,SOURCE,TIMER_END <span class="operator">-</span> TIMER_START <span class="keyword">FROM</span> events_stages_history_long <span class="keyword">WHERE</span> NESTING_EVENT_ID <span class="operator">=</span> <span class="number">1553</span>;</span><br><span class="line"><span class="comment">--12-3、查看每个阶段的锁等待情况</span></span><br><span class="line"><span class="keyword">SELECT</span> event_id,event_name,source,timer_wait,object_name,index_name,operation,nesting_event_id <span class="keyword">FROM</span> events_waits_history_longWHERE nesting_event_id <span class="operator">=</span> <span class="number">1553</span>;</span><br></pre></td></tr></table></figure>

<h4 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">mysql执行计划</a></p>
<p>可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。</p>
<h5 id="执行计划中包含的信息"><a href="#执行计划中包含的信息" class="headerlink" title="执行计划中包含的信息"></a>执行计划中包含的信息</h5><table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">涵义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">The <code>SELECT</code> identifier</td>
</tr>
<tr>
<td align="center">select_type</td>
<td align="center">The <code>SELECT</code> type</td>
</tr>
<tr>
<td align="center">table</td>
<td align="center">The table for the output row</td>
</tr>
<tr>
<td align="center">partitions</td>
<td align="center">The matching partitions</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">The join type</td>
</tr>
<tr>
<td align="center">possible_keys</td>
<td align="center">The possible indexes to choose</td>
</tr>
<tr>
<td align="center">key</td>
<td align="center">The index actually chosen</td>
</tr>
<tr>
<td align="center">key_len</td>
<td align="center">The length of the chosen key</td>
</tr>
<tr>
<td align="center">ref</td>
<td align="center">The columns compared to the index</td>
</tr>
<tr>
<td align="center">rows</td>
<td align="center">Estimate of rows to be examined</td>
</tr>
<tr>
<td align="center">filtered</td>
<td align="center">Percentage of rows filtered by table condition</td>
</tr>
<tr>
<td align="center">extra</td>
<td align="center">Additional information</td>
</tr>
</tbody></table>
<p><strong>执行计划是</strong>：当执行SQL语句时，首先会分析、优化，形成执行计划，在按照执行计划执行。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的索引</title>
    <url>/posts/9edcaf99/</url>
    <content><![CDATA[<h2 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h2><p>索引是什么了，查阅了官方文档。官方文档写了索引的作用和没有索引会带来全表扫描，非常费时间。 <code>Indexes are used to find rows with specific column values quickly. Without an index, MySQL must begin with the first row and then read through the entire table to find the relevant rows.</code> 简单的说索引是提高查询速度。这个很好理解，就像是以前的英文词典，找单词如果没有前面目录的话，效率很低，得全文找一遍。</p>
<h2 id="索引实现原理"><a href="#索引实现原理" class="headerlink" title="索引实现原理"></a>索引实现原理</h2><p>要搞清楚索引的实现原理，先看看索引的底层实现，<strong>MySQL索引大部分采用B-Tree实现，B-Tree又有B-树和B+树</strong>。还有一些使用Hash索引。</p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>再说B-Tree之前，先简单了解一下二叉搜索树（Binary Search Trees）。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309160238.png" alt="image-20210309160238726"></p>
<p>理解二叉搜索树，对于后面理解B-和B+树很有帮助，因为这2种有些特性跟二叉搜索树很像。二叉搜索树的特点是左孩子的值小于父亲节点的值，父亲节点的值小于右孩子的值，即按二叉树的中序遍历，刚好是一个按小到大排序的。二叉搜索树的查找就可以使用二分查找，如果要查找10，因为10比27小，所以往左孩子找，10&lt;14，还在左孩子找。最坏的情况下，<strong>查找的次数等于树的高度</strong>。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p><strong>B树和B-tree理解成了两种不同类别的树，其实这两个是同一种树;</strong></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构</p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol>
<li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</li>
<li>子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</li>
<li>关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</li>
<li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309163100.png" alt="image-20210309163059977"></p>
<h4 id="B树查询流程"><a href="#B树查询流程" class="headerlink" title="B树查询流程"></a>B树查询流程</h4><p>从上图中找到E字母，查找流程如下</p>
<ol>
<li>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li>
<li>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</li>
<li>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</li>
</ol>
<h4 id="B树插入节点流程"><a href="#B树插入节点流程" class="headerlink" title="B树插入节点流程"></a>B树插入节点流程</h4><p>节点要处于违规状态，它必须包含在可接受范围之外数目的元素。</p>
<ol>
<li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。</li>
<li>如果没有节点处于违规状态则处理结束。</li>
<li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。</li>
</ol>
<h4 id="B树删除节点流程"><a href="#B树删除节点流程" class="headerlink" title="B树删除节点流程"></a>B树删除节点流程</h4><ol>
<li>首先，查找要删除的值。接着从包含它的节点中删除这个值。</li>
<li>如果没有节点处于违规状态则处理结束。</li>
<li>如果节点处于违规状态则有两种可能情况：<ol>
<li>它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。</li>
<li>它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</li>
</ol>
</li>
</ol>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。</p>
<h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><ol>
<li>B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；</li>
<li>B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li>
<li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li>
<li><strong>非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）</strong>;</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快</li>
<li>B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li>
<li>B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li>
<li>B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
</ol>
<blockquote>
<p>B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</p>
</blockquote>
<h2 id="为什么是B-Tree-B-来实现数据库索引"><a href="#为什么是B-Tree-B-来实现数据库索引" class="headerlink" title="为什么是B-Tree(B+)来实现数据库索引"></a>为什么是B-Tree(B+)来实现数据库索引</h2><h3 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h3><p>数据导论书中开头就是说： B树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树,计算机系统有主存和基于磁盘的辅存，主存通常就是我们说的RAM，也就是内存，这里不展开说它。<strong>索引文件本身很大，一般不会存在内存里，因此索引往往是以文件的形式存储在磁盘里，所以索引检索需要磁盘I/O操作</strong></p>
<p>为了缩短磁盘读取的时间，计算机做了一些优化：磁盘预读。磁盘预读是基于局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。所以磁盘I/O操作时不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部性原理告诉我们，<strong>当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到</strong>.</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。</p>
<ul>
<li>文件很大，不可能全部存储在内存中，故要存储到磁盘上。</li>
<li>索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因为每次磁盘I/O消耗时间都是非常多的。</li>
<li>局部性原理与磁盘预读，预读的长度一般为页（page）的整倍数。</li>
</ul>
<h3 id="B-B-的查找性能"><a href="#B-B-的查找性能" class="headerlink" title="B-/B+的查找性能"></a>B-/B+的查找性能</h3><p>数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。B-树也利用这一点，每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一次磁盘I/O就读取了一页的数据。下面是B-树的示例图：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309164634.png" alt="image-20210309164634346"></p>
<p>根据B-Tree的定义，可知检索一次最多需要访问h个节点（h个树的高度）。<strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。所以B-Tree作为索引效率是非常高，相比平衡二叉树、红黑树要高很多，</strong>因为这些树的h一般都比较深。</p>
<h3 id="B-树的直观图"><a href="#B-树的直观图" class="headerlink" title="B+树的直观图"></a>B+树的直观图</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309164727.png" alt="image-20210309164727718"></p>
<p>B+树比B-树更加适合作为磁盘的索引数据结构，原因是B+树的内部结点不存储data，内部结点的出度d越大，那么渐进复杂度越小。出度d的上限取决于节点内key和data的大小： <strong>dmax=floor(pagesize/(keysize+datasize+pointsize))</strong></p>
<p>一般3层B+树可以存储上百万的数据，也就是读取上百万的数据，只需要3次磁盘I/O，可见这效率，大大提升了。</p>
<h2 id="不同引擎的索引实现原理"><a href="#不同引擎的索引实现原理" class="headerlink" title="不同引擎的索引实现原理"></a>不同引擎的索引实现原理</h2><h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p>MyISAM的索引采用B+树实现，MyISAM的索引和数据时分开的，叶子节点data存取的是数据的地址，要根据索引找到数据，先根据索引找到叶子节点，再根据叶子节点找到数据的地址，然后再根据数据地址取出数据</p>
<h4 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a>主键索引：</h4><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。<br>下图是MyISAM主键索引的原理图：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309165534.png" alt="image-20210309165534544"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，图myisam1是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。</p>
<h4 id="辅助索引（Secondary-key）"><a href="#辅助索引（Secondary-key）" class="headerlink" title="辅助索引（Secondary key）"></a>辅助索引（Secondary key）</h4><p><strong>在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</strong> 如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309165625.png" alt="image-20210309165625118"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，<strong>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</strong><br>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<ol>
<li><strong>第一个重大区别是InnoDB的数据文件本身就是索引文件。</strong></li>
<li>InnoDB的辅助索引data域存储相应记录主键的值而不是地址。</li>
</ol>
<h4 id="主键索引：-1"><a href="#主键索引：-1" class="headerlink" title="主键索引："></a>主键索引：</h4><p> MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309165746.png" alt="image-20210309165746780"></p>
<p>以上是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做<strong>聚集索引</strong>。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<h4 id="InnoDB的辅助索引"><a href="#InnoDB的辅助索引" class="headerlink" title="InnoDB的辅助索引"></a>InnoDB的辅助索引</h4><p> InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309165824.png" alt="image-20210309165824763"></p>
<p><strong>InnoDB 表是基于聚簇索引建立的</strong>。因此InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列， <strong>所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义很多索引，则争取尽量把主键定义得小一些。</strong> InnoDB 不会压缩索引。</p>
<p>文字符的ASCII码作为比较准则。<strong>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</strong></p>
<p>不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白<strong>为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</strong> 再例如， <strong>用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</strong></p>
<h3 id="InnoDB索引和MyISAM索引的区别："><a href="#InnoDB索引和MyISAM索引的区别：" class="headerlink" title="InnoDB索引和MyISAM索引的区别："></a>InnoDB索引<strong>和</strong>MyISAM索引的区别：</h3><p>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</p>
<p>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</p>
<h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>InnoDB辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录，不建议使用过长的字段作为主键，因为<strong>所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</strong></p>
<p><strong>不建议用非单调的字段作为InnoDB的主键</strong>，因为InnoDB数据文件本身是一颗B+Tree，<strong>非单调的主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，所以一般使用自增字段作为主键。</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的Sql执行流程</title>
    <url>/posts/6b5d697/</url>
    <content><![CDATA[<h2 id="执行流程图"><a href="#执行流程图" class="headerlink" title="执行流程图"></a>执行流程图</h2><p>简易的流程图如下:</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309144801.png" alt="image-20210309144801371"></p>
<p>大致流程描述:</p>
<ol>
<li>MySQL客户端通过协议将SQL语句发送给MySQL服务器。</li>
<li>服务器会先检查查询缓存中是否有执行过这条SQL，如果命中缓存，则将结果返回，否则进入下一个环节（<strong>查询缓存默认不开启</strong>）。</li>
<li>服务器端进行SQL解析，预处理，然后由查询优化器生成对应的执行计划。</li>
<li>服务器根据查询优化器给出的执行计划，再调用存储引擎的API执行查询。</li>
<li>将结果返回给客户端，如果<strong>开启查询缓存，则会备份一份到查询缓存中</strong>。</li>
</ol>
<h2 id="流程图详解"><a href="#流程图详解" class="headerlink" title="流程图详解"></a>流程图详解</h2><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>MySQL查询缓存会保存查询返回的完整结构。当查询命中该缓存时，MySQL会立刻返回结果，跳过了解析、优化和执行阶段。 但查询缓存是默认不开启的，且要求SQL和参数都是一样，同时查询缓存系统会跟踪查询中涉及的每一个表，如果这些表发生变化，则该表相关的所有缓存数据均会失效。所以命中率一般较低，生产环境中也很少用到，</p>
<h3 id="解析和预处理"><a href="#解析和预处理" class="headerlink" title="解析和预处理"></a>解析和预处理</h3><p>如果查询缓存未命中，则到解析器。解析器主要是对SQL语句进行解析，使用MySQLy语法规则进行验证和解析查询，并生成对应的解析树。 得到解析数之后，还需要做预处理，预处理则进一步检查解释树是否合法，以及进行一些优化，比如检查数据表和列是否存在，如果有计算，会将计算的结果算出来等等。</p>
<h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>查询优化器是整个流程中重要的一环。查询优化器会将预处理之后的解析树转化成执行计划。一条查询可以有多种执行方法，最后均会返回相同结果。查询优化器的作用就是找到这其中最好的执行计划。  生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。 通常所讲的优化SQL，其实就是想让查询优化器，按照我们的思路,帮我们选择最优的执行方案。</p>
<h3 id="查询执行计划"><a href="#查询执行计划" class="headerlink" title="查询执行计划"></a>查询执行计划</h3><p>查询执行计划，就是MySQL查询中的执行计划，比如是执行where语句还是from语句，下面有一张执行顺序的图。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309145045.png" alt="image-20210309145045381"></p>
<p>最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。</p>
<ul>
<li><p>FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</p>
</li>
<li><p>ON: 对虚表VT1进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。</p>
</li>
<li><p>JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3， 如果 from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</p>
</li>
<li><p>WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。</p>
</li>
<li><p>GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</p>
</li>
<li><p>CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.</p>
</li>
<li><p>HAVING： 对虚拟表VT6应用having过滤，只有符合的记录才会被 插入到虚拟表VT7中。</p>
</li>
<li><p>SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。</p>
</li>
<li><p>DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9.</p>
</li>
<li><p>ORDER BY: 将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10.</p>
</li>
<li><p>LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。</p>
</li>
</ul>
<h3 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h3><p>执行计划会传给查询执行引擎，执行引擎选择存储引擎来执行计划，到磁盘中的文件中去查询。 影响这个查询性能最根本的原因是什么? 其实是硬盘的机械运动，也就是我们平时熟悉的IO，所以一条查询语句是快还是慢，就是根据这个时间的IO来确定的。那怎么执行IO又是什么来确定的?就是传过来的这一份执行计划.</p>
<p>原文链接：<a href="https://juejin.cn/post/6844903780987715592">https://juejin.cn/post/6844903780987715592</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的多表查询及约束</title>
    <url>/posts/c746dd2d/</url>
    <content><![CDATA[<h2 id="MySQL的约束"><a href="#MySQL的约束" class="headerlink" title="MySQL的约束"></a>MySQL的约束</h2><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><ul>
<li>语法：order by 子句</li>
<li>order by 排序字段1 排序方式1 ，  排序字段2 排序方式2…</li>
<li>排序方式：<ul>
<li>ASC：升序，默认的。</li>
<li>DESC：降序。</li>
</ul>
</li>
<li><strong>如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</strong></li>
</ul>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>将一列数据作为一个整体，进行纵向的计算。</p>
<ul>
<li><strong>count</strong>：计算个数<ul>
<li>一般选择非空的列：主键</li>
<li>count(*)  </li>
</ul>
</li>
<li><strong>max</strong>：计算最大值</li>
<li><strong>min</strong>：计算最小值</li>
<li><strong>sum</strong>：计算和</li>
<li><strong>avg</strong>：计算平均值</li>
</ul>
<blockquote>
<p>聚合函数的计算，<strong>排除null值。</strong></p>
<p><strong>解决方案：</strong></p>
<ol>
<li>选择不包含非空的列进行计算</li>
<li>IFNULL函数</li>
</ol>
</blockquote>
<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>group by 分组字段</p>
<p>employee 表数据</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>gender</th>
<th>hire_date</th>
<th>salary</th>
<th>performance</th>
<th>manage</th>
<th>deparmant</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>张三</td>
<td>男</td>
<td>2/12/1991 00:00:00</td>
<td>2000</td>
<td>200</td>
<td>500</td>
<td>营销部</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>男</td>
<td>5/8/1993 00:00:00</td>
<td>4000</td>
<td>500</td>
<td></td>
<td>营销部</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>女</td>
<td>12/13/1993 00:00:00</td>
<td>1000</td>
<td>100</td>
<td>5000</td>
<td>研发部</td>
</tr>
<tr>
<td>1004</td>
<td>赵六</td>
<td>男</td>
<td>8/19/1996 00:00:00</td>
<td>8000</td>
<td>1000</td>
<td>4000</td>
<td>财务部</td>
</tr>
<tr>
<td>1005</td>
<td>孙七</td>
<td>女</td>
<td>11/6/1997 00:00:00</td>
<td>5000</td>
<td>500</td>
<td></td>
<td>研发部</td>
</tr>
<tr>
<td>1006</td>
<td>周八</td>
<td>男</td>
<td>10/16/1994 00:00:00</td>
<td>6000</td>
<td>2000</td>
<td>1000</td>
<td>人事部</td>
</tr>
<tr>
<td>1007</td>
<td>吴九</td>
<td>女</td>
<td>9/22/1995 00:00:00</td>
<td>8000</td>
<td>1500</td>
<td></td>
<td>研发部</td>
</tr>
<tr>
<td>1008</td>
<td>郑十</td>
<td>女</td>
<td>10/25/1998 00:00:00</td>
<td>4000</td>
<td>900</td>
<td></td>
<td>人事部</td>
</tr>
</tbody></table>
<h4 id="GroupBy-Group-concat"><a href="#GroupBy-Group-concat" class="headerlink" title="GroupBy+Group_concat"></a>GroupBy+Group_concat</h4><p>group by 是分组，是分组，是分组，分组并不是去重，而是分组</p>
<p>将查询结果按一个或多个进行分组，字段值相同的为一组</p>
<p>GroupBy+Group_concat ： 表示分组之后，根据分组结果，使用 group_contact() 来放置每一组的每字段的值的集合</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deparmant, GROUP_CONCAT(`name`) <span class="keyword">from</span> employee <span class="keyword">GROUP</span> <span class="keyword">BY</span> deparmant</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309112830.png" alt="image-20210309112830453"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,gender <span class="keyword">from</span> employee <span class="keyword">GROUP</span> <span class="keyword">BY</span> gender,name</span><br><span class="line"><span class="comment">-- 先按gender分组，再按姓名分组...</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309112918.png" alt="image-20210309112918423"></p>
<h4 id="SQL分组-聚合函数"><a href="#SQL分组-聚合函数" class="headerlink" title="SQL分组+聚合函数"></a>SQL分组+聚合函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deparmant, GROUP_CONCAT(salary), <span class="built_in">SUM</span>(salary),<span class="built_in">AVG</span>(salary) 平均工资,<span class="built_in">MAX</span>(salary) 最高工资 <span class="keyword">from</span> employee <span class="keyword">GROUP</span> <span class="keyword">BY</span> deparmant;</span><br><span class="line"><span class="comment">-- 根据department 分组，计算各部门下工资总数，平均工资，最高工资![1532919789347]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309112957.png" alt="image-20210309112957603"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询每个部门的部门名称以及每个部门的人数</span></span><br><span class="line"><span class="keyword">SELECT</span> deparmant, GROUP_CONCAT(`name`), <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">from</span> employee <span class="keyword">GROUP</span> <span class="keyword">BY</span> deparmant</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309113025.png" alt="image-20210309113025515"></p>
<h4 id="SQL分组GroupBy-Having"><a href="#SQL分组GroupBy-Having" class="headerlink" title="SQL分组GroupBy+Having"></a>SQL分组GroupBy+Having</h4><ul>
<li>group by + having 用来分组查询后指定一些条件来输出查询结果</li>
<li>having 和 where 一样，但 having 只能用于 group by</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资总和大于 9000的部门名称</span></span><br><span class="line"><span class="keyword">SELECT</span> deparmant, GROUP_CONCAT(salary), <span class="built_in">SUM</span>(salary) <span class="keyword">FROM</span> employee </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deparmant </span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(salary) <span class="operator">&gt;</span> <span class="number">9000</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309113103.png" alt="image-20210309113103212"></p>
<h5 id="having-和-where-的区别："><a href="#having-和-where-的区别：" class="headerlink" title="having 和 where 的区别："></a>having 和 where 的区别：</h5><ol>
<li>having 是在分组后对数据进行过滤，where 是在分组前对数据进行过滤</li>
<li>having后面可以使用分组函数(统计函数)，where后面不可以使用分组函数</li>
<li>where 是对分组前记录的条件，如果某行记录没有满足where字句的条件，那么这行记录不会参加分组；而having是对分组后数据的约束</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资大于2000的，工资总和大于9000的部门名称以及工资和</span></span><br><span class="line"><span class="keyword">select</span> deparmant,GROUP_CONCAT(salary), <span class="built_in">SUM</span>(salary) <span class="keyword">from</span> employee </span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">2000</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deparmant </span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">sum</span>(salary) <span class="operator">&gt;</span> <span class="number">9000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">SUM</span>(salary) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309113315.png" alt="image-20210309113315352"></p>
<h3 id="sql语句书写顺序"><a href="#sql语句书写顺序" class="headerlink" title="sql语句书写顺序"></a>sql语句书写顺序</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309113332.png" alt="image-20210309113332101"></p>
<h2 id="MySQL的多表查询"><a href="#MySQL的多表查询" class="headerlink" title="MySQL的多表查询"></a>MySQL的多表查询</h2><h3 id="准备sql"><a href="#准备sql" class="headerlink" title="准备sql"></a>准备sql</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建部门表</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept (NAME) <span class="keyword">VALUES</span> (<span class="string">&#x27;开发部&#x27;</span>),(<span class="string">&#x27;市场部&#x27;</span>),(<span class="string">&#x27;财务部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 创建员工表</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">	gender <span class="type">CHAR</span>(<span class="number">1</span>), <span class="comment">-- 性别</span></span><br><span class="line">	salary <span class="keyword">DOUBLE</span>, <span class="comment">-- 工资</span></span><br><span class="line">	join_date <span class="type">DATE</span>, <span class="comment">-- 入职日期</span></span><br><span class="line">	dept_id <span class="type">INT</span>,</span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY (dept_id) <span class="keyword">REFERENCES</span> dept(id) <span class="comment">-- 外键，关联部门表(部门表的主键)</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">7200</span>,<span class="string">&#x27;2013-02-24&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">&#x27;猪八戒&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">3600</span>,<span class="string">&#x27;2010-12-02&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">&#x27;唐僧&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">9000</span>,<span class="string">&#x27;2008-08-08&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">&#x27;白骨精&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">5000</span>,<span class="string">&#x27;2015-10-07&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">&#x27;蜘蛛精&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">4500</span>,<span class="string">&#x27;2011-03-14&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h4><h5 id="隐式内连接"><a href="#隐式内连接" class="headerlink" title="隐式内连接"></a>隐式内连接</h5><p> 使用where条件消除无用数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有员工信息和对应的部门信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;</span><br><span class="line">			</span><br><span class="line"><span class="comment">-- 查询员工表的名称，性别。部门表的名称</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.name,emp.gender,dept.name <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;</span><br><span class="line">			</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">t1.name, <span class="comment">-- 员工表的姓名</span></span><br><span class="line">t1.gender,<span class="comment">-- 员工表的性别</span></span><br><span class="line">t2.name <span class="comment">-- 部门表的名称</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp t1,</span><br><span class="line">dept t2</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">t1.`dept_id` <span class="operator">=</span> t2.`id`;</span><br></pre></td></tr></table></figure>

<h5 id="显式内连接"><a href="#显式内连接" class="headerlink" title="显式内连接"></a>显式内连接</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;	</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;	</span><br></pre></td></tr></table></figure>



<h4 id="外链接查询"><a href="#外链接查询" class="headerlink" title="外链接查询"></a>外链接查询</h4><h5 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h5><p>左向外联接的结果集包括 LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；</span></span><br></pre></td></tr></table></figure>

<p>查询的是左表所有数据以及其交集部分。</p>
<blockquote>
<p>效果: 内连接查询与多表联合查询的效果是一样的.</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称</span></span><br><span class="line"><span class="keyword">SELECT</span> 	t1.<span class="operator">*</span>,t2.`name` <span class="keyword">FROM</span> emp t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept t2 <span class="keyword">ON</span> t1.`dept_id` <span class="operator">=</span> t2.`id`;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309115012.png" alt="image-20210309115012503"></p>
<h5 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h5><p>右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；</span></span><br></pre></td></tr></table></figure>

<p>查询的是右表所有数据以及其交集部分。</p>
<blockquote>
<p>效果:人员表中的数据全部都显示,而 部门表中的数据符合条件的才会显示,不符合条件的会以 null 进行填充.</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept t2 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> emp t1 <span class="keyword">ON</span> t1.`dept_id` <span class="operator">=</span> t2.`id`; </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309114953.png" alt="image-20210309114953597"></p>
<h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p>查询中嵌套查询，称嵌套查询为子查询。    </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工信息</span></span><br><span class="line"><span class="comment">--  1 查询最高的工资是多少 9000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">--  2 查询员工信息，并且工资等于9000的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`salary` <span class="operator">=</span> <span class="number">9000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用子查询</span></span><br><span class="line"><span class="comment">-- 一条sql就完成这个操作。子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`salary` <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure>

<h5 id="子查询不同情况"><a href="#子查询不同情况" class="headerlink" title="子查询不同情况"></a>子查询不同情况</h5><h6 id="子查询的结果是单行单列的"><a href="#子查询的结果是单行单列的" class="headerlink" title="子查询的结果是单行单列的"></a>子查询的结果是单行单列的</h6><ul>
<li><p>子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =</p>
</li>
<li><p>查询员工工资小于平均工资的人</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.salary <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="子查询的结果是多行单列"><a href="#子查询的结果是多行单列" class="headerlink" title="子查询的结果是多行单列"></a>子查询的结果是多行单列</h6><ul>
<li><p>查询可以作为条件，使用运算符in来判断</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询&#x27;财务部&#x27;和&#x27;市场部&#x27;所有的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">OR</span> NAME <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">OR</span> dept_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">--- 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">OR</span> NAME <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="查询的结果是多行多列的"><a href="#查询的结果是多行多列的" class="headerlink" title="查询的结果是多行多列的"></a>查询的结果是多行多列的</h6><p>子查询可以作为一张虚拟表参与查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息</span></span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept t1 ,(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`join_date` <span class="operator">&gt;</span> <span class="string">&#x27;2011-11-11&#x27;</span>) t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t2.dept_id;</span><br><span class="line"><span class="comment">-- 普通内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp t1,dept t2 <span class="keyword">WHERE</span> t1.`dept_id` <span class="operator">=</span> t2.`id` <span class="keyword">AND</span> t1.`join_date` <span class="operator">&gt;</span>  <span class="string">&#x27;2011-11-11&#x27;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper集群简单介绍</title>
    <url>/posts/5af4d7fe/</url>
    <content><![CDATA[<p><a href="https://zookeeper.apache.org/doc/r3.6.2/zookeeperOver.html">官方文档地址</a></p>
<h1 id="Zookeeper介绍"><a href="#Zookeeper介绍" class="headerlink" title="Zookeeper介绍"></a>Zookeeper介绍</h1><p>ZooKeeper是一个<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/19276232">分布式</a>的，开放源码的<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/9854429">分布式应用程序</a>协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<p>ZooKeeper具有<strong>高性能</strong>，<strong>高可用性</strong>，<strong>严格排序的访问</strong>的特性。ZooKeeper的<strong>高性能</strong>意味着它<strong>可以在大型的分布式系统中使用</strong>。<strong>可靠性</strong>方面使它<strong>不会产生单点故障</strong>。<strong>严格的排序</strong>意味着可以<strong>在客户端上实现复杂的同步原语</strong>。</p>
<blockquote>
<p>详细测试对比可看官方文档   ：   <a href="https://zookeeper.apache.org/doc/r3.6.2/zookeeperOver.html">官方文档地址</a></p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210228144326.png" alt="image-20210228144326215"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210228143924.png" alt="image-20210228143924298"></p>
<blockquote>
<p><a href="https://juejin.cn/post/6844903919026438158">Zookeeper顺序一致性的理解</a></p>
</blockquote>
<h1 id="Zookeeper的读写机制"><a href="#Zookeeper的读写机制" class="headerlink" title="Zookeeper的读写机制"></a>Zookeeper的读写机制</h1><ul>
<li>Zookeeper是一个由多个server组成的集群</li>
<li>一个leader，多个follower</li>
<li>每个server保存一份数据副本</li>
<li>全局数据一致</li>
<li>分布式读写</li>
<li>更新请求转发，由<strong>leader实施</strong></li>
</ul>
<h1 id="Zookeeper-的保证"><a href="#Zookeeper-的保证" class="headerlink" title="Zookeeper 的保证"></a><strong>Zookeeper 的保证</strong></h1><ul>
<li><font color=red>更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行</font></li>
<li>数据更新原子性，一次数据更新要么成功，要么失败</li>
<li>全局<strong>唯一数据视图</strong>，client无论连接到哪个server，<strong>数据视图都是一致的</strong></li>
<li>实时性，在一定事件范围内，client能读到最新数据</li>
</ul>
<h1 id="集群中的角色"><a href="#集群中的角色" class="headerlink" title="集群中的角色"></a>集群中的角色</h1><ul>
<li>领导者（leader），负责进行投票的发起和决议，更新系统状态</li>
<li>学习者（learner），包括跟随者（follower）和观察者（observer），follower用于接受客户端请求并想客户端返回结果，在选主过程中参与投票</li>
<li>Observer可以接受客户端连接，将写请求转发给leader，但<strong>observer不参加投票过程</strong>，只同步leader的状态，<font color=red>observer的目的是为了扩展系统，提高读取速度,放大查询能力</font></li>
<li>客户端（client），请求发起方</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302102953.png" alt="183233-20160316222444771-1363762533"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302103007.jpg"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303103255.png" alt="节点间连接模式"></p>
<ul>
<li>　　Zookeeper的核心<strong>是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。</strong>当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</li>
</ul>
<ul>
<li>　为了保证事务的顺序一致性<strong>，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid</strong>。<strong>实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</strong></li>
</ul>
<p><strong>每个Server在工作过程中有三种状态：</strong></p>
<ul>
<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>
<li>LEADING：当前Server即为选举出来的leader</li>
<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>
</ul>
<p><strong>Follower主要有四个功能</strong></p>
<ol>
<li>向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</li>
<li>接收Leader消息并进行处理；</li>
<li>接收Client的请求，如果为写请求，发送给Leader进行投票；</li>
<li>返回Client结果。</li>
</ol>
<p><strong>Follower的消息循环处理如下几种来自Leader的消息：</strong></p>
<ol>
<li>PING消息： 心跳消息；</li>
<li>PROPOSAL消息：Leader发起的提案，要求Follower投票；</li>
<li>COMMIT消息：服务器端最新一次提案的信息；</li>
<li>UPTODATE消息：表明同步完成；</li>
<li>.REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</li>
<li>SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</li>
</ol>
<p>其他文档：<a href="http://www.cnblogs.com/lpshou/archive/2013/06/14/3136738.html">http://www.cnblogs.com/lpshou/archive/2013/06/14/3136738.html</a></p>
<h1 id="Zookeeper中节点的状态信息各字段含义"><a href="#Zookeeper中节点的状态信息各字段含义" class="headerlink" title="Zookeeper中节点的状态信息各字段含义"></a>Zookeeper中节点的状态信息各字段含义</h1><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302100241.png" alt="image-20210302100241394"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stat</span> <span class="keyword">implements</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> czxid; <span class="comment">// 该数据节点被创建时的事务id</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> mzxid; <span class="comment">// 该数据节点被修改时最新的事务id（集群中会不一样）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> ctime; <span class="comment">// 该数据节点创建时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> mtime; <span class="comment">// 该数据节点最后修改时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> version; <span class="comment">// 当前节点版本号（可以理解为修改次数，每修改一次值+1）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> cversion;<span class="comment">// 子节点版本号（子节点修改次数，每修改一次值+1）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> aversion; <span class="comment">// 当前节点acl版本号（acl节点被修改次数，每修改一次值+1）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> ephemeralOwner; <span class="comment">// 临时节点标示，当前节点如果是临时节点，则存储的创建者的会话id（sessionId），如果不是，那么值=0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> dataLength;<span class="comment">// 当前节点数据长度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> numChildren; <span class="comment">// 当前节点子节点个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> pzxid; <span class="comment">// 当前节点的父级节点事务ID</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Stat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color=red>其中zxid表示的是zookeeper的事务ID，由64位数字组成，分为高32位和低32位</font></strong></p>
<p><strong>高32位</strong>：Epoch周期数，值为最新的领导的对应的id，其实就是就是一个递增的数字</p>
<p><strong>低32位</strong>：计数器，一个递增的计数器，当处理了一个事务，值+1</p>
<p>zxid生成的规则：ZxidUtils.makeZxid</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZxidUtils</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getEpochFromZxid</span><span class="params">(<span class="keyword">long</span> zxid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zxid &gt;&gt; <span class="number">32L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getCounterFromZxid</span><span class="params">(<span class="keyword">long</span> zxid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zxid &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">makeZxid</span><span class="params">(<span class="keyword">long</span> epoch, <span class="keyword">long</span> counter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (epoch &lt;&lt; <span class="number">32L</span>) | (counter &amp; <span class="number">0xffffffffL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">zxidToString</span><span class="params">(<span class="keyword">long</span> zxid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Long.toHexString(zxid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Zookeeper节点数据操作流程"><a href="#Zookeeper节点数据操作流程" class="headerlink" title="Zookeeper节点数据操作流程"></a>Zookeeper节点数据操作流程</h1><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302103739.png" alt="183233-20160316223234865-1124736424"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303103735.png"></p>
<p><strong>详细说明</strong></p>
<ol>
<li>在Client向Follwer发出一个写的请求</li>
<li>Follwer把请求发送给Leader</li>
<li>Leader接收到以后开始发起投票并通知Follwer进行投票</li>
<li>Follwer把投票结果发送给Leader</li>
<li>Leader将结果汇总后如果需要写入，则开始写入同时把写入操作通知给Leader然后commit;</li>
<li>Follwer把请求结果返回给Client</li>
</ol>
<h1 id="Zookeeper集群的两种运行状态"><a href="#Zookeeper集群的两种运行状态" class="headerlink" title="Zookeeper集群的两种运行状态"></a>Zookeeper集群的两种运行状态</h1><h2 id="leader可用状态"><a href="#leader可用状态" class="headerlink" title="leader可用状态"></a>leader可用状态</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210228144112.png" alt="image-20210228144111968"></p>
<h2 id="leader不可用状态"><a href="#leader不可用状态" class="headerlink" title="leader不可用状态"></a>leader不可用状态</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210228144131.png" alt="image-20210228144131837"></p>
<p>不可用状态恢复到可用状态根据官方测试<font color=red>小于200ms</font></p>
<h1 id="Zookeeper的集群选举"><a href="#Zookeeper的集群选举" class="headerlink" title="Zookeeper的集群选举"></a>Zookeeper的集群选举</h1><p>Leader选举是ZooKeeper中最重要的技术之一，也是保证分布式数据一致性的关键所在。</p>
<p> <a href="https://blog.csdn.net/qq_39554452/article/details/109988266">zookeeper集群搭建及选举模式</a></p>
<h2 id="服务器启动时期的选举"><a href="#服务器启动时期的选举" class="headerlink" title="服务器启动时期的选举"></a>服务器启动时期的选举</h2><h3 id="服务器启动时期的Leader选举"><a href="#服务器启动时期的Leader选举" class="headerlink" title="服务器启动时期的Leader选举"></a>服务器启动时期的Leader选举</h3><p> Leader选举的时候，需要注意的是，<strong>隐式条件便是ZooKeeper的集群规模至少是2台机器</strong>，这里我们以3台机器组成的服务器集群为例。在服务器集群初始化阶段，当有一台服务器(我们假设这台机器的myid为1，因此称其为Server1)启动的时候，它是无法完成Leader选举的。当第二胎机器(同样，我们假设这台服务器的myid是2，称其为Server2)也启动后，此时这两台机器已经能够进行互相通信，每台机器都试图找到一个Leader，于是便进入了Leader选举流程。</p>
<ol>
<li><p>每个Server会发出一个投票，由于是初始情况，因此对于Server1和Server2来说，都会将自己作为Leader服务器来进行投票，每次投票包含最基本的元素有：所推举的服务器的myid和ZXID，我们以(myid,ZXID)的形式来表示。因为是初始化阶段，因此无论是Server1还是Server2,都会投给自己，即Server1的投票为(1,0),Server2的投票为(2,0),然后各自将这个投票发给集群中其他所有机器。</p>
</li>
<li><p>接收来自各个服务器的投票，每个服务器都会接收来自其他服务器的投票。集群中的每个服务器在接收到投票后，首先会判断该投票的有效性，包括检查是否是本轮投票，是否来自LOOKING状态的服务器。</p>
</li>
<li><p>处理投票，在接收到来自其他服务器的投票后，针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK的<strong>步骤及处理流程</strong>如下：</p>
<ol>
<li><p>==统计投票==，每次投票后，服务器都会统计所有投票，判断是否已经有过半的及其接收到相同的投票信息。对于Server1和Server2服务器来说，都统计出集群中已经有两台机器接受了(2,0)这个投票信息。这里我们需要对“过半”的概念做一个简单的介绍。所有“过半”就是指大于集群机器数量的一半，即大于或等于(n/2+1)。对于这里由3台机器构成的集群，大于等于2台即为达到“过半”要求。，当<strong>选举票数机器相同</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优先检查ZXID，ZXID比较大的服务器优先作为Leader</span><br><span class="line"></span><br><span class="line">如果ZXID相同的话，那么就比较myid。myid比较大的服务器作为Leader服务器</span><br></pre></td></tr></table></figure>
</li>
<li><p>==改变服务器状态==，一旦确定Leader，每个服务器就会更新自己的状态。如果是Follower，那么就变更为FOLLOWING，如果是Leader，那么就变更为LEADING。</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210303103925.png"></p>
</li>
</ol>
</li>
</ol>
<h3 id="服务器运行时期的Leader选举"><a href="#服务器运行时期的Leader选举" class="headerlink" title="服务器运行时期的Leader选举"></a>服务器运行时期的Leader选举</h3><p>在Zookeeper集群正常运行过程中，<strong>一旦选出一个Leader，那么所有服务器的集群角色一般不会再发生变化</strong>，也就是说，Leader服务器将一直作为集群的Leader，<strong>即使集群中有非Leader挂了或有新机器加入集群也不会影响Leader</strong>。但是<strong>一旦Leader所在机器挂了，那么整个集群将暂时无法对外提供服务，而是进入新一轮的Leader选举</strong>。服务器运行期间的Leader选举和启动时期的Leader选举基本过程一致的。</p>
<h1 id="ZooKeeper的Watch"><a href="#ZooKeeper的Watch" class="headerlink" title="ZooKeeper的Watch"></a>ZooKeeper的Watch</h1><p>  Zookeeper提供了数据的发布/订阅功能，多个订阅者可同时监听某一特定主题对象，当该主题对象的自身状态发生变化时(例如节点内容改变、节点下的子节点列表改变等)，会实时、主动通知所有订阅者。</p>
<p>  Zookeeper采用了Watcher机制实现数据的发布/订阅功能。该机制在被订阅对象发生变化时会异步通知客户端，因此客户端不必在Watcher注册后轮询阻塞，从而减轻了客户端压力。</p>
<blockquote>
<p>Watcher机制实际上<strong>与观察者模式类似</strong>，也可看作是一种观察者模式在分布式场景下的实现方式。</p>
</blockquote>
<h2 id="watcher架构"><a href="#watcher架构" class="headerlink" title="watcher架构"></a>watcher架构</h2><p>Watcher实现由三个部分组成：</p>
<ul>
<li>Zookeeper服务端；</li>
<li>Zookeeper客户端；</li>
<li>客户端的ZKWatchManager对象；</li>
</ul>
<p>客户端首先将Watcher注册到服务端，同时将Watcher对象保存到客户端的Watch管理器中。当ZooKeeper服务端监听的数据状态发生变化时，服务端会主动通知客户端，接着客户端的Watch管理器会触发相关Watcher来回调相应处理逻辑，从而完成整体的数据发布/订阅流程。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303104435.png" alt="image-20210303104435501"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303104900.webp" alt="img"></p>
<p>此时小红旗是一个watcher，当小红旗被创建并注册到node1节点(会有相应的API实现)后，就会监听node1+node_a+node_b或node_a+node_b。这里两种情况是因为在创建watcher注册时会有多种途径。并且watcher不能监听到孙节点。注意注意注意，watcher设置后，一旦触发一次后就会失效，如果要想一直监听，需要在process回调函数里重新注册相同的 <strong>watcher</strong>。</p>
<h2 id="Watcher特性"><a href="#Watcher特性" class="headerlink" title="Watcher特性"></a>Watcher特性</h2><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>一次性</td>
<td>Watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册</td>
</tr>
<tr>
<td>客户端顺序回调</td>
<td>Watcher回调是顺序串行化执行的，只有回调后客户端才能看到最新的数据状态。一个Watcher回调逻辑不应该太多，以免影响别的watcher执行</td>
</tr>
<tr>
<td>轻量级</td>
<td>WatchEvent是最小的通信单元，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容；</td>
</tr>
<tr>
<td>时效性</td>
<td>Watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，则watcher依然存在，仍可接收到通知；</td>
</tr>
</tbody></table>
<h1 id="Zookeeper顺序一致性简单验证"><a href="#Zookeeper顺序一致性简单验证" class="headerlink" title="Zookeeper顺序一致性简单验证"></a>Zookeeper顺序一致性简单验证</h1><ol>
<li><p>启动三个1，2，3三个节点(共四个节点)，三个节点已经可以选举出leader</p>
<p> <code>./bin/zkServer.sh start-foreground</code></p>
<p> <strong>节点1日志</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302121105.png" alt="image-20210302121105538"></p>
<p> <strong>节点2日志</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302121316.png" alt="image-20210302121316291"></p>
<p> <strong>节点3日志</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302123647.png" alt="image-20210302123647739"></p>
</li>
<li><p>启动节点4</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302124033.png"></p>
</li>
<li><p>连接3，4节点并新增数据，会发现cZxid会自增</p>
<p> <code>./bin/zkCli.sh -server 127.0.0.1:12183</code></p>
<p> <code>./bin/zkCli.sh -server 127.0.0.1:12184</code></p>
<p> <code>create -s /ooxx/xxx</code></p>
<p> <code>get -s /ooxx/xxx</code></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302124819.png" alt="image-20210302124819564"></p>
<p> 当进行修改时，会自动在mzxid（该数据节点被修改时最新的事务id）字段加1</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302125027.png" alt="image-20210302125027621"></p>
<p> 4.在此时中断leader进程，并在4节点继续新增相关数据</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302130145.png"></p>
<p> <strong>mZxid前两次（剩余2个following节点）事务是进行了数据同步，第三次事务才是修改/ooxx节点数据</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302130252.png" alt="image-20210302130252033"></p>
<p> 5.不同客户端创建同一个节点</p>
<p> <strong>leader会在此节点进行递增，不会覆盖创建</strong>，规避数据被覆盖</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302130554.png" alt="image-20210302130554281"></p>
</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302130614.png" alt="image-20210302130614931"></p>
<p>当删除节点重新创建，但是数据名会继续递增（leade内部维护）</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302130920.png" alt="image-20210302130920351"></p>
<h1 id="Zookeeper的应用场景"><a href="#Zookeeper的应用场景" class="headerlink" title="Zookeeper的应用场景"></a>Zookeeper的应用场景</h1><ol>
<li>统一的配置管理  ————节点下可以存储1M的数据</li>
<li>分组管理              ————–Zookeeper的树结构，可以有多个节点</li>
<li>统一命名              ————-顺序一致性的能力（不会覆盖数据）</li>
<li>分布式同步          ————-临时节点<ul>
<li>分布式锁   ———临时节点下放置分布式锁（session挂掉自动消失，就会释放锁）</li>
<li>带事务(队列形式)的公平锁   ————–在持久的父节点下，建立多个同级同名(create -s  会自动的添加序列)的临时节点（可以持有多把锁），后面的锁盯住前面的锁（01-02-03）</li>
<li>HA,选主（hadoop）</li>
</ul>
</li>
<li>发布订阅</li>
</ol>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 的击穿，穿透，雪崩，分布式锁，缓存一致性</title>
    <url>/posts/8f6adc3b/</url>
    <content><![CDATA[<h5 id="1-Redis-的击穿，穿透，雪崩"><a href="#1-Redis-的击穿，穿透，雪崩" class="headerlink" title="1. Redis 的击穿，穿透，雪崩"></a>1. Redis 的击穿，穿透，雪崩</h5><h6 id="1-1-Redis-击穿"><a href="#1-1-Redis-击穿" class="headerlink" title="1.1 Redis 击穿"></a>1.1 Redis 击穿</h6><p><strong>产生原因</strong>：在高并发的情况下，在某一时间点，<strong>在高频获取的key在此时过期，大量请求直接请求到服务器上</strong>，导致缓存击穿</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>可以将<strong>热点数据设置为永远不过期</strong>；</p>
</li>
<li><p>基于 <strong>redis</strong> or <strong>zookeeper</strong> 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p>
<blockquote>
<p>redis的分布式锁主要是通过  setnx 命令，设置锁的过期时间，只有返回是ok的才能去数据库中获取数据</p>
<p><strong>产生问题</strong>：在db端超时导致锁过期 </p>
<p><strong>解决方案</strong>： 通过<strong>zookeeper</strong> 实现分布式锁</p>
</blockquote>
</li>
</ul>
<h6 id="1-2-Redis穿透"><a href="#1-2-Redis穿透" class="headerlink" title="1.2 Redis穿透"></a>1.2 Redis穿透</h6><p>  一般是出现这种情况是因为恶意频繁查询才会对系统造成很大的问题: <strong>key缓存并且数据库不存在</strong>，所以<strong>每次查询都会查询数据库从而导致数据库崩溃</strong>。</p>
<p><strong>解决方案：</strong>使用布隆过滤器</p>
<blockquote>
<p>布隆过滤器缺点：只能增加不能删除</p>
<p>可使用布谷鸟过滤器 ，设置空key</p>
</blockquote>
<h6 id="1-3-Redis雪崩"><a href="#1-3-Redis雪崩" class="headerlink" title="1.3 Redis雪崩"></a>1.3 Redis雪崩</h6><p>雪崩指的是<strong>多个key</strong>查询并且出现<strong>高并发</strong>，缓存中失效或者查不到，然后都去db查询，从而导致db压力突然飙升，从而崩溃。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p> 时点性无关:<strong>均匀的设计过期时间</strong></p>
</li>
<li><p>时点性有关:<strong>强依赖击穿的方案</strong></p>
<p>​                    也可在<strong>程序设计的时候在业务层进行时点进行请求延时操作</strong></p>
<p>​                    当知道<strong>时点之后的数据也可以进行预加载工作</strong></p>
</li>
<li><p>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</p>
</li>
<li><p> 事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</p>
</li>
<li><p>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</p>
<blockquote>
<p>时点性有关指<strong>某一个时间段某些key必须要过期使用新数据</strong></p>
</blockquote>
</li>
</ul>
<h5 id="2-Redis-的分布式锁实现"><a href="#2-Redis-的分布式锁实现" class="headerlink" title="2. Redis  的分布式锁实现"></a>2. Redis  的分布式锁实现</h5><p>最好是使用zookeeper实现分布式锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原理需要三个关键元素</span><br><span class="line">1. setnx</span><br><span class="line">2.过期时间</span><br><span class="line">3.多线程（守护进程），延长过期</span><br></pre></td></tr></table></figure>

<h6 id="2-1-Redis加锁实现"><a href="#2-1-Redis加锁实现" class="headerlink" title="2.1 Redis加锁实现"></a>2.1 Redis加锁实现</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">&quot;NX&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">&quot;PX&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-redis-解锁代码"><a href="#2-2-redis-解锁代码" class="headerlink" title="2.2 redis 解锁代码"></a>2.2 redis 解锁代码</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Redis的弊端"><a href="#Redis的弊端" class="headerlink" title="Redis的弊端"></a>Redis的弊端</h6><ul>
<li>数据库事务超时，导致锁过期</li>
<li><code>redis cluster</code>集群环境下，假如现在<code>A客户端</code>想要加锁，它会根据路由规则选择一台<code>master</code>节点写入<code>key</code> <code>mylock</code>，在加锁成功后，<code>master</code>节点会把<code>key</code>异步复制给对应的<code>slave</code>节点。如果此时<code>redis master</code>节点宕机，为保证集群可用性，会进行<code>主备切换</code>，<code>slave</code>变为了<code>redis master</code>。<code>B客户端</code>在新的<code>master</code>节点上加锁成功，而<code>A客户端</code>也以为自己还是成功加了锁的。此时就会导致同一时间内多个客户端对一个分布式锁完成了加锁，导致各种脏数据的产生。</li>
</ul>
<h5 id="Redis-缓存一致性"><a href="#Redis-缓存一致性" class="headerlink" title="Redis 缓存一致性"></a>Redis 缓存一致性</h5><h6 id="出现场景"><a href="#出现场景" class="headerlink" title="出现场景"></a>出现场景</h6><p>在<strong>高并发的情况</strong>下涉及到数据更新：数据库和缓存更新，就容易出现<strong>缓存(Redis)和数据库（MySQL）间的数据一致性问题</strong>。</p>
<p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：</p>
<p>1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p>
<p>2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p>
<p>因为<strong>写和读是并发</strong>的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。</p>
<h6 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h6><p><strong>1.第一种方案：采用延时双删策略</strong></p>
<p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line"> redis.delKey(key);</span><br><span class="line"> db.updateData(data);</span><br><span class="line"> Thread.sleep(<span class="number">500</span>);</span><br><span class="line"> redis.delKey(key);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体的步骤就是：</strong></p>
<ul>
<li>先删除缓存；</li>
<li>再写数据库；</li>
<li>休眠500毫秒；</li>
<li>再次删除缓存</li>
</ul>
<p><strong>该方案的弊端</strong></p>
<p>结合<strong>双删策略+缓存超时设置</strong>，这样<strong>最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</strong></p>
<p><strong>2、第二种方案：异步更新缓存(基于订阅binlog的同步机制)</strong></p>
<p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p>
<ul>
<li><strong>读Redis</strong>：热数据基本都在Redis</li>
<li><strong>写MySQL</strong>:增删改都是操作MySQL</li>
<li><strong>更新Redis数据</strong>：MySQ的数据操作binlog，来更新到Redis</li>
</ul>
<p><strong>1）数据操作主要分为两大块：</strong></p>
<ul>
<li>一个是全量(将全部数据一次写入到redis)</li>
<li>一个是增量（实时更新）</li>
</ul>
<p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p>
<p><strong>2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</strong></p>
<p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p>
<p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p>
<p><strong>消息推送工具</strong>你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>redis集群</title>
    <url>/posts/b153a32a/</url>
    <content><![CDATA[<h5 id="1-单节点redis的缺陷"><a href="#1-单节点redis的缺陷" class="headerlink" title="1.单节点redis的缺陷"></a>1.单节点redis的缺陷</h5><ul>
<li>单点故障导致服务不可用</li>
<li>redis的容量优先</li>
<li>redis的服务压力</li>
</ul>
<h5 id="2-集群的AKF原则"><a href="#2-集群的AKF原则" class="headerlink" title="2. 集群的AKF原则"></a>2. 集群的AKF原则</h5><p><a href="https://www.cnblogs.com/-wenli/p/13584796.html">AKF原则</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113708.png" alt="image-20210222095931709"></p>
<blockquote>
<p>x轴：全量，镜像</p>
<p>Y轴：业务，功能</p>
<p>Z轴：优先级，逻辑再拆分</p>
</blockquote>
<h6 id="2-1-redis使用AKF原则扩展为集群产生的问题"><a href="#2-1-redis使用AKF原则扩展为集群产生的问题" class="headerlink" title="2.1 redis使用AKF原则扩展为集群产生的问题"></a>2.1 redis使用AKF原则扩展为集群产生的问题</h6><p>通过AKF一变多 ：<strong>数据一致性问题</strong></p>
<blockquote>
<p>X轴：redis的主从复制</p>
<p>y轴：redis的集群</p>
<p>z轴：redis的集群（根据用户需求）</p>
</blockquote>
<p>​                            </p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113717.png" alt="image-20210222102653774"></p>
<h5 id="3-CAP原则"><a href="#3-CAP原则" class="headerlink" title="3. CAP原则"></a>3. CAP原则</h5><p><a href="https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99/5712863?fr=aladdin">CAP原则百科</a></p>
<p>CAP原则又称CAP定理，指的是在一个分布式系统中，<a href="https://baike.baidu.com/item/%E4%B8%80%E8%87%B4%E6%80%A7/9840083">一致性</a>（Consistency）、<a href="https://baike.baidu.com/item/%E5%8F%AF%E7%94%A8%E6%80%A7/109628">可用性</a>（Availability）、<a href="https://baike.baidu.com/item/%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7/23734073">分区容错性</a>（Partition tolerance）。CAP 原则指的是，这三个<a href="https://baike.baidu.com/item/%E8%A6%81%E7%B4%A0/5261200">要素</a>最多只能同时实现两点，不可能三者兼顾。</p>
<h5 id="4-Redis的复制（同步）"><a href="#4-Redis的复制（同步）" class="headerlink" title="4. Redis的复制（同步）"></a>4. Redis的复制（同步）</h5><p><a href="http://redis.cn/topics/replication.html">redis的复制</a></p>
<p>Redis使用默认的<strong>异步复制</strong>，其特点是低延迟和高性能，是绝大多数 Redis 用例的自然复制模式。但是，从 Redis 服务器会异步地确认其从主 Redis 服务器周期接收到的数据量。</p>
<h6 id="4-1-redis复制的重要细节"><a href="#4-1-redis复制的重要细节" class="headerlink" title="4.1. redis复制的重要细节"></a>4.1. redis复制的重要细节</h6><ul>
<li>Redis 使用异步复制，slave 和 master 之间异步地确认处理的数据量</li>
<li>一个 master 可以拥有多个 slave</li>
<li>slave 可以接受其他 slave 的连接。除了多个 slave 可以连接到同一个 master 之外， slave 之间也可以像层叠状的结构（cascading-like structure）连接到其他 slave 。自 Redis 4.0 起，所有的 sub-slave 将会从 master 收到完全一样的复制流。</li>
<li>Redis 复制在 master 侧是非阻塞的。这意味着 master 在一个或多个 slave 进行初次同步或者是部分重同步时，可以继续处理查询请求。</li>
<li>复制在 slave 侧大部分也是非阻塞的。当 slave 进行初次同步时，它可以使用旧数据集处理查询请求，假设你在 redis.conf 中配置了让 Redis 这样做的话。否则，你可以配置如果复制流断开， Redis slave 会返回一个 error 给客户端。但是，在初次同步之后，旧数据集必须被删除，同时加载新的数据集。 slave 在这个短暂的时间窗口内（如果数据集很大，会持续较长时间），会阻塞到来的连接请求。自 Redis 4.0 开始，可以配置 Redis 使删除旧数据集的操作在另一个不同的线程中进行，但是，加载新数据集的操作依然需要在主线程中进行并且会阻塞 slave 。</li>
<li>复制既可以被用在可伸缩性，以便只读查询可以有多个 slave 进行（例如 O(N) 复杂度的慢操作可以被下放到 slave ），或者仅用于数据安全。</li>
<li>可以使用复制来避免 master 将全部数据集写入磁盘造成的开销：一种典型的技术是配置你的 master Redis.conf 以避免对磁盘进行持久化，然后连接一个 slave ，其配置为不定期保存或是启用 AOF。但是，这个设置必须小心处理，因为重新启动的 master 程序将从一个空数据集开始：如果一个 slave 试图与它同步，那么这个 slave 也会被清空。</li>
</ul>
<h6 id="Redis-复制功能的细节过程"><a href="#Redis-复制功能的细节过程" class="headerlink" title="Redis 复制功能的细节过程"></a>Redis 复制功能的细节过程</h6><p>master 开启一个<strong>后台保存进程，以便于生产一个 RDB 文件</strong>。同时它开始缓冲所有从客户端接收到的新的写入命令。当后台保存完成时， master 将数据集文件传输给 slave， slave将之保存在磁盘上，然后加载文件到内存。再然后 master 会发送所有缓冲的命令发给 slave。这个过程以指令流的形式完成并且和 Redis 协议本身的格式相同。</p>
<p>你可以用 telnet 自己进行尝试。在服务器正在做一些工作的同时连接到 Redis 端口并发出 <a href="https://redis.io/commands/sync">SYNC</a> 命令。你将会看到一个批量传输，并且之后每一个 master 接收到的命令都将在 telnet 回话中被重新发出。事实上 SYNC 是一个旧协议，在新的 Redis 实例中已经不再被使用，但是其仍然向后兼容：但它不允许部分重同步，所以现在 <strong>PSYNC</strong> 被用来替代 SYNC。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226145730.png" alt="image-20210226145730728"></p>
<h5 id="5-Redis中哨兵sentinel"><a href="#5-Redis中哨兵sentinel" class="headerlink" title="5. Redis中哨兵sentinel"></a>5. Redis中哨兵sentinel</h5><p><a href="http://redis.cn/topics/sentinel.html">Redis 的 Sentinel 文档</a></p>
<p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p>
<ul>
<li><strong>监控（Monitoring</strong>）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong>： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis Sentinel 是一个<strong>分布式系统</strong>， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用<strong>流言协议（gossip protocols)**来接收关于主服务器是否下线的信息， 并使用</strong>投票协议**（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器</p>
<h6 id="客观下线和主观下线"><a href="#客观下线和主观下线" class="headerlink" title="客观下线和主观下线"></a>客观下线和主观下线</h6><ul>
<li>主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。</li>
<li>客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）</li>
</ul>
<p>客观下线条件<strong>只适用于主服务器</strong>： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。</p>
<p>从主观下线状态切换到客观下线状态并没有使用严格的法定人数算法（strong quorum algorithm）， 而是使用了<strong>流言协议</strong>： 如果 <strong>Sentinel 在给定的时间范围内， 从其他 Sentinel 那里接收到了足够数量的主服务器下线报告， 那么 Sentinel 就会将主服务器的状态从主观下线改变为客观下线</strong>。 如果之后其他 Sentinel 不再报告主服务器已下线， 那么客观下线状态就会被移除。</p>
<h5 id="6-Redis集群"><a href="#6-Redis集群" class="headerlink" title="6.Redis集群"></a>6.Redis集群</h5><p><a href="http://redis.cn/topics/cluster-tutorial.html">redis集群教程</a></p>
<h6 id="Redis集群的拆分方案"><a href="#Redis集群的拆分方案" class="headerlink" title="Redis集群的拆分方案"></a>Redis集群的拆分方案</h6><ul>
<li>数据可以分类，交集不多</li>
<li>数据没办法拆分,用一致性hash算法进行拆分(redis-cluster)</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226152546.png" alt="image-20210226152546200"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226153455.png" alt="image-20210226153454965"></p>
<h6 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h6><p>希算法就是将任意长度的二进制值映射为较短的固定长度的唯一的二进制值(即哈希值)。敲黑板，哈希算法的入参可以是任意长度，而出参是固定长度而且唯一。一致性哈希算法就是，先构造一个0到2^32的整数环(hash环，java中可用SortedMap实现)，根据缓存服务器名称(也可以是ip:port)计算出hash值，根据其hash值将缓存服务器放置在hash环上。每次根据要缓存的key计算得到hash值，在hash环上顺时针查找距离最近的缓存服务器节点(SortedMap.tailMap(key)实现)，进行set/set操作<br><img src="https://gitee.com/CNRF/image/raw/master/img/20210226153659.png" alt="image-20210226153659880"></p>
<p><strong>一致性hash算法的问题</strong></p>
<p>1.加减缓存服务器节点会造成hash环部分数据无法命中；</p>
<p>2.少量缓存服务器节点时，数据分布不均匀，同时缓存服务器节点变化将影响大范围数据;</p>
<p>3.普通的一致性哈希分区需要增加一倍或减掉一半缓存服务器节点才能保持数据负载均衡；</p>
<p>当只有少量缓存服务器又想尽量保证负载均衡时，我们一般采用下面的办法：将一个缓存服务器节点虚拟成一组，比如某台缓存服务器为192.168.2.1:6379，我们就可以将其虚拟成一个虚拟节点数组，为192.168.2.1:6379-1，192.168.2.1:6379-2，192.168.2.1:6379-3……然后分别计算数组里的元素的hash值并映射到hash环上，每台缓存服务器都如此处理。当不同key的缓存路由到虚拟节点时，最终都是指向真实的缓存服务器节点。通过这样增加节点的方式，可以一定概率上使数据路由均衡</p>
<h6 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis-cluster"></a>redis-cluster</h6><p> Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p> 其结构特点：<br> 1、所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。<br> 2、节点的fail是通过集群中超过半数的节点检测失效时才生效。<br> 3、客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。<br> 4、redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value。<br> 5、Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。</p>
<p><strong>a.redis cluster节点分配</strong><br> 现在我们是三个主节点分别是：A, B, C 三个节点，它们可以是一台机器上的三个端口，也可以是三台不同的服务器。那么，采用哈希槽 (hash slot)的方式来分配16384个slot 的话，它们三个节点分别承担的slot 区间是：</p>
<ul>
<li><p>节点A覆盖0－5460;</p>
</li>
<li><p>节点B覆盖5461－10922;</p>
</li>
<li><p>节点C覆盖10923－16383.</p>
<p>  获取数据:<br>   如果存入一个值，按照redis cluster哈希槽的<a href="http://lib.csdn.net/base/datastructure">算法</a>： CRC16(‘key’)384 = 6782。 那么就会把这个key 的存储分配到 B 上了。同样，当我连接(A,B,C)任何一个节点想获取’key’这个key时，也会这样的算法，然后内部跳转到B节点上获取数据</p>
<p>  新增一个主节点:<br>   新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上，我会在接下来的实践中实验。大致就会变成这样：</p>
</li>
<li><p>节点A覆盖1365-5460</p>
</li>
<li><p>节点B覆盖6827-10922</p>
</li>
<li><p>节点C覆盖12288-16383</p>
</li>
<li><p>节点D覆盖0-1364,5461-6826,10923-12287</p>
</li>
</ul>
<p>同样删除一个节点也是类似，移动完成后就可以删除这个节点了。</p>
<p><strong>b.Redis Cluster主从模式</strong><br> redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉</p>
<p>上面那个例子里, 集群有ABC三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了。A和C的slot也无法访问。</p>
<p>所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像这样, 集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。</p>
<p>B1节点替代了B节点，所以Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。</p>
<p>不过需要注意，如果<strong>节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了</strong>。</p>
<h5 id="8-Redis集群的代理"><a href="#8-Redis集群的代理" class="headerlink" title="8.Redis集群的代理"></a>8.Redis集群的代理</h5><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226154729.png" alt="image-20210226154729661"></p>
<p><a href="https://blog.csdn.net/qq_34944535/article/details/106803261?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.control&dist_request_id=46a127bd-e7dd-4660-b485-d998c0726304&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.control">redis cluster代理</a></p>
<p>目前市面上主流的代理包含：predixy、twemproxy、codis、redis-cerberus四款，这四款各有各的优势，我们逐个对比进行对比分析。</p>
<div class="table-box"><table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td><strong>特性</strong></td><td><strong>predixy</strong></td><td><strong>twemproxy</strong></td><td><strong>codis</strong></td><td><strong>redis-cerberus</strong></td></tr><tr><td>高可用</td><td>Redis Sentinel或Redis Cluster</td><td>一致性哈希</td><td>Redis Sentinel</td><td>Redis Cluster</td></tr><tr><td>可扩展</td><td>Key哈希分布或Redis Cluster</td><td>Key哈希分布</td><td>Key哈希分布</td><td>Redis Cluster</td></tr><tr><td>开发语言</td><td>C++</td><td>C</td><td>GO</td><td>C++</td></tr><tr><td>多线程</td><td>是</td><td>否</td><td>是</td><td>是</td></tr><tr><td>事务</td><td>Redis Sentinel模式单Redis组下支持</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>BLPOP/BRPOP/BLPOPRPUSH</td><td>支持</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>Pub/Sub</td><td>支持</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>Script</td><td>支持load</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>Scan</td><td>支持</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>Select DB</td><td>支持</td><td>不支持</td><td>支持</td><td>Redis Cluster只有一个DB</td></tr><tr><td>Auth</td><td>支持定义多个密码，给予不同读写及管理权限和Key访问空间</td><td>不支持</td><td>同redis</td><td>不支持</td></tr><tr><td>读从节点</td><td>支持，可定义丰富规则读指定的从节点</td><td>不支持</td><td>支持，简单规则</td><td>支持，简单规则</td></tr><tr><td>多机房支持</td><td>支持，可定义丰富规则调度流量</td><td>不支持</td><td>有限支持</td><td>有限支持</td></tr><tr><td>统计信息</td><td>丰富</td><td>丰富</td><td>丰富</td><td>简单</td></tr></tbody></table></div>

]]></content>
      <categories>
        <category>Redis</category>
        <category>一致性Hash算法</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>一致性Hash算法</tag>
      </tags>
  </entry>
  <entry>
    <title>redis持久化</title>
    <url>/posts/dcfaa904/</url>
    <content><![CDATA[<h5 id="1-redis的持久化方式"><a href="#1-redis的持久化方式" class="headerlink" title="1. redis的持久化方式"></a>1. redis的持久化方式</h5><ol>
<li><p>RDB持久化</p>
<p> 原理是将<strong>Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化</strong></p>
</li>
<li><p>AOF持久化</p>
<p> 原理是将<strong>Reids的操作日志以追加的方式写入文件</strong></p>
<p> <a href="https://www.cnblogs.com/zxs117/p/11242026.html">两种持久化方式区别</a></p>
<p> 二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。不过生产环境其实更多都是二者结合使用的。</p>
</li>
</ol>
<h5 id="2-RDB持久化"><a href="#2-RDB持久化" class="headerlink" title="2.RDB持久化"></a>2.RDB持久化</h5><p><strong>原理</strong> :在liunx系统系统中，<strong>进程之间的数据是隔离的</strong>，在使用export的环境变量，<strong>父子进程的修改都不会影响到其他进程的数据</strong></p>
<p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是<strong>fork一个子进程</strong>，先将<strong>数据集写入临时文件</strong>，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303093740.png"></p>
<h6 id="2-1-RDB的优缺点"><a href="#2-1-RDB的优缺点" class="headerlink" title="2.1 RDB的优缺点"></a>2.1 RDB的优缺点</h6><p><strong>优点</strong>： </p>
<ol>
<li><strong>还原速度快</strong>（类似java的对象序列化，可快速还原）</li>
<li><strong>整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的</strong>。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li>
</ol>
<p><strong>弊端</strong>：</p>
<ol>
<li>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么<strong>RDB将不是一个很好的选择。因为系统一旦在定时持久化完成之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失</strong>。</li>
<li> 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，<strong>如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</strong></li>
</ol>
<blockquote>
<p>fork命令只是创建进程，并不会在此时进行复制，因此创建进程的速度变快</p>
<p>fork出来的父子进程具有 <strong>相同但是独立的地址空间</strong>因为父进程和子进程是独立的进程，他们都有自己私有的地址空间，当父进程或者子进程单独改变时，不会影响到彼此，类似于c++的写实拷贝的形式自建一个副本</p>
<p><a href="https://blog.csdn.net/weixin_40853073/article/details/81873398?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=4254810a-f10f-43c5-8965-6b775b5a3682&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">fork命令详细说明</a></p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113700.png" alt="image-20210221233300160"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303093910.png" alt="image-20210303093910862"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226151043.png" alt="image-20210226151042967"></p>
<h5 id="3-AOF持久化"><a href="#3-AOF持久化" class="headerlink" title="3. AOF持久化"></a>3. AOF持久化</h5><p>AOF持久化以<strong>日志的形式</strong>记录服务器所处理的<strong>每一个写、删除操作</strong>，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p>
<blockquote>
<p>当redis同时开启RDB和AOF备份，redis恢复是只会依据AOF的备份（AOF的数据丢失较少）</p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113653.png" alt="image-20210221233312115"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226151129.png" alt="image-20210226151129085"></p>
<h6 id="3-1-AOF的优缺点"><a href="#3-1-AOF的优缺点" class="headerlink" title="3.1 AOF的优缺点"></a>3.1 AOF的优缺点</h6><p><strong>优点</strong>：</p>
<p>1). 该机制可以带来<strong>更高的数据安全性，即数据持久性</strong>。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。</p>
<p>2). 由于该机制对日志文件的<strong>写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容</strong>。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以<strong>通过redis-check-aof工具来帮助我们解决数据一致性的问题。</strong></p>
<p>3). 如果<strong>日志过大，Redis可以自动启用rewrite机制</strong>。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</p>
<blockquote>
<p>redis4.0以前：rewrite其实是删除抵消的命令（创建和删除），合并重复的命名。最终会生成重复命令</p>
<p>redis4.0以后：将老的数据RDB到AOF中，将增量的以指令的方式append到aof中（实际就是混合RDB+AOF的持久化方式）</p>
</blockquote>
<p>4). <strong>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建</strong>。</p>
<p><strong>缺点</strong>：</p>
<p>1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。<strong>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</strong></p>
<p>2). 根据同步策略的不同，<strong>AOF在运行效率上往往会慢于RDB</strong>。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的消息订阅，pipeline，事务</title>
    <url>/posts/d09e787/</url>
    <content><![CDATA[<h5 id="1-Redis-管道（Pipelining）"><a href="#1-Redis-管道（Pipelining）" class="headerlink" title="1.Redis 管道（Pipelining）"></a>1.Redis 管道（Pipelining）</h5><p><a href="http://redis.cn/topics/pipelining.html">Redis 管道（Pipelining）</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113641.png" alt="image-20210220103817162"></p>
<p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将<em>多个命令</em>发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
<p><strong>重要说明</strong>: 使用管道发送命令时，服务器将被迫回复一个队列答复，占用很多内存。如果需要发送大量的命令，最好是按照合理数量分批次的处理，例如10K的命令，读回复，然后再发送另一个10k的命令，等等。这样速度几乎是相同的，但是在回复这10k命令队列需要非常大量的内存用来组织返回数据内容。</p>
<h5 id="2-redis的消息订阅"><a href="#2-redis的消息订阅" class="headerlink" title="2. redis的消息订阅"></a>2. redis的消息订阅</h5><p><a href="http://redis.cn/topics/pubsub.html">redis的消息订阅</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303110111.png" alt="redis发布订阅过程"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUBLISH  &#x2F;&#x2F;发布消息</span><br><span class="line">SUBSCRIBE foo bar</span><br><span class="line">SUBSCRIBE  &#x2F;&#x2F;接收指定队列消息</span><br><span class="line">SUBSCRIBE foo</span><br></pre></td></tr></table></figure>

<h5 id="3-redis的事务"><a href="#3-redis的事务" class="headerlink" title="3. redis的事务"></a>3. redis的事务</h5><p><a href="http://redis.cn/topics/transactions.html">redis的事务</a></p>
<p><a href="http://redis.cn/commands/multi.html">MULTI</a> 、 <a href="http://redis.cn/commands/exec.html">EXEC</a> 、 <a href="http://redis.cn/commands/discard.html">DISCARD</a> 和 <a href="http://redis.cn/commands/watch.html">WATCH</a> 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<p><a href="http://redis.cn/commands/exec.html">EXEC</a> 命令负责触发并执行事务中的所有命令：</p>
<ul>
<li><p>如果客户端在使用 <a href="http://redis.cn/commands/multi.html">MULTI</a> 开启了一个事务之后，却因为断线而没有成功执行 <a href="http://redis.cn/commands/exec.html">EXEC</a> ，那么事务中的所有命令都不会被执行。</p>
</li>
<li><p>另一方面，如果客户端成功在开启事务之后执行 <a href="http://redis.cn/commands/exec.html">EXEC</a> ，那么事务中的所有命令都会被执行</p>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210303101618.png"></p>
<blockquote>
<p>开启事务，修改k2 的值，但是<font  color=red>没有进行事务的提交，导致修改不成功</font></p>
</blockquote>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210303102359.png" alt="image-20210303102359486"></p>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210303102525.png"></p>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210303102720.png"></p>
<blockquote>
<p>由于redis是单线程，当<font  color=red>2的事务(exec)先到达，则先回执行2的事务，则事务1无法获取到k1的值</font></p>
<p>当<font  color=red>1的事务(exec)先到达，则先回执行1的事务，则事务1能获取到k1的值</font></p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code> AOF 方式做持久化</code>的时候，Redis 会使用单个 write(2) 命令将事务写入到磁盘中。然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p>
<p>Redis (2.2版本开始)还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作</p>
</blockquote>
<h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><p><a href="http://redis.cn/commands/multi.html">MULTI</a> 命令用于开启一个事务，它总是返回 <code>OK</code> 。 <a href="http://redis.cn/commands/multi.html">MULTI</a> 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 <a href="http://redis.cn/commands/exec.html">EXEC</a>命令被调用时， 所有队列中的命令才会被执行。</p>
<p>另一方面， 通过调用 <a href="http://redis.cn/commands/discard.html">DISCARD</a> ， 客户端可以清空事务队列， 并放弃执行事务。</p>
<p>以下是一个事务例子， 它原子地增加了 <code>foo</code> 和 <code>bar</code> 两个键的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br></pre></td></tr></table></figure>

<p><a href="http://redis.cn/commands/exec.html">EXEC</a> 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。</p>
<p>当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 <code>QUEUED</code> 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行</p>
<h6 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h6><ul>
<li>事务在执行 <a href="http://redis.cn/commands/exec.html">EXEC</a> 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 <code>maxmemory</code> 设置了最大内存限制的话）。</li>
<li>命令可能在 <a href="http://redis.cn/commands/exec.html">EXEC</a> 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。</li>
</ul>
<p>服务器会对命令入队失败的情况进行记录，并在客户端调用 <a href="http://redis.cn/commands/exec.html">EXEC</a> 命令时，<strong>拒绝执行并自动放弃这个事务</strong>。</p>
<h6 id="Redis-不支持回滚（roll-back）原因"><a href="#Redis-不支持回滚（roll-back）原因" class="headerlink" title="Redis 不支持回滚（roll back）原因"></a>Redis 不支持回滚（roll back）原因</h6><ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，<strong>失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中</strong>。</li>
<li>因为<strong>不需要对回滚进行支持</strong>，所以 Redis 的内部可以保持<strong>简单且快速</strong>。</li>
</ul>
<h5 id="4-布隆过滤器"><a href="#4-布隆过滤器" class="headerlink" title="4.布隆过滤器"></a>4.布隆过滤器</h5><p><a href="https://github.com/RedisBloom/RedisBloom">第三方实现的redis的布隆过滤器</a></p>
<h6 id="redis添加过滤器的意义"><a href="#redis添加过滤器的意义" class="headerlink" title="redis添加过滤器的意义"></a>redis添加过滤器的意义</h6><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303094333.png" alt="image-20210303094333858"></p>
<h6 id="redis的布隆过滤器实现"><a href="#redis的布隆过滤器实现" class="headerlink" title="redis的布隆过滤器实现"></a>redis的布隆过滤器实现</h6><ol>
<li>Client自己承载，<strong>实现bloom算法并承载bitmap</strong></li>
<li>Client实现bloom算法，对应redis的bitmap</li>
<li>redis安装bloom插件</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303094514.png" alt="image-20210303094514053"></p>
<blockquote>
<p>第三方实现redis的相关功能： <a href="https://redis.io/modules">https://redis.io/modules</a></p>
</blockquote>
<h5 id="5-redis的LRU（Least-Recently-Used）淘汰策略"><a href="#5-redis的LRU（Least-Recently-Used）淘汰策略" class="headerlink" title="5.redis的LRU（Least Recently Used）淘汰策略"></a>5.redis的LRU（Least Recently Used）淘汰策略</h5><p><a href="http://redis.cn/topics/lru-cache.html">将redis当做使用LRU算法的缓存来使用</a></p>
<p><strong>LRU是Redis唯一支持的回收方法</strong>，Redis的<code>maxmemory</code>指令用于将可用内存限制成一个固定大小，还包括了Redis使用的LRU算法，这个实际上只是近似的LRU。</p>
<p><strong>Redis的LRU算法并非完整的实现</strong>。这意味着<strong>Redis并没办法选择最佳候选来进行回收</strong>，也就是最久未被访问的键。相反它会尝试运行一个近似LRU的算法，<strong>通过对少量keys进行取样，然后回收其中一个最好的key（被访问时间较早的）</strong>。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303094057.png"></p>
<h6 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h6><p>以下的策略是可用的:</p>
<ul>
<li><strong>noeviction</strong>:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</li>
<li><strong>allkeys-lru</strong>: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</li>
<li><strong>volatile-lru</strong>: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</li>
<li><strong>allkeys-random</strong>: 回收随机的键使得新添加的数据有空间存放。</li>
<li><strong>volatile-random</strong>: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li>
<li><strong>volatile-ttl</strong>: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</li>
</ul>
<h6 id="回收进程如何工作"><a href="#回收进程如何工作" class="headerlink" title="回收进程如何工作"></a><strong>回收进程如何工作</strong></h6><p>理解回收进程如何工作是非常重要的:</p>
<ul>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ul>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis快的原因</title>
    <url>/posts/400dad18/</url>
    <content><![CDATA[<h1 id="Liunx的IO"><a href="#Liunx的IO" class="headerlink" title="Liunx的IO"></a>Liunx的IO</h1><h1 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h1><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<br>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303092341.png" alt="image-20210303092341779"></p>
<h1 id="non-blocking-IO"><a href="#non-blocking-IO" class="headerlink" title="non-blocking IO"></a>non-blocking IO</h1><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303093047.png" alt="image-20210303093047688"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303092823.png" alt="image-20210303092823060"></p>
<p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<br>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。</p>
<h1 id="多路复用NIO"><a href="#多路复用NIO" class="headerlink" title="多路复用NIO"></a>多路复用NIO</h1><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303093109.png" alt="image-20210303093109692"></p>
<h3 id="Liunx的IO演变"><a href="#Liunx的IO演变" class="headerlink" title="Liunx的IO演变"></a>Liunx的IO演变</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303093222.png" alt="image-20210303093222430"></p>
<h1 id="Redis中IO"><a href="#Redis中IO" class="headerlink" title="Redis中IO"></a>Redis中IO</h1><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303102906.png" alt="image-20210303102906808"></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>win10添加新建文件md方式以及设置md模版</title>
    <url>/posts/558e0cc4/</url>
    <content><![CDATA[<p><strong><em>务必先创建系统还原点或者备份注册表</em></strong></p>
<h1 id="添加新建方式步骤"><a href="#添加新建方式步骤" class="headerlink" title="添加新建方式步骤"></a>添加新建方式步骤</h1><p>新建<code>temp.txt</code>输入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@&#x3D;&quot;.md&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;&#x3D;&quot;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>把<code>temp.txt</code>改名为<code>temp.reg</code></p>
</li>
<li><p>双击运行，就ok了，有问题记得先重启，如果不行，就采用下面这个</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@&#x3D;&quot;typora.md&quot;</span><br><span class="line">&quot;icon&quot;&#x3D;&quot;E:\\Typora\\bin\\typora.exe&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\OpenWithProgids]</span><br><span class="line">&quot;Typora.md&quot;&#x3D;&quot;&quot;</span><br><span class="line">&quot;VSCode.md&quot;&#x3D;&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;&#x3D;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="配置md文件模版"><a href="#配置md文件模版" class="headerlink" title="配置md文件模版"></a>配置md文件模版</h1><p>1、使用<code>notepad++</code>新建<code>新建 Markdown.md</code>文件，填入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">tags: []</span><br><span class="line">categories:</span><br><span class="line">- []</span><br><span class="line">- []</span><br><span class="line">description: </span><br><span class="line">updated: </span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>将文件移动到不会<strong>轻易删除的文件夹</strong></p>
<p>打开注册表，按如下(没有就创建)</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226105517.png" alt="image-20210226105516945"></p>
]]></content>
      <categories>
        <category>Typora</category>
        <category>Win10</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Win10</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+NexT博客归档/标签/分类页美化</title>
    <url>/posts/be9758cd/</url>
    <content><![CDATA[<p>NexT自带的<code>归档</code>、<code>标签</code>、<code>分类</code>页的样式比较单一，我们可以在样式文件中添加一些<code>css</code>配置来将我们想要的样式添加到这些页面中，本文就来介绍如何添加或修改这些页面的样式。</p>
<h1 id="彩色标签页"><a href="#彩色标签页" class="headerlink" title="彩色标签页"></a>彩色标签页</h1><ol>
<li>在 /themes/next/layout/ 目录下，新增 tag-color.swig 文件，填入如下内容:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">     var alltags &#x3D; document.getElementsByClassName(&#39;tag-cloud-tags&#39;);</span><br><span class="line">     var tags &#x3D; alltags[0].getElementsByTagName(&#39;a&#39;);</span><br><span class="line">     for (var i &#x3D; tags.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">       var r&#x3D;Math.floor(Math.random()*75+130);</span><br><span class="line">       var g&#x3D;Math.floor(Math.random()*75+100);</span><br><span class="line">       var b&#x3D;Math.floor(Math.random()*75+80);</span><br><span class="line">       tags[i].style.background &#x3D; &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    &#x2F;*font-family: Helvetica, Tahoma, Arial;*&#x2F;</span><br><span class="line">    &#x2F;*font-weight: 100;*&#x2F;</span><br><span class="line">    text-align: center;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a&#123;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin: 8px 5px 0px 0px;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a:before&#123;</span><br><span class="line">    content: &quot;🔖&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags a:hover&#123;</span><br><span class="line">     box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4);</span><br><span class="line">     transform: scale(1.1);</span><br><span class="line">     &#x2F;*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*&#x2F;</span><br><span class="line">     transition-duration: 0.15s;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在同级目录的 page.swig 中引入 tag-color.swig</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tag-cloud&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 目前共计xxx个标签</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tag-cloud-title&quot;</span>&gt;</span><br><span class="line">            &#123;&#123; _p(<span class="string">&#x27;counter.tag_cloud&#x27;</span>, site.tags.length) &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        --&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tag-cloud-tags&quot;</span>&gt;</span><br><span class="line">          &#123;&#123; tagcloud(&#123;<span class="attr">min_font</span>: <span class="number">10</span>, <span class="attr">max_font</span>: <span class="number">15</span>, <span class="attr">amount</span>: <span class="number">300</span>, <span class="attr">color</span>: <span class="literal">true</span>, <span class="attr">start_color</span>: <span class="string">&#x27;#ccc&#x27;</span>, <span class="attr">end_color</span>: <span class="string">&#x27;#111&#x27;</span>&#125;) &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">+     &#123;% include <span class="string">&#x27;tag-color.swig&#x27;</span> %&#125;</span><br><span class="line">    </span><br><span class="line">    &#123;% elif page.type === <span class="string">&#x27;categories&#x27;</span> %&#125;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;category-all-page&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;category-all-title&quot;</span>&gt;</span><br><span class="line">            &#123;&#123; _p(<span class="string">&#x27;counter.categories&#x27;</span>, site.categories.length) &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;category-all&quot;</span>&gt;</span><br><span class="line">          &#123;&#123; list_categories() &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>以下是文章底部的标签样式（代码拷入 /themes/next/source/css/_schemes/(自己选择的主题)/index.styl 即可）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*文章底部标签样式*&#x2F;</span><br><span class="line">.posts-expand .post-tags a &#123;</span><br><span class="line">  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, .12), 0 1px 2px rgba(0, 0, 0, .24);</span><br><span class="line">  -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, .12), 0 1px 2px rgba(0, 0, 0, .24);</span><br><span class="line">  box-shadow: 0 1px 3px rgba(0, 0, 0, .12), 0 1px 2px rgba(0, 0, 0, .24);</span><br><span class="line">  font-family: &#39;Comic Sans MS&#39;, sans-serif;</span><br><span class="line">  transition: .2s ease-out;</span><br><span class="line">  padding: 3px 5px;</span><br><span class="line">  margin: 5px;</span><br><span class="line">  background: #f5f5f5;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-radius: 15px;</span><br><span class="line"></span><br><span class="line">  +mobile()&#123;</span><br><span class="line">    padding: 1px 3px;</span><br><span class="line">    font-size: 8px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    background: rgba(100,154,182,0.902);</span><br><span class="line">    color: #fff;</span><br><span class="line">    -webkit-box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);</span><br><span class="line">    -moz-box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);</span><br><span class="line">    box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226130811.png" alt="image-20210226130811067"></p>
<h1 id="归档页美化"><a href="#归档页美化" class="headerlink" title="归档页美化"></a>归档页美化</h1><ol>
<li>修改 /themes/next/ layout/_ macro/post collapse.swig 后的代码如下:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% macro render(posts) %&#125;</span><br><span class="line">&#123;%- set current_year &#x3D; &#39;1970&#39; %&#125;</span><br><span class="line">&#123;%- for post in posts.toArray() %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- set year &#x3D; date(post.date, &#39;YYYY&#39;) %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- if year !&#x3D;&#x3D; current_year %&#125;</span><br><span class="line">    &#123;%- set current_year &#x3D; year %&#125;</span><br><span class="line">    &lt;div class&#x3D;&quot;collection-year&quot;&gt;</span><br><span class="line">      &lt;&#123;%- if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;%- endif %&#125; class&#x3D;&quot;collection-header&quot;&gt;&#123;&#123; current_year &#125;&#125;&lt;&#x2F;&#123;%- if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;%- endif %&#125;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;article class&#x3D;&quot;my-post post-type-&#123;&#123; post.type | default(&#39;normal&#39;) &#125;&#125;&quot; itemscope itemtype&#x3D;&quot;http:&#x2F;&#x2F;schema.org&#x2F;Article&quot;&gt;</span><br><span class="line">    &lt;header class&#x3D;&quot;my-post-header&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div class&#x3D;&quot;my-post-meta&quot;&gt;</span><br><span class="line">        &lt;time class&#x3D;&quot;my-post-time&quot; itemprop&#x3D;&quot;dateCreated&quot;</span><br><span class="line">              datetime&#x3D;&quot;&#123;&#123; moment(post.date).format() &#125;&#125;&quot;</span><br><span class="line">              content&#x3D;&quot;&#123;&#123; date(post.date, config.date_format) &#125;&#125;&quot;&gt;</span><br><span class="line">          &#123;&#123; date(post.date, &#39;MM-DD&#39;) &#125;&#125;</span><br><span class="line">        &lt;&#x2F;time&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;&#123;%- if theme.seo %&#125;h3&#123;% else %&#125;h2&#123;%- endif %&#125; class&#x3D;&quot;my-post-title&quot;&gt;</span><br><span class="line">        &#123;%- if post.link %&#125;&#123;# Link posts #&#125;</span><br><span class="line">          &lt;a class&#x3D;&quot;my-post-title-link post-title-link-external&quot; target&#x3D;&quot;_blank&quot; href&#x3D;&quot;&#123;&#123; url_for(post.link) &#125;&#125;&quot; itemprop&#x3D;&quot;url&quot;&gt;</span><br><span class="line">            &#123;&#123; post.title or post.link &#125;&#125;</span><br><span class="line">            &lt;i class&#x3D;&quot;fa fa-external-link&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">          &lt;&#x2F;a&gt;</span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">          &lt;a class&#x3D;&quot;my-post-title-link&quot; href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; itemprop&#x3D;&quot;url&quot;&gt;</span><br><span class="line">            &#123;% if post.type &#x3D;&#x3D;&#x3D; &#39;picture&#39; %&#125;</span><br><span class="line">              &#123;&#123; post.content &#125;&#125;</span><br><span class="line">            &#123;% else %&#125;</span><br><span class="line">              &lt;span itemprop&#x3D;&quot;name&quot;&gt;&#123;&#123; post.title or __(&#39;post.untitled&#39;) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">          &lt;&#x2F;a&gt;</span><br><span class="line">        &#123;%- endif %&#125;</span><br><span class="line">      &lt;&#x2F;&#123;%- if theme.seo %&#125;h3&#123;% else %&#125;h2&#123;%- endif %&#125;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;header&gt;</span><br><span class="line">  &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">&#123;%- endfor %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure>

<p>主要修改：一是将 post-meta这个div移到前面header 标签下；二是将所有的 class 属性都加上 my-，例如 my-post-meta，这样改动是为了不影响其它页面引用的样式。</p>
<ol>
<li>在 /themes/next/source/css/_schemes/(自己选择的主题)/index.styl 新增如下样式：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 归档页样式 began *&#x2F;</span><br><span class="line">.page-archive .archive-page-counter &#123;</span><br><span class="line">  font-size: 18px;</span><br><span class="line">  background-color: #49b1f5;</span><br><span class="line">  padding-left: 10px;</span><br><span class="line">  padding-right: 10px;</span><br><span class="line">  border-radius: 8px;</span><br><span class="line">  color: #fff;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.my-post-time&#123;</span><br><span class="line">  font-size: 11px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  color: #fff;</span><br><span class="line">  background-color: #49b1f5;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">  padding-left: 5px;</span><br><span class="line">  padding-right: 5px;</span><br><span class="line">  margin-left: 15px;</span><br><span class="line">&#125;</span><br><span class="line">.mypost&#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  margin-bottom: 1rem;</span><br><span class="line">  -webkit-transition: all .2s ease-in-out;</span><br><span class="line">  -moz-transition: all .2s ease-in-out;</span><br><span class="line">  -o-transition: all .2s ease-in-out;</span><br><span class="line">  -ms-transition: all .2s ease-in-out;</span><br><span class="line">  transition: all .2s ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line">a.my-post-title-link:before&#123;</span><br><span class="line">  top: 10px;</span><br><span class="line">  width: 18px;</span><br><span class="line">  height: 18px;</span><br><span class="line">  content: &quot;📚&quot;;</span><br><span class="line">  margin-right: 5px;</span><br><span class="line">  font: normal normal normal 14px&#x2F;1 FontAwesome;</span><br><span class="line">  font-size: 15px;</span><br><span class="line">  line-height: 18px;</span><br><span class="line">&#125;</span><br><span class="line">.my-post:hover&#123;</span><br><span class="line">  transform: scale(1.1);</span><br><span class="line">  box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);</span><br><span class="line">  border-radius: 30px;</span><br><span class="line">  width: 400px;</span><br><span class="line">  padding: 1px 10px;</span><br><span class="line">  margin-left: 25px;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  transition-duration: 0.15s;</span><br><span class="line">  +mobile()&#123;</span><br><span class="line">    width: 260px;</span><br><span class="line">    margin-left: 18px;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;display:flex;</span><br><span class="line">&#125;</span><br><span class="line">a.my-post-title-link&#123;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  font-size: 15px;</span><br><span class="line">  font-weight: 400;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.my-post-title&#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin-left: 4.5rem;</span><br><span class="line">  color: #4c4948;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  font-size: .8rem;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    &#x2F;&#x2F;margin-left: 4rem;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.my-post-header&#123;</span><br><span class="line">  position: top;</span><br><span class="line">  margin-bottom: 1rem;</span><br><span class="line">  -webkit-transition: all .2s ease-in-out;</span><br><span class="line">  -moz-transition: all .2s ease-in-out;</span><br><span class="line">  -o-transition: all .2s ease-in-out;</span><br><span class="line">  -ms-transition: all .2s ease-in-out;</span><br><span class="line">  transition: all .2s ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;.my-post-title-link&#123;</span><br><span class="line">&#x2F;&#x2F;  font-size: 16px;</span><br><span class="line">&#x2F;&#x2F;  font-weight: 500;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">.my-post-meta&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  color: #99a9bf;</span><br><span class="line">  width: 80px;</span><br><span class="line">  color: #114142;</span><br><span class="line">&#125;</span><br><span class="line">div.post-block.tag .collection-title h2 &#123;</span><br><span class="line">  border-width: 1px;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: #3f3f3f;</span><br><span class="line">  border-radius: 20px;</span><br><span class="line">  font-size: 22px;</span><br><span class="line">  background-color: #b4e8fa;</span><br><span class="line">  padding: 2px 15px;</span><br><span class="line">  letter-spacing: 1.5px;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  color: #3f3f3f;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin: 10px 0 10px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  +mobile()&#123;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 归档页样式 end *&#x2F;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><a href="https://img-blog.csdnimg.cn/20200720163209724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTY5Mzgz,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200720163209724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTY5Mzgz,size_16,color_FFFFFF,t_70" alt="img"></a></p>
<h1 id="分类页美化"><a href="#分类页美化" class="headerlink" title="分类页美化"></a>分类页美化</h1><p>在 /themes/next/source/css/_schemes/(自己选择的主题)/index.styl 新增如下样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 分类页样式 began *&#x2F;</span><br><span class="line">.category-list-link:hover&#123;</span><br><span class="line">  transform: scale(1.1);</span><br><span class="line">  box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);</span><br><span class="line">  border-radius: 15px;</span><br><span class="line">  padding: 6px 16px;</span><br><span class="line">  margin-left: 0px;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  transition-duration: 0.15s;</span><br><span class="line">  &#x2F;&#x2F;display:flex;</span><br><span class="line">&#125;</span><br><span class="line">a.category-list-link:before&#123;</span><br><span class="line">  top: 10px;</span><br><span class="line">  width: 18px;</span><br><span class="line">  height: 18px;</span><br><span class="line">  content: &quot;📚&quot;;</span><br><span class="line">  margin-right: 5px;</span><br><span class="line">  font: normal normal normal 14px&#x2F;1 FontAwesome;</span><br><span class="line">  font-size: 15px;</span><br><span class="line">  line-height: 18px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 分类页样式 end *&#x2F;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><a href="https://img-blog.csdnimg.cn/20200720172136778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTY5Mzgz,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200720172136778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTY5Mzgz,size_16,color_FFFFFF,t_70" alt="img"></a></p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性协议——Zab算法</title>
    <url>/posts/b369a3b6/</url>
    <content><![CDATA[<h1 id="Zab算法描述"><a href="#Zab算法描述" class="headerlink" title="Zab算法描述"></a>Zab算法描述</h1><p>Zab协议 的全称是 <strong>Zookeeper Atomic Broadcast</strong> （Zookeeper原子广播）。</p>
<p><strong>Zookeeper 是通过 Zab 协议来保证分布式事务的最终一致性</strong>。</p>
<ol>
<li>Zab协议是为分布式协调服务Zookeeper专门设计的一种 <strong>支持崩溃恢复</strong> 的 <strong>原子广播协议</strong> ，是Zookeeper保证数据一致性的核心算法。Zab借鉴了Paxos算法，但又不像Paxos那样，是一种通用的分布式一致性算法。<strong>它是特别为Zookeeper设计的支持崩溃恢复的原子广播协议</strong>。</li>
<li>在Zookeeper中主要依赖Zab协议来实现数据一致性，基于该协议，zk实现了一种主备模型（即Leader和Follower模型）的系统架构来保证集群中各个副本之间数据的一致性。<br> 这里的主备系统架构模型，就是指只有一台客户端（Leader）负责处理外部的写事务请求，然后Leader客户端将数据同步到其他Follower节点。</li>
</ol>
<p>Zookeeper 客户端会随机的链接到 zookeeper 集群中的一个节点，如果是<font color=red>读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交</font>。</p>
<h1 id="Zab-协议的特性："><a href="#Zab-协议的特性：" class="headerlink" title="Zab 协议的特性："></a><strong>Zab 协议的特性</strong>：</h1><p>1）Zab 协议需要确保那些<strong>已经在 Leader 服务器上提交（Commit）的事务最终被所有的服务器提交</strong>。</p>
<p>2）Zab 协议需要确保<strong>丢弃那些只在 Leader 上被提出而没有被提交的事务</strong>。</p>
<h1 id="Zab-协议的作用"><a href="#Zab-协议的作用" class="headerlink" title="Zab 协议的作用"></a>Zab 协议的作用</h1><ol>
<li><p><strong>使用一个单一的主进程（Leader）来接收并处理客户端的事务请求</strong>（也就是写请求），并采用了Zab的原子广播协议，将服务器数据的状态变更以 <strong>事务proposal</strong> （事务提议）的形式广播到所有的副本（Follower）进程上去。</p>
</li>
<li><p><strong>保证一个全局的变更序列被顺序引用</strong>。<br> Zookeeper是一个树形结构，很多操作都要先检查才能确定是否可以执行，比如P1的事务t1可能是创建节点”/a”，t2可能是创建节点”/a/bb”，只有先创建了父节点”/a”，才能创建子节点”/a/b”。</p>
<p> 为了保证这一点，Zab要保证同一个Leader发起的事务要按顺序被apply，同时还要保证只有先前Leader的事务被apply之后，新选举出来的Leader才能再次发起事务。</p>
</li>
<li><p><strong>当主进程出现异常的时候，整个zk集群依旧能正常工作</strong>。</p>
</li>
</ol>
<h2 id="Zab协议原理"><a href="#Zab协议原理" class="headerlink" title="Zab协议原理"></a>Zab协议原理</h2><p>Zab协议要求每个 Leader 都要经历三个阶段：<strong>发现，同步，广播</strong>。</p>
<ul>
<li><strong>发现</strong>：要求zookeeper集群必须选举出一个 Leader 进程，同时 Leader 会维护一个 Follower 可用客户端列表。将来客户端可以和这些 Follower节点进行通信。</li>
<li><strong>同步</strong>：Leader 要负责将本身的数据与 Follower 完成同步，做到多副本存储。这样也是提现了CAP中的高可用和分区容错。Follower将队列中未处理完的请求消费完成后，写入本地事务日志中。</li>
<li><strong>广播</strong>：Leader 可以接受客户端新的事务Proposal请求，将新的Proposal请求广播给所有的 Follower。</li>
</ul>
<h2 id="Zab协议核心"><a href="#Zab协议核心" class="headerlink" title="Zab协议核心"></a>Zab协议核心</h2><p>Zab协议的核心：<strong>定义了事务请求的处理方式</strong></p>
<p>1）所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被叫做 <strong>Leader服务器</strong>。其他剩余的服务器则是 <strong>Follower服务器</strong>。</p>
<p>2）Leader服务器 负责将一个客户端事务请求，转换成一个 <strong>事务Proposal</strong>，并将该 Proposal 分发给集群中所有的 Follower 服务器，也就是向所有 Follower 节点发送数据广播请求（或数据复制）</p>
<p>3）分发之后Leader服务器需要等待所有Follower服务器的反馈（Ack请求），<strong>在Zab协议中，只要超过半数的Follower服务器进行了正确的反馈</strong>后（也就是收到半数以上的Follower的Ack请求），那么 Leader 就会再次向所有的 Follower服务器发送 Commit 消息，要求其将上一个 事务proposal 进行提交。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302165537.png" alt="image-20210302165537904"></p>
<h2 id="Zab协议内容"><a href="#Zab协议内容" class="headerlink" title="Zab协议内容"></a>Zab协议内容</h2><p>Zab 协议包括两种基本的模式：<strong>崩溃恢复</strong> 和 <strong>消息广播</strong></p>
<h3 id="Zab协议内容-1"><a href="#Zab协议内容-1" class="headerlink" title="Zab协议内容"></a>Zab协议内容</h3><h4 id="协议过程"><a href="#协议过程" class="headerlink" title="协议过程"></a>协议过程</h4><p>当整个集群启动过程中，或者当 Leader 服务器出现网络中弄断、崩溃退出或重启等异常时，Zab协议就会 <strong>进入崩溃恢复模式</strong>，选举产生新的Leader。</p>
<p>当选举产生了新的 Leader，同时集群中有过半的机器与该 Leader 服务器完成了状态同步（即数据同步）之后，Zab协议就会退出崩溃恢复模式，<strong>进入消息广播模式</strong>。</p>
<p>这时，如果有一台遵守Zab协议的服务器加入集群，因为此时集群中已经存在一个Leader服务器在广播消息，那么该新加入的服务器自动进入恢复模式：找到Leader服务器，并且完成数据同步。同步完成后，作为新的Follower一起参与到消息广播流程中。</p>
<h4 id="协议状态切换"><a href="#协议状态切换" class="headerlink" title="协议状态切换"></a>协议状态切换</h4><p>当Leader出现崩溃退出或者机器重启，亦或是集群中不存在超过半数的服务器与Leader保存正常通信，Zab就会再一次进入崩溃恢复，发起新一轮Leader选举并实现数据同步。同步完成后又会进入消息广播模式，接收事务请求。</p>
<h4 id="保证消息有序"><a href="#保证消息有序" class="headerlink" title="保证消息有序"></a>保证消息有序</h4><p>在整个消息广播中，Leader会将每一个事务请求转换成对应的 proposal 来进行广播，并且在广播 事务Proposal 之前，Leader服务器会首先为这个事务Proposal分配一个全局单递增的唯一ID，称之为事务ID（即zxid），由于Zab协议需要保证每一个消息的严格的顺序关系，因此必须将每一个proposal按照其zxid的先后顺序进行排序和处理。</p>
<h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><ol>
<li><p>在zookeeper集群中，数据副本的传递策略就是采用消息广播模式。zookeeper中农数据副本的同步方式与二段提交相似，但是却又不同。二段提交要求协调者必须等到所有的参与者全部反馈ACK确认消息后，再发送commit消息。要求所有的参与者要么全部成功，要么全部失败。二段提交会产生严重的阻塞问题。</p>
</li>
<li><p>Zab协议中 Leader 等待 Follower 的ACK反馈消息是指“只要半数以上的Follower成功反馈即可，不需要收到全部Follower反馈”</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302170013.png" alt="消息广播流程图"></p>
</li>
</ol>
<h4 id="消息广播具体步骤"><a href="#消息广播具体步骤" class="headerlink" title="消息广播具体步骤"></a>消息广播具体步骤</h4><ol>
<li>客户端发起一个写操作请求。</li>
<li>Leader 服务器将客户端的请求转化为事务 Proposal 提案，同时为每个 Proposal 分配一个全局的ID，即zxid。</li>
<li>Leader 服务器为每个 Follower 服务器分配一个单独的队列，然后将需要广播的 Proposal 依次放到队列中取，并且根据 FIFO 策略进行消息发送。</li>
<li>Follower 接收到 Proposal 后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向 Leader 反馈一个 Ack 响应消息。</li>
<li>Leader 接收到超过半数以上 Follower 的 Ack 响应消息后，即认为消息发送成功，可以发送 commit 消息。</li>
<li>Leader 向所有 Follower 广播 commit 消息，同时自身也会完成事务提交。Follower 接收到 commit 消息后，会将上一条事务提交。</li>
</ol>
<p><strong>zookeeper 采用 Zab 协议的核心，就是只要有一台服务器提交了 Proposal，就要确保所有的服务器最终都能正确提交 Proposal。这也是 CAP/BASE 实现最终一致性的一个体现。</strong></p>
<p><strong>Leader 服务器与每一个 Follower 服务器之间都维护了一个单独的 FIFO 消息队列进行收发消息，使用队列消息可以做到异步解耦。 Leader 和 Follower 之间只需要往队列中发消息即可。如果使用同步的方式会引起阻塞，性能要下降很多。</strong></p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p><strong>一旦 Leader 服务器出现崩溃或者由于网络原因导致 Leader 服务器失去了与过半 Follower 的联系，那么就会进入崩溃恢复模式。</strong></p>
<p>在 Zab 协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的 Leader 服务器。因此 Zab 协议需要一个高效且可靠的 Leader 选举算法，从而确保能够快速选举出新的 Leader 。</p>
<p>Leader 选举算法不仅仅需要让 Leader 自己知道自己已经被选举为 Leader ，同时还需要让集群中的所有其他机器也能够快速感知到选举产生的新 Leader 服务器。</p>
<p>崩溃恢复主要包括两部分：<strong>Leader选举</strong> 和 <strong>数据恢复</strong></p>
<h4 id="Zab-协议保证数据一致性"><a href="#Zab-协议保证数据一致性" class="headerlink" title="Zab 协议保证数据一致性"></a>Zab 协议保证数据一致性</h4><p><strong>Zab 协议崩溃恢复要求满足以下两个要求</strong>：</p>
<ol>
<li><p><strong>确保已经被 Leader 提交的 Proposal 必须最终被所有的 Follower 服务器提交</strong>。</p>
</li>
<li><p><strong>确保丢弃已经被 Leader 提出的但是没有被提交的 Proposal</strong>。</p>
</li>
</ol>
<p>根据上述要求</p>
<p>Zab协议需要保证选举出来的Leader需要满足以下条件：</p>
<ol>
<li><p><strong>新选举出来的 Leader 不能包含未提交的 Proposal</strong> 。</p>
<p> 即新选举的 Leader 必须都是已经提交了 Proposal 的 Follower 服务器节点。</p>
</li>
<li><p><strong>新选举的 Leader 节点中含有最大的 zxid</strong> 。<br> 这样做的好处是可以避免 Leader 服务器检查 Proposal 的提交和丢弃工作。</p>
</li>
</ol>
<h4 id="Zab-数据同步"><a href="#Zab-数据同步" class="headerlink" title="Zab 数据同步"></a>Zab 数据同步</h4><ol>
<li>完成 Leader 选举后（新的 Leader 具有最高的zxid），在正式开始工作之前（接收事务请求，然后提出新的 Proposal），Leader 服务器会首先确认事务日志中的所有的 Proposal 是否已经被集群中过半的服务器 Commit。</li>
<li>Leader 服务器需要确保所有的 Follower 服务器能够接收到每一条事务的 Proposal ，并且能将所有已经提交的事务 Proposal 应用到内存数据中。等到 Follower 将所有尚未同步的事务 Proposal 都从 Leader 服务器上同步过啦并且应用到内存数据中以后，Leader 才会把该 Follower 加入到真正可用的 Follower 列表中。</li>
</ol>
<h4 id="Zab-数据同步过程中，如何处理需要丢弃的-Proposal"><a href="#Zab-数据同步过程中，如何处理需要丢弃的-Proposal" class="headerlink" title="Zab 数据同步过程中，如何处理需要丢弃的 Proposal"></a>Zab 数据同步过程中，如何处理需要丢弃的 Proposal</h4><p>在 Zab 的事务编号 zxid 设计中，zxid是一个64位的数字。</p>
<p>其中低32位可以看成一个简单的单增计数器，针对客户端每一个事务请求，Leader 在产生新的 Proposal 事务时，都会对该计数器加1。而<font color=red>高32位则代表了 Leader 周期的 epoch 编号</font>。</p>
<blockquote>
<p>epoch 编号可以理解为当前集群所处的年代，或者周期。每次Leader变更之后都会在 epoch 的基础上加1，这样旧的 Leader 崩溃恢复之后，其他Follower 也不会听它的了，因为 Follower 只服从epoch最高的 Leader 命令。</p>
</blockquote>
<p>每当选举产生一个新的 Leader ，就会从这个 <font color=red>Leader 服务器上取出本地事务日志充最大编号 Proposal 的 zxid，并从 zxid 中解析得到对应的 epoch 编号，然后再对其加1，之后该编号就作为新的 epoch 值，并将低32位数字归零，由0开始重新生成zxid</font>。</p>
<p><strong>Zab 协议通过 epoch 编号来区分 Leader 变化周期</strong>，能够有效避免不同的 Leader 错误的使用了相同的 zxid 编号提出了不一样的 Proposal 的异常情况。</p>
<h1 id="Zab实现原理"><a href="#Zab实现原理" class="headerlink" title="Zab实现原理"></a>Zab实现原理</h1><p><strong>Zab 节点有三种状态</strong>：</p>
<ul>
<li>Following：当前节点是跟随者，服从 Leader 节点的命令。</li>
<li>Leading：当前节点是 Leader，负责协调事务。</li>
<li>Election/Looking：节点处于选举状态，正在寻找 Leader。</li>
</ul>
<p>代码实现中，多了一种状态：Observing 状态<br>这是 Zookeeper 引入 Observer 之后加入的，Observer 不参与选举，是只读节点，跟 Zab 协议没有关系。</p>
<p><strong>节点的持久状态</strong>：</p>
<ul>
<li>history：当前节点接收到事务 Proposal 的Log</li>
<li>acceptedEpoch：Follower 已经接受的 Leader 更改 epoch 的 newEpoch 提议。</li>
<li>currentEpoch：当前所处的 Leader 年代</li>
<li>lastZxid：history 中最近接收到的Proposal 的 zxid（最大zxid）</li>
</ul>
<h2 id="Zab-的四个阶段"><a href="#Zab-的四个阶段" class="headerlink" title="Zab 的四个阶段"></a>Zab 的四个阶段</h2><h3 id="选举阶段（Leader-Election"><a href="#选举阶段（Leader-Election" class="headerlink" title="选举阶段（Leader Election"></a>选举阶段（Leader Election</h3><p>节点在一开始都处于选举节点，只要有一个节点得到超过半数节点的票数，它就可以当选准 Leader，只有到达第三个阶段（也就是同步阶段），这个准 Leader 才会成为真正的 Leader。<strong>Zookeeper 规定所有有效的投票都必须在同一个 轮次 中，每个服务器在开始新一轮投票时，都会对自己维护的 logicalClock 进行自增操作</strong>。</p>
<p>每个服务器在广播自己的选票前，会将自己的投票箱（recvset）清空。该投票箱记录了所受到的选票。</p>
<p>例如：Server_2 投票给 Server_3，Server_3 投票给 Server_1，则Server_1的投票箱为(2,3)、(3,1)、(1,1)。（每个服务器都会默认给自己投票）</p>
<p>前一个数字表示投票者，后一个数字表示被选举者。票箱中只会记录每一个投票者的最后一次投票记录，如果投票者更新自己的选票，则其他服务器收到该新选票后会在自己的票箱中更新该服务器的选票。</p>
<p><strong>这一阶段的目的就是为了选出一个准 Leader ，然后进入下一个阶段。</strong></p>
<p>协议并没有规定详细的选举算法，后面会提到实现中使用的 Fast Leader Election。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302171418.png" alt="选举流程"></p>
<h3 id="发现阶段（Descovery）"><a href="#发现阶段（Descovery）" class="headerlink" title="发现阶段（Descovery）"></a>发现阶段（Descovery）</h3><p>在这个阶段，Followers 和上一轮选举出的准 Leader 进行通信，同步 Followers 最近接收的事务 Proposal 。</p>
<p>一个 Follower 只会连接一个 Leader，如果一个 Follower 节点连接另一个 Follower 节点，则会在尝试连接时被拒绝。被拒绝之后，该节点就会进入 Leader Election阶段。</p>
<p><strong>这个阶段的主要目的是发现当前大多数节点接收的最新 Proposal，并且准 Leader 生成新的 epoch ，让 Followers 接收，更新它们的 acceptedEpoch</strong>。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302171535.png" alt="发现流程"></p>
<h3 id="同步阶段（Synchronization）"><a href="#同步阶段（Synchronization）" class="headerlink" title="同步阶段（Synchronization）"></a>同步阶段（Synchronization）</h3><p><strong>同步阶段主要是利用 Leader 前一阶段获得的最新 Proposal 历史，同步集群中所有的副本</strong>。<br>只有当 quorum（超过半数的节点） 都同步完成，准 Leader 才会成为真正的 Leader。Follower 只会接收 zxid 比自己 lastZxid 大的 Proposal。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302171702.png" alt="同步流程"></p>
<h3 id="广播阶段（Broadcast）"><a href="#广播阶段（Broadcast）" class="headerlink" title="广播阶段（Broadcast）"></a>广播阶段（Broadcast）</h3><p>到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 Leader 可以进行消息广播。同时，如果有新的节点加入，还需要对新节点进行同步。</p>
<p>需要注意的是，Zab 提交事务并不像 2PC 一样需要全部 Follower 都 Ack，只需要得到 quorum（超过半数的节点）的Ack 就可以。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302171740.png" alt="广播流程"></p>
<h1 id="Zab协议实现"><a href="#Zab协议实现" class="headerlink" title="Zab协议实现"></a>Zab协议实现</h1><p>选举阶段使用 java版本实现的是Fast Leader Election算法，实际的实现将<strong>发现和同步阶段合并为 Recovery Phase（恢复阶段）</strong>，所以，Zab 的实现实际上有三个阶段。</p>
<p>Zab协议三个阶段：</p>
<ol>
<li><strong>选举（Fast Leader Election）</strong></li>
<li><strong>恢复（Recovery Phase）</strong></li>
<li><strong>广播（Broadcast Phase）</strong></li>
</ol>
<h2 id="Fast-Leader-Election（快速选举）"><a href="#Fast-Leader-Election（快速选举）" class="headerlink" title="Fast Leader Election（快速选举）"></a>Fast Leader Election（快速选举）</h2><p> FLE 会选举拥有最新Proposal history （lastZxid最大）的节点作为 Leader，这样就省去了发现最新提议的步骤。<strong>这是基于拥有最新提议的节点也拥有最新的提交记录</strong></p>
<h3 id="成为-Leader-的条件："><a href="#成为-Leader-的条件：" class="headerlink" title="成为 Leader 的条件："></a>成为 Leader 的条件：</h3><ol>
<li>选 epoch 最大的</li>
<li>若 epoch 相等，选 zxid 最大的</li>
<li>若 epoch 和 zxid 相等，选择 server_id 最大的（<strong>zoo.cfg中的myid</strong>）</li>
</ol>
<p>节点在选举开始时，都默认投票给自己，当接收其他节点的选票时，会根据上面的 <strong>Leader条件</strong> 判断并且更改自己的选票，然后重新发送选票给其他节点。<strong>当有一个节点的得票超过半数，该节点会设置自己的状态为 Leading ，其他节点会设置自己的状态为 Following</strong>。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302172451.png" alt="选举过程"></p>
<h2 id="Recovery-Phase（恢复阶段）"><a href="#Recovery-Phase（恢复阶段）" class="headerlink" title="Recovery Phase（恢复阶段）"></a>Recovery Phase（恢复阶段）</h2><p>这一阶段 Follower 发送他们的 <strong>lastZxid</strong> 给 Leader，Leader 根据 lastZxid 决定如何同步数据。这里的实现跟前面的 Phase 2 有所不同：Follower 收到 TRUNC 指令会终止L.lastCommitedZxid 之后的 Proposal ，收到 DIFF 指令会接收新的 Proposal。</p>
<blockquote>
<p>history.lastCommitedZxid：最近被提交的 Proposal zxid</p>
<p>history.oldThreshold：被认为已经太旧的已经提交的 Proposal zxid</p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302172728.png" alt="恢复阶段"></p>
<h1 id="Zab特殊情况下需要解决的两个问题："><a href="#Zab特殊情况下需要解决的两个问题：" class="headerlink" title="Zab特殊情况下需要解决的两个问题："></a>Zab特殊情况下需要解决的两个问题：</h1><h2 id="已经被处理的事务请求（proposal）不能丢（commit的）"><a href="#已经被处理的事务请求（proposal）不能丢（commit的）" class="headerlink" title="已经被处理的事务请求（proposal）不能丢（commit的）"></a>已经被处理的事务请求（proposal）不能丢（commit的）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当 leader 收到合法数量 follower 的 ACKs 后，就向各个 follower 广播 COMMIT 命令，同时也会在本地执行 COMMIT 并向连接的客户端返回「成功」。但是如果在各个 follower 在收到COMMIT 命令前 leader 就挂了，导致剩下的服务器并没有执行都这条消息。</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ol>
<li><p>选举拥有 proposal 最大值（即 zxid 最大） 的节点作为新的 leader。</p>
<blockquote>
<p>由于所有提案被 COMMIT 之前必须有<font color=red>合法数量的 follower ACK，即必须有合法数量的服务器的事务日志上有该提案的 proposal</font>，因此，zxid最大也就是数据最新的节点保存了所有被 COMMIT 消息的 proposal 状态。</p>
</blockquote>
</li>
<li><p>新的 leader 将自己事务日志中 proposal 但未 COMMIT 的消息处理。</p>
</li>
<li><p>新的 leader 与 follower 建立先进先出的队列， 先将自身有而 follower 没有的 proposal</p>
<p> 发送给 follower，再将这些 proposal 的 COMMIT 命令发送给 follower，以保证所有的</p>
<p> follower 都保存了所有的 proposal、所有的 follower 都处理了所有的消息</p>
</li>
</ol>
<h2 id="没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？"><a href="#没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？" class="headerlink" title="没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？"></a>没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>当 leader 接收到消息请求生成 proposal 后就挂了，其他 follower 并没有收到此 proposal，因此经过恢复模式重新选了 leader 后，这条消息是被跳过的。 此时，之前挂了的 leader 重新启动并注册成了 follower，他保留了被跳过消息的 proposal 状态，与整个系统的状态是不一致的，需要将其删除。</p>
<h3 id="解决方式-1"><a href="#解决方式-1" class="headerlink" title="解决方式"></a>解决方式</h3><p><strong>Zab 通过巧妙的设计 zxid 来实现这一目的。</strong></p>
<p>一个 zxid 是64位，高 32 是纪元（epoch）编号，每经过一次 leader 选举产生一个新的 leader，新 leader 会将 epoch 号 +1。低 32 位是消息计数器，每接收到一条消息这个值 +1，新 leader 选举后这个值重置为 0。</p>
<p>这样设计的好处是旧的 leader 挂了后重启，它不会被选举为 leader，因为此时它的 zxid 肯定小于当前的新 leader。当旧的 leader 作为 follower 接入新的 leader 后，新的 leader 会让它将所有的拥有旧的 epoch 号的未被 COMMIT 的 proposal 清除。</p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
        <category>Zab</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
        <tag>ZAB</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性协议——paxos算法</title>
    <url>/posts/fe45d335/</url>
    <content><![CDATA[<h1 id="paxos目的"><a href="#paxos目的" class="headerlink" title="paxos目的"></a>paxos目的</h1><p>Paxos算法是<font color=red>基于消息传递且具有高度容错特性的一致性算法</font>，是目前公认的解决分布式一致性问题最有效的算法之一，其<font color=red>解决的问题就是在分布式系统中如何就某个值（决议）达成一致</font>。</p>
<p>Paxos算法的前提假设是不存在拜占庭将军问题，即： <font color=red>信道是安全的（信道可靠），发出的信号不会被篡改，因为Paxos算法是基于消息传递的</font>。：如下图所示</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302154508.png" alt="image-20210302154508699"></p>
<h1 id="paxos算法角色划分：三种类型"><a href="#paxos算法角色划分：三种类型" class="headerlink" title="paxos算法角色划分：三种类型"></a>paxos算法角色划分：三种类型</h1><ul>
<li><p>提议者（Proposer）：提出提案；</p>
</li>
<li><p>接受者（Acceptor）：对提案作出裁决；</p>
</li>
<li><p>告知者（Learner）：被告知投票的结果，<strong>不参与投票过程</strong>。</p>
<blockquote>
<p><font color=blue>提案（Proposal）</font>。最终要达成一致的value就在提案里。只要Proposer发的提案被Acceptor接受（半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。只要Acceptor接受了某个提案，Acceptor就任务该提案里的value被选定了。</p>
</blockquote>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210302155514.png" alt="image-20210302155514766"></p>
</li>
</ul>
<p><strong>优势</strong>：为了避免单点问题：会有一个acceptor集合，proposer向该集合发送提案，acceptor集合中所有成员都有可能接受提案，并且只能批准一个提案，当有半数以上的成员同意，那么就同意批准该提案</p>
<h1 id="paxos算法过程"><a href="#paxos算法过程" class="headerlink" title="paxos算法过程"></a>paxos算法过程</h1><ul>
<li>阶段一（prepare阶段）：</li>
</ul>
<p>(a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。Pareper（N）</p>
<p>(b) 如果一个Acceptor收到一个编号为N的Prepare请求，如果小于它已经响应过的请求，则拒绝，不回应或回复error。若N大于该Acceptor已经响应过的所有Prepare请求的编号（maxN），那么它就会将它已经接受过（已经经过第二阶段accept的提案）的编号最大的提案（如果有的话，如果还没有的accept提案的话返回{pok，null，null}）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案</p>
<ul>
<li>阶段二（accept阶段）：</li>
</ul>
<p>(a) 如果一个Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value（某个acceptor响应的它已经通过的{acceptN，acceptV}），如果响应中不包含任何提案，那么V就由Proposer自己决定。</p>
<p>(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。如果N小于Acceptor以及响应的prepare请求，则拒绝，不回应或回复error（当proposer没有收到过半的回应，那么他会重新进入第一阶段，递增提案号，重新提出prepare请求）。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302154726.png" alt="image-20210302154726554"></p>
<h1 id="paxos优缺点"><a href="#paxos优缺点" class="headerlink" title="paxos优缺点"></a>paxos优缺点</h1><p>优点：paxos算法的优点很明显，按照此方法可以对多个数据值达到一致，收敛较好。</p>
<p>缺点：paxos算法的缺点是会出现活锁问题：考虑到一种极端的情况下，有两个proposer依次提出了一系列编号递增的议案，但是最终paxos无法形成最终的议案。具体场景如下：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302154914.png"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302154927.png"><strong>解决办法</strong>：</p>
<p>通过<strong>选取主Proposer</strong>，就可以保证Paxos算法的活性。选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来，<font color=red>只要主Proposer和过半的Acceptor能够正常进行网络通信，那么肯定会有一个提案被批准（第二阶段的accept），则可以解决死循环导致的活锁问题</font>。</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p><strong>通过选择一个主Proposer，并规定只能由主Proposer才能提出议案，整个paxos算法就可以保持活性。</strong></p>
<h1 id="Paxos算法的过半依据"><a href="#Paxos算法的过半依据" class="headerlink" title="Paxos算法的过半依据"></a>Paxos算法的过半依据</h1><p>在Paxos算法中，采用了“过半”理念，也就是少数服从多数，这使Paxos算法具有很好的容错性</p>
<h2 id="Paxos基于的过半数学原理"><a href="#Paxos基于的过半数学原理" class="headerlink" title="Paxos基于的过半数学原理"></a>Paxos基于的过半数学原理</h2><p>大多数（过半）进程组成的集合为法定集合，<font color=red> 两个法定（过半）集合必然存在非空交集，即至少有一个公共进程，称为法定集合性质</font>。 例如A,B,C,D,F进程组成的全集，法定集合Q1包括进程A,B,C，Q2包括进程B,C,D，那么Q1和Q2的交集必然不在空，C就是Q1，Q2的公共进程。如果要说Paxos最根本的原理是什么，那么就是这个简单性质。也就是说：<font color=red>两个过半的集合必然存在交集，也就是肯定是相等的，也就是肯定达成了一致</font>。</p>
<p>Paxos是基于消息传递的具有高度容错性的分布式一致性算法。<font color=red>Paxos算法引入了过半的概念，解决了2PC，3PC的太过保守的缺点，且使算法具有了很好的容错性，另外Paxos算法支持分布式节点角色之间的轮换，这极大避免了分布式单点的出现，因此Paxos算法既解决了无限等待问题，也解决了脑裂问题，是目前来说最优秀的分布式一致性算法。其中，Zookeeper的ZAB算法和Raft一致性算法都是基于Paxos的</font></p>
<p>参考文档：</p>
<ol>
<li><a href="https://www.zhihu.com/question/19787937">如何浅显易懂地解说 Paxos 的算法？</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95">paxos算法</a></li>
</ol>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
        <category>panxos</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
        <tag>panxos</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper的安装和简单操作</title>
    <url>/posts/b439f21c/</url>
    <content><![CDATA[<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><ol>
<li>系统：CentOS 7</li>
<li>Java环境： JDK8</li>
</ol>
<h1 id="下载及安装"><a href="#下载及安装" class="headerlink" title="下载及安装"></a>下载及安装</h1><p>　zookeeper有单机、伪集群、集群三种部署方式，我使用的zookeeper版本是：zookeeper-3.5.9</p>
<p>下载Zookeeper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;apache.claz.org&#x2F;zookeeper&#x2F;zookeeper-3.5.9&#x2F;apache-zookeeper-3.5.9-bin.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h2><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;解压到指定目录</span><br><span class="line">tar -zxvf apache-zookeeper-3.5.9-bin.tar.gz   -C &#x2F;user&#x2F;soft&#x2F;</span><br></pre></td></tr></table></figure>

<p>解压后目录</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301110436.png" alt="image-20210301110435970"></p>
<p>进入conf目录，创建一个zookeeper的配置文件zoo.cfg，可复制conf/zoo_sample.cfg作为配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>

<h3 id="配置文件说明："><a href="#配置文件说明：" class="headerlink" title="配置文件说明："></a>配置文件说明：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line"># tickTime：CS通信心跳数</span><br><span class="line"># Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。tickTime以毫秒为单位。</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"></span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">#initLimit：LF初始通信时限</span><br><span class="line"># 集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量）。</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"></span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line"># syncLimit：LF同步通信时限</span><br><span class="line"># 集群中的follower服务器与leader服务器之间请求和应答之间能容忍的最多心跳数（tickTime*syncLimit ）。</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># dataDir：数据文件目录</span><br><span class="line"># Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;apache-zookeeper-3.6.2-bin&#x2F;data</span><br><span class="line"></span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">#clientPort：客户端连接端口</span><br><span class="line">#客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"></span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#最大连接数</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#保留数量3</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"></span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#清理时间间隔1小时</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br><span class="line"></span><br><span class="line">## Metrics Providers</span><br><span class="line">#</span><br><span class="line"># https:&#x2F;&#x2F;prometheus.io Metrics Exporter</span><br><span class="line">#metricsProvider.className&#x3D;org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span><br><span class="line">#metricsProvider.httpPort&#x3D;7000</span><br><span class="line">#metricsProvider.exportJvmInfo&#x3D;true</span><br><span class="line"></span><br><span class="line"> # 服务器名称与地址：集群信息（服务器编号，服务器地址，LF通信端口，选举端口）</span><br><span class="line"># 这个配置项的书写格式比较特殊，规则如下：</span><br><span class="line"># server.N&#x3D;YYY:A:B   </span><br><span class="line"># 其中N表示服务器编号，YYY表示服务器的IP地址，A为LF通信端口，表示该服务器与集群中的leader交换的信息的端口。B为选举端口，表示选举新leader时服务器间相互通信的端口（当leader挂掉时，其余服务器会相互通信，选择出新的leader）。一般来说，集群中每个服务器的A端口都是一样，每个服务器的B端口也是一样。但是当所采用的为伪集群时，IP地址都一样，只能时A端口和B端口不一样。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="启动及停止服务"><a href="#启动及停止服务" class="headerlink" title="启动及停止服务"></a>启动及停止服务</h3><p>可以不修改zoo.cfg，默认配置就行，进去zookeeper安装目录，启动ZooKeeper</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动命令：</span></span><br><span class="line">./bin/zkServer.sh start</span><br><span class="line"><span class="comment">#在前端启动，可看启动日志</span></span><br><span class="line">./bin/zkServer.sh start-foreground</span><br><span class="line"><span class="comment">#停止命令：</span></span><br><span class="line">./bin/zkServer.sh stop　　</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启命令：</span></span><br><span class="line">./bin/zkServer.sh restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#状态查看命令：</span></span><br><span class="line">./bin/zkServer.sh status</span><br></pre></td></tr></table></figure>

<h2 id="伪集群模式"><a href="#伪集群模式" class="headerlink" title="伪集群模式"></a>伪集群模式</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在同一台主机上，通过复制得到三个zookeeper实例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp -r  /usr/soft/zookeeper/Zookeeper   /usr/soft/zookeeper/Zookeeper2</span><br></pre></td></tr></table></figure>



<h3 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h3><p>zookeeper1配置文件conf/zoo.cfg修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper1&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper1&#x2F;logs</span><br><span class="line">clientPort&#x3D;12181</span><br><span class="line"></span><br><span class="line">server.1&#x3D;127.0.0.1:12888:13888</span><br><span class="line">server.2&#x3D;127.0.0.1:14888:15888</span><br><span class="line">server.3&#x3D;127.0.0.1:16888:17888</span><br></pre></td></tr></table></figure>

<p>注：server.1中的数字1为<strong>服务器的ID</strong>，需要与<strong>myid文件中的id一致</strong>，下一步将配置myid</p>
<p>zookeeper1的data/myid配置，使用如下命令（即新建一个文件data/myid，在其中添加内容为：1）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1&#x27;</span> &gt; data/myid</span><br></pre></td></tr></table></figure>

<p>zookeeper2配置文件conf/zoo.cfg修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper2&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper2&#x2F;logs</span><br><span class="line">clientPort&#x3D;12182</span><br><span class="line"></span><br><span class="line">server.1&#x3D;127.0.0.1:12888:13888</span><br><span class="line">server.2&#x3D;127.0.0.1:14888:15888</span><br><span class="line">server.3&#x3D;127.0.0.1:16888:17888</span><br></pre></td></tr></table></figure>

<p>zookeeper2的data/myid配置，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;2&#39; &gt; data&#x2F;myid</span><br></pre></td></tr></table></figure>

<p>zookeeper3配置文件conf/zoo.cfg修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper3&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper3&#x2F;logs</span><br><span class="line">clientPort&#x3D;12183</span><br><span class="line"></span><br><span class="line">server.1&#x3D;127.0.0.1:12888:13888</span><br><span class="line">server.2&#x3D;127.0.0.1:14888:15888</span><br><span class="line">server.3&#x3D;127.0.0.1:16888:17888</span><br></pre></td></tr></table></figure>

<p>zookeeper3的data/myid配置，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;3&#39; &gt; data&#x2F;myid</span><br></pre></td></tr></table></figure>

<p>分别启动三个zookeeper节点</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301134558.png" alt="image-20210301134558405"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301134626.png" alt="image-20210301134626147"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301134728.png" alt="image-20210301134728171"></p>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>参考伪集群模式</p>
<p>　　　　1、在三台机器上分别部署1个ZooKeeper实例</p>
<p>　　　　2、zookeeper配置文件conf/zoo.cfg，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper1&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper1&#x2F;logs</span><br><span class="line">clientPort&#x3D;12181</span><br><span class="line"></span><br><span class="line">server.1&#x3D;127.0.0.1:12888:13888</span><br><span class="line">&#x2F;&#x2F;修改为2，3节点的ip</span><br><span class="line">server.2&#x3D;127.0.0.1:14888:15888</span><br><span class="line">server.3&#x3D;127.0.0.1:16888:17888</span><br></pre></td></tr></table></figure>

<p>3、zookeeper的data/myid配置，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 echo &#39;1&#39; &gt; data&#x2F;myid</span><br></pre></td></tr></table></figure>

<p>zookeeper1 对应的是 1，zookeeper2 对应的是 2，zookeeper3 对应的是 3</p>
<p>　　4、分别启动三个zookeeper节点，即完成对ZooKeeper集群的安装</p>
<h1 id="Zookeeper简单操作"><a href="#Zookeeper简单操作" class="headerlink" title="Zookeeper简单操作"></a>Zookeeper简单操作</h1><p>a、使用客户端连接ZooKeeper服务</p>
<p>　命令：<code>./bin/zkCli.sh -server 127.0.0.1:12181</code></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301140944.png" alt="image-20210301140944047"></p>
<p>b、使用 ls 命令来查看当前 ZooKeeper 中所包含的内容：<br>命令：<font color=blue>ls /</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301141124.png" alt="image-20210301141124292"></p>
<p>c 、创建节点</p>
<p>命令 ：<font color=blue>create /zk myData</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301141402.png" alt="image-20210301141402229"></p>
<p>d、获取节点‘zk’</p>
<p>命令：<font color=blue>get /zk</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301141449.png" alt="image-20210301141449291"></p>
<p>e、删除znode节点“ zk </p>
<p>命令：<font color=blue>delete /zk</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301141725.png" alt="image-20210301141725018"></p>
<p>f、退出客户端</p>
<p>命令：<font color=blue>quit</font></p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性理论，CAP，BASE理论</title>
    <url>/posts/6afaddd1/</url>
    <content><![CDATA[<h1 id="分布式的问题"><a href="#分布式的问题" class="headerlink" title="分布式的问题"></a>分布式的问题</h1><p>分布式因为<strong>网络的不确定性</strong>，<strong>节点故障等情况</strong>，会带来各种复杂的问题。我们在学习分布式的相关理论时，一定要明确这样一个<strong>道理</strong>，就是：网络不可靠，网络分区以及节点宕机是常态，另外网络带宽资源是及其珍贵的，我们<font color=red>必须在网络不可靠、分区以及节点宕机的前提下，构建高性能、高可用的分布式系统</font>。</p>
<h2 id="分布式环境的问题"><a href="#分布式环境的问题" class="headerlink" title="分布式环境的问题"></a>分布式环境的问题</h2><ol>
<li><strong>通信异常</strong>：从集中式向分布式演变过程中，必然会引入网络因素，而由于网络本身的不可靠性，因此也引入了额外的问题。<strong>分布式系统需要在各个节点之间进行网络通信，因此当网络通信设备故障就会导致无法顺利完成一次网络通信，就算各节点的网络通信正常，但是消息丢失和消息延时也是非常普遍的事情</strong>。</li>
<li><strong>网络分区（脑裂）</strong>：网络发生异常情况导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点，只有部分节点能够正常通行，而另一些节点则不能。我们称这种情况叫做网络分区（脑裂），当网络分区出现时，<strong>分布式系统会出现多个局部小集群（多个小集群可能又会产生多个master节点），所以分布式系统要求这些小集群要能独立完成原本需要整个分布式系统才能完成的功能</strong>，这就对分布式一致性提出了非常大的挑战。</li>
<li><strong>节点故障</strong>：节点宕机是分布式环境中的常态，每个节点都有可能会出现宕机或僵死的情况，并且每天都在发生。</li>
<li><strong>三态</strong>：由于网络不可靠的原因，因此<strong>分布式系统的每一次请求，都存在特有的“三态”概念，即：成功，失败与超时</strong>。在集中式单机部署中，由于没有网络因素，所以程序的每一次调用都能得到“成功”或者“失败”的响应，但是在分布式系统中，网络不可靠，可能就会出现超时的情况。<strong>可能在消息发送时丢失或者在响应过程中丢失，当出现超时情况时，网络通信的发起方是无法确定当前请求是否被成功处理的，所以这也是分布式事务的难点</strong>。</li>
</ol>
<h1 id="分布式数据一致性问题"><a href="#分布式数据一致性问题" class="headerlink" title="分布式数据一致性问题"></a>分布式数据一致性问题</h1><p>在分布式系统中，<strong>节点宕机是常态</strong>，为了高可用性，我们一般会部署多台服务器，势必就会存在<strong>数据的复制问题</strong>，分布式系统对于数据的复制需求一般来自于以下两个原因：</p>
<blockquote>
<ul>
<li>高可用：将数据复制到分布式部署的多台机器中，可以消除单点故障，防止系统由于某台（些）机器宕机导致的不可用。</li>
<li>性能：通过负载均衡技术，能够让分布在不同地方的数据副本全都对外提供服务。有效提高系统性能。</li>
</ul>
</blockquote>
<p><strong>在分布式系统引入复制机制后，不同的数据节点之间由于网络延时等原因很容易产生数据不一致的情况</strong>。复制机制的目的是为了保证数据的一致性。但是数据复制面临的主要难题也是如何保证多个副本之间的数据一致性。其中，常见的就是主从数据库之间的复制延时问题。</p>
<blockquote>
<p>Zookeeper就是分布式一致性问题的工业解决方案，paxos是理论算法，其中zab，raft和众多开源算法是对paxos的工业级实现。Zookeeper使用zab来保证其自身系统的高可用与数据一致性的。</p>
</blockquote>
<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p>
<p>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</p>
<p>可用性（A）：保证每个请求不管成功或者失败都有响应。</p>
<p>分区容忍性（P）：系统中任意信息的丢失或失败不会影响系统的继续运作。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302163013.png" alt="image-20210302163013412"></p>
<p>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足</p>
<h2 id="一致性与可用性的决择编辑"><a href="#一致性与可用性的决择编辑" class="headerlink" title="一致性与可用性的决择编辑"></a>一致性与可用性的决择编辑</h2><p>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以<font color=red>分区容忍性是我们必须需要实现的</font>。所以我们<font color=red>只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点</font>。</p>
<p>CAP三个特性只能满足其中两个，那么取舍的策略就共有三种：</p>
<p><strong><font color=red>CA without P</font>：</strong>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。<strong>传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</strong></p>
<p><strong><font color=red>CP without A </font>：</strong>如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，<strong>最典型的就是分布式数据库，如Redis、HBase等</strong>。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p>
<p> <strong><font color=red>AP wihtout C</font>：</strong>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，<font color=red>其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）</font></p>
<h2 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h2><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</p>
<ul>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</li>
<li>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ul>
<p>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据听不的过程存在延时。</p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>最终一致性强调的是<font color=red>系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态</font>。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
        <category>CAP</category>
        <category>BASE理论</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
        <tag>CAP</tag>
        <tag>BASE理论</tag>
      </tags>
  </entry>
  <entry>
    <title>修复点击目录无法跳转</title>
    <url>/posts/14f8dec7/</url>
    <content><![CDATA[<p>在 themes/next/source/js/util.js 中增加两行代码，删除两行代码。保存，hexo clean &amp; hexo g &amp; hexo s 即可解决。（如果还是不行就删除浏览器缓存重试）</p>
<p><a href="https://github.com/theme-next/hexo-theme-next/pull/1540/files">中文目录层级无法跳转</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210225115114.png" alt="image-20210225115114883"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">registerSidebarTOC: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> navItems = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.post-toc li&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> sections = [...navItems].map(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> link = element.querySelector(<span class="string">&#x27;a.nav-link&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(<span class="built_in">decodeURI</span>(link.getAttribute(<span class="string">&#x27;href&#x27;</span>)).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    <span class="comment">// TOC item animation navigate.</span></span><br><span class="line">    link.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">      <span class="comment">// var target = document.getElementById(event.currentTarget.getAttribute(&#x27;href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;));</span></span><br><span class="line">      <span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br><span class="line">      <span class="built_in">window</span>.anime(&#123;</span><br><span class="line">        targets  : <span class="built_in">document</span>.scrollingElement,</span><br><span class="line">        duration : <span class="number">500</span>,</span><br><span class="line">        easing   : <span class="string">&#x27;linear&#x27;</span>,</span><br><span class="line">        scrollTop: offset + <span class="number">10</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">    <span class="comment">// return document.getElementById(link.getAttribute(&#x27;href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;));</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客优化Next7主题优化</title>
    <url>/posts/33ffdf26/</url>
    <content><![CDATA[<h1 id="设置站点名等"><a href="#设置站点名等" class="headerlink" title="设置站点名等"></a>设置站点名等</h1><p>打开<strong>根目录下的<code>_config.yml</code></strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">三才生的个人笔记</span>   <span class="comment">#标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">三才生的个人笔记</span>  <span class="comment">#标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">三才生的个人笔记</span> <span class="comment">#标题</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">CNRF</span>     <span class="comment">#作者名称</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>  <span class="comment">#设置简体中文</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">UTC</span>	<span class="comment">#设置时区</span></span><br></pre></td></tr></table></figure>



<h1 id="选择scheme"><a href="#选择scheme" class="headerlink" title="选择scheme"></a>选择scheme</h1><p>在主目录的\source_data\next.yml中，,查找<code>scheme</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>

<h1 id="设置菜单及对应页面"><a href="#设置菜单及对应页面" class="headerlink" title="设置菜单及对应页面"></a>设置菜单及对应页面</h1><p>在主目录的\source_data\next.yml中，查找<code>menu</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">heartbeat</span></span><br></pre></td></tr></table></figure>

<p>去掉<code>#</code>注释即可显示对应的菜单项，也可自定义新的菜单项。 <code>||</code>之前的值是目标链接，之后的是分类页面的图标，图标名称来自于FontAwesome icon。若没有配置图标，默认会使用问号图标。</p>
<p>新添加的菜单需要翻译对应的中文<br>打开<code>hexo/theme/next/languages/zh-CN.yml</code>，在menu下自定义，如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">资源</span></span><br></pre></td></tr></table></figure>

<p>配置新增的菜单</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;commonweal&quot;</span><br></pre></td></tr></table></figure>

<p>在<strong>主目录下source</strong>新建404.html</p>
<blockquote>
<p><strong>Hexo 默认会渲染所有的 HTML 和 Markdown 文件</strong>。</p>
</blockquote>
<p>因此我们可以简单地在文件开头加上 <code>layout: false</code> 一行来避免渲染：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+layout: false</span><br><span class="line">+---</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>404<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">homePageUrl</span>=<span class="string">&quot;/&quot;</span> <span class="attr">homePageName</span>=<span class="string">&quot;返回&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="设定站点建立时间"><a href="#设定站点建立时间" class="headerlink" title="设定站点建立时间"></a>设定站点建立时间</h1><p>打开**<code>themes/next/</code>下的<code>_config.yml</code>**，查找<code>since</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup.</span></span><br><span class="line">  <span class="comment"># If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2015</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如果不设置，默认显示当前年份</strong>。</p>
<h1 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h1><p>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>avatar</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar111.png</span>  <span class="comment"># 设置头像资源的位置</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span>            <span class="comment"># 开启圆形头像</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1</span>               <span class="comment"># 不透明的比例：0就是完全透明</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span>           <span class="comment"># 不开启旋转</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224210106.png" alt="image-20210224210106776"></p>
<p><code>avatar</code>的值是<strong>图片的链接地址</strong>(完整的URI 或者 站内的相对地址皆可)</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>完整的URI</td>
<td><a href="http://example.com/avatar.png">http://example.com/avatar.png</a></td>
</tr>
<tr>
<td>站点内地址</td>
<td>图片放至<code>themes/next/source/images/</code>配置为：<code>avatar: /images/图片名</code></td>
</tr>
<tr>
<td>站点内地址</td>
<td>图片放至<strong>根目录下</strong><code>source/uploads/</code>(初始无uploads文件夹，自行创建)目录下配置为：<code>avatar: /uploads/图片名</code></td>
</tr>
</tbody></table>
<h1 id="网站图标设置"><a href="#网站图标设置" class="headerlink" title="网站图标设置"></a>网站图标设置</h1><ul>
<li><p>图标素材网站：<a href="https://www.iconfont.cn/">iconfont</a>；<a href="https://www.easyicon.net/">easyicon</a></p>
</li>
<li><p>下载16x16以及32x32大小的<strong>PNG格式图标</strong>，置于<code>/themes/next/source/images/</code>下</p>
</li>
<li><p>打开**<code>source/_data</code>下的<code>next.yml</code>**，查找<code>favicon</code></p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>

<p>  修改small和medium的路径为下载的图标路径</p>
</li>
</ul>
<h1 id="配置hexo本地搜索"><a href="#配置hexo本地搜索" class="headerlink" title="配置hexo本地搜索"></a>配置hexo本地搜索</h1><h2 id="本地搜索的原理"><a href="#本地搜索的原理" class="headerlink" title="本地搜索的原理"></a>本地搜索的原理</h2><p>对于动态网站来说，可以通过 php 实现。但是，Hexo 博客是静态网站，用不了 php。</p>
<p>NexT 主题已经实现这个功能，它用了 Hexo 的拓展包 <code>hexo-generator-searchdb</code>，预先生成了一个文本库 <code>search.xml</code>，然后传到了网站里面。在本地搜索的时候，NexT 直接用 javascript 调用了这个文件，从而实现了静态网站的本地搜索。</p>
<h2 id="设置过程"><a href="#设置过程" class="headerlink" title="设置过程"></a>设置过程</h2><p>安装插件:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save #安装 hexo-generator-search</span><br><span class="line">npm install hexo-generator-searchdb --save #安装 hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p>然后我们修改站点配置<code>_config.yml</code> 文件，添加如下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<ul>
<li>path：索引文件的路径，相对于站点根目录</li>
<li>field：搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面</li>
<li>limit：限制搜索的条目数</li>
</ul>
<p>然后修改主题配置文件next.yml`：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h1 id="配置-hexo-站点的-footer-信息"><a href="#配置-hexo-站点的-footer-信息" class="headerlink" title="配置 hexo 站点的 footer 信息"></a>配置 hexo 站点的 footer 信息</h1><p>底部 <code>footer</code> 可以开关显示 hexo 信息、theme 信息、建站时间等个性化配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span>        <span class="comment"># 建站开始时间</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span>       <span class="comment"># 设置 建站初始时间和至今时间中间的图标，默认是一个&#x27;小人像&#x27;，更改user为heart可以变成一个心</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span> <span class="comment"># 更改图标的颜色，红色为&#x27;#ff0000&#x27;</span></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>     <span class="comment"># 开启hexo驱动</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span>    <span class="comment"># 开启hexo版本号</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>     <span class="comment"># 开启主题驱动</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span>    <span class="comment"># 开启主题版本号</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">Hosted</span> <span class="string">by</span> <span class="string">&lt;a</span> <span class="string">target=&quot;_blank&quot;</span> <span class="string">rel=&quot;external</span> <span class="string">nofollow&quot;</span> <span class="string">href=&quot;https://pages.coding.me&quot;&gt;&lt;b&gt;Coding</span> <span class="string">Pages&lt;/b&gt;&lt;/a&gt;</span> <span class="comment"># 这里的底部标识是为了添加coding page服务时的版权声明 打开注释就可以看到底部有一个 hosted by coding pages</span></span><br></pre></td></tr></table></figure>

<h1 id="首页文章不展示全文显示摘要"><a href="#首页文章不展示全文显示摘要" class="headerlink" title="首页文章不展示全文显示摘要"></a>首页文章不展示全文显示摘要</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">true</span>      <span class="comment"># 点击阅读全文后是否跳到&lt;!--more--&gt;标记处,设为false时点击阅读全文可以从头阅读</span></span><br><span class="line"></span><br><span class="line"><span class="attr">save_scroll:</span> <span class="literal">false</span>        <span class="comment"># 自动保存每篇文章或页面上一次滚动的地方</span></span><br><span class="line"></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span> <span class="comment"># 自动在首页对文章进行摘要描述作为前言文本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">auto_excerpt:</span>   <span class="comment"># 是否自动截取摘要</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># 设置为true则自动截取150字当做首页摘要</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span>   <span class="comment"># 自动截取的字数</span></span><br></pre></td></tr></table></figure>

<p>注意需要在md文件前面加<strong>yaml front matter</strong>中相关元素</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">centos安装redis</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-01 23:47:44</span> </span><br><span class="line"><span class="attr">categories:</span> <span class="string">&quot;redis&quot;</span> </span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line">     <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">标签二</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;centos7 安装redis&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="首页文章属性"><a href="#首页文章属性" class="headerlink" title="首页文章属性"></a>首页文章属性</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">false</span>    <span class="comment"># 设为true 可以一行显示，文章的所有属性</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span>    <span class="comment"># 显示创建时间</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>     <span class="comment"># 显示修改的时间</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span> <span class="comment"># 设true时，如果创建时间和修改时间一样则显示一个时间</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span>    <span class="comment"># 显示分类信息</span></span><br></pre></td></tr></table></figure>

<h1 id="页面阅读统计"><a href="#页面阅读统计" class="headerlink" title="页面阅读统计"></a>页面阅读统计</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>              <span class="comment"># 设true 开启</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>       <span class="comment"># 总阅读人数（uv数）</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span>  <span class="comment"># 阅读总人数的图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>          <span class="comment"># 总阅读次数（pv数）</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span>      <span class="comment"># 阅读总次数的图标</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>           <span class="comment"># 开启内容阅读次数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span>       <span class="comment"># 内容页阅读数的图标</span></span><br></pre></td></tr></table></figure>

<h1 id="字数统计、阅读时长"><a href="#字数统计、阅读时长" class="headerlink" title="字数统计、阅读时长"></a>字数统计、阅读时长</h1><p>首先安装插件：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-<span class="built_in">time</span> --save #运行一次会报错导致配置不生效</span><br><span class="line">npm install hexo-symbols-count-<span class="built_in">time</span> --save</span><br></pre></td></tr></table></figure>

<p>主题配置文件<code>_config.yml</code> 修改如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>  <span class="comment"># false会显示一行</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>  <span class="comment"># 显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span> <span class="comment"># 底部footer是否显示字数统计属性文字</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>                <span class="comment"># 计算字数的一个设置,没设置过</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>              <span class="comment"># 一分钟阅读的字数</span></span><br></pre></td></tr></table></figure>

<p>站点配置文件<code>next.yml</code> 新增如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"> <span class="comment">#文章内是否显示</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line"> <span class="comment"># 网页底部是否显示</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="内容页里的代码块新增复制按钮"><a href="#内容页里的代码块新增复制按钮" class="headerlink" title="内容页里的代码块新增复制按钮"></a>内容页里的代码块新增复制按钮</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>      <span class="comment"># 增加复制按钮的开关</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">false</span> <span class="comment"># 点击复制完后是否显示 复制成功 结果提示</span></span><br></pre></td></tr></table></figure>

<h1 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h1><p>鼠标的点击红心特效<br>在/themes/next/source/js/src下新建文件clicklove.js ，接着把下面的代码拷贝粘贴到 clicklove.js 文件中：7.8 next没有src文件夹，先建一个src文件夹</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">&quot;left:&quot;</span>+d[e].x+<span class="string">&quot;px;top:&quot;</span>+d[e].y+<span class="string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="string">&quot;,&quot;</span>+d[e].scale+<span class="string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">&quot;function&quot;</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;div&quot;</span>);a.className=<span class="string">&quot;heart&quot;</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX-<span class="number">5</span>,<span class="attr">y</span>:e.clientY-<span class="number">5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;style&quot;</span>);a.type=<span class="string">&quot;text/css&quot;</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">&quot;rgb(&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;)&quot;</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">setTimeout</span>(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在\themes\next\layout_layout.swig文件末尾添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/src/clicklove.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224214118.png" alt="image-20210224214118864"></p>
<h1 id="添加网页顶部进度加载条"><a href="#添加网页顶部进度加载条" class="headerlink" title="添加网页顶部进度加载条"></a>添加网页顶部进度加载条</h1><p>在主目录下载安装Progress module，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-pace source&#x2F;lib&#x2F;pace</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="comment">#theme: minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">pace-theme-minimal</span></span><br></pre></td></tr></table></figure>

<h1 id="Footer-页脚设置"><a href="#Footer-页脚设置" class="headerlink" title="Footer / 页脚设置"></a>Footer / 页脚设置</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2015</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="comment">## 图标的一个动画效果，类似于心跳</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="comment"># 图标颜色，可格局需要自行修改</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Powered by Hexo 字样，不喜欢可以设置为 false</span></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 主题字样，不喜欢可以 false</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Beian ICP and gongan information for Chinese users. See: http://www.beian.miit.gov.cn, http://www.beian.gov.cn</span></span><br><span class="line">  <span class="comment"># 备案信息，如果网站有备案号，可以在这里填写备案号</span></span><br><span class="line">  <span class="attr">beian:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">icp:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Creative-Commons-文章版权"><a href="#Creative-Commons-文章版权" class="headerlink" title="Creative Commons / 文章版权"></a>Creative Commons / 文章版权</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span></span><br><span class="line"><span class="comment"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<p>在文章 .md 文件中的上部，添加 copyright: true。</p>
<h1 id="开启文章目录"><a href="#开启文章目录" class="headerlink" title="开启文章目录"></a>开启文章目录</h1><p>修改主题配置文件<strong>next.ym</strong>l</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Table of Contents in the Sidebar</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front-matter.</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="GitHub-Fork-Me"><a href="#GitHub-Fork-Me" class="headerlink" title="GitHub Fork Me"></a>GitHub Fork Me</h1><p>修改主题配置文件<strong>next.ym</strong>l</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/CNRF</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="bookmark"><a href="#bookmark" class="headerlink" title="bookmark"></a>bookmark</h1><p>Bookmark是一个插件，允许用户保存他们的阅读进度。用户只需单击页面左上角的书签图标即可保存滚动位置。当他们下次访问您的博客时，他们可以自动恢复每个页面的最后滚动位置。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bookmark:</span>	</span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize the color of the bookmark.	</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#222&quot;</span>	</span><br><span class="line">  <span class="comment"># If auto, save the reading progress when closing the page or clicking the bookmark-icon.	</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.	</span></span><br><span class="line">  <span class="attr">save:</span> <span class="string">auto</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="添加lazyload"><a href="#添加lazyload" class="headerlink" title="添加lazyload"></a>添加lazyload</h1><p>对于图片进行延迟加载，访问到图片位置时才去请求图片资源，这样可以提高博客的访问速度，节省流量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-jquery-lazyload source&#x2F;lib&#x2F;jquery_lazyload</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="显示当前浏览进度"><a href="#显示当前浏览进度" class="headerlink" title="显示当前浏览进度"></a>显示当前浏览进度</h1><p>修改主题配置文件<strong>next.ym</strong>l</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Scroll percent label in b2t button.# # 是否显示页面浏览百分比</span></span><br><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224220253.png" alt="image-20210224220253001"></p>
<h1 id="支持数学公式"><a href="#支持数学公式" class="headerlink" title="支持数学公式"></a>支持数学公式</h1><p>可能在一些情况下我们需要写一个公式，makdown是支持的，next也支持。</p>
<p>Next 主题提供了两个渲染引擎，分别是 mathjax 和katex，后者相对前者来说渲染速度更快，而且不需要 JavaScript 的额外支持，但后者支持的功能现在还不如前者丰富，具体的对比可以看官方文档：<a href="https://theme-next.org/docs/third-party-services/math-equations%E3%80%82">https://theme-next.org/docs/third-party-services/math-equations。</a></p>
<p>这里选择 mathjax ,通过修改配置即可启用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm uninstall hexo-renderer-marked --save</span><br><span class="line">sudo npm install hexo-renderer-kramed --save</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>注意：使用的时候需要在 <strong>文章开头加上mathjax: true</strong></p>
<h1 id="添加音乐和视频"><a href="#添加音乐和视频" class="headerlink" title="添加音乐和视频"></a>添加音乐和视频</h1><h2 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h2><p>打开网易云，找到你想要添加的歌曲或者歌单，点生成<code>外链播放器</code> 然后复制代码</p>
<p>将代码放到…<code>/themes/hexo-theme-next/layout/_macro/sidebar.swig</code>文件下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--新增163播放器--&gt;</span><br><span class="line">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;298 height&#x3D;52 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;0&amp;id&#x3D;756579097&amp;auto&#x3D;0&amp;height&#x3D;32&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210225094310.png" alt="image-20210225094310438"></p>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>1）直接用 HTML 的标签，写法如下：</p>
<p>复制<br>Your browser does not support the video tag.<br>2）用插件，可支持弹幕，首先在站点文件夹根目录安装插件：</p>
<p>复制<br>npm install hexo-tag-dplayer –save<br>然后文章中的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% dplayer “url&#x3D;https:&#x2F;&#x2F;什么什么什么.mp4” “https:&#x2F;&#x2F;封面图.jpg” “api&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer&#x2F;” “id&#x3D;” “loop&#x3D;false” %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% dplayer &quot;url&#x3D;https:&#x2F;&#x2F;moeplayer.b0.upaiyun.com&#x2F;dplayer&#x2F;hikarunara.mp4&quot; &quot;api&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer3&#x2F;&quot; &quot;addition&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer3&#x2F;v2&#x2F;bilibili?aid&#x3D;120040&quot; &quot;pic&#x3D;https:&#x2F;&#x2F;moeplayer.b0.upaiyun.com&#x2F;dplayer&#x2F;hikarunara.jpg&quot; &quot;id&#x3D;9E2E3368B56CDBB4&quot; &quot;loop&#x3D;yes&quot; &quot;theme&#x3D;#FADFA3&quot; &quot;autoplay&#x3D;false&quot; &quot;token&#x3D;tokendemo&quot; %&#125;  </span><br><span class="line">&#123;% dplayer &#39;url&#x3D;some.mp4&#39; &quot;id&#x3D;someid&quot; &quot;api&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer&#x2F;&quot; &quot;addition&#x3D;&#x2F;some.json&quot; &#39;code&#x3D;player.on(&quot;loadstart&quot;,function()&#123;console.log(&quot;loadstart&quot;)&#125;)&#39; &quot;autoplay&quot; %&#125;</span><br></pre></td></tr></table></figure>

<p>要使用弹幕，必须有api和id两项，并且若使用的是官方的 api 地址（即上面的），id 的值不能与这个列表的值一样。id 的值自己随便取，唯一要求就是前面这点。如果唯一要求难倒了你，可以使用这个工具将一段与众不同的文字?生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。</p>
<p>要使用弹幕，必须有api和id两项，并且若使用的是官方的 api 地址（即上面的），id 的值不能与这个列表的值一样。id 的值自己随便取，唯一要求就是前面这点。如果唯一要求难倒了你，可以使用这个工具将一段与众不同的文字?生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。</p>
<p>当然，这个插件的功能还有很多，可以去 README 和这插件的「母亲」Dplayer 的官方文档看看。</p>
<h1 id="文章末尾统一添加“本文结束”标记"><a href="#文章末尾统一添加“本文结束”标记" class="headerlink" title="文章末尾统一添加“本文结束”标记"></a>文章末尾统一添加“本文结束”标记</h1><p>修改主题配置文件<strong>next.ym</strong>l</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">postBodyEnd:</span> <span class="string">source/_data/post-body-end.swig</span></span><br></pre></td></tr></table></figure>

<p>在路径 /source/_data 下创建/修改 post-body-end.swig文件，并添加以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">&quot;text-align:center;color: #ccc;font-size:14px;&quot;</span>&gt;-------------本文结束&lt;i class=<span class="string">&quot;fa fa-paw&quot;</span>&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h1 id="主题及标题栏背景图"><a href="#主题及标题栏背景图" class="headerlink" title="主题及标题栏背景图"></a>主题及标题栏背景图</h1><p>首先主题配置文件取消注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: <span class="built_in">source</span>/_data/styles.styl</span><br></pre></td></tr></table></figure>

<p>在主目录source/_data创建/修改 <strong>styles.styl</strong>文件，并添加以下内容</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  background: url(https://source.unsplash.com/random/1600x900?wallpapers);//自己喜欢的图片地址</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>:fixed; <span class="comment">//不重复</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;      <span class="comment">//填充</span></span><br><span class="line">  <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//博客内容透明化</span></span><br><span class="line"><span class="comment">//文章内容的透明度设置</span></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单栏的透明度设置</span></span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索框（local-search）的透明度设置</span></span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="修改文章底部的-号的标签，改为图标"><a href="#修改文章底部的-号的标签，改为图标" class="headerlink" title="修改文章底部的#号的标签，改为图标"></a>修改文章底部的#号的标签，改为图标</h1><p>修改模板<code>/themes/next/layout/_macro/post.swig</code></p>
<p>搜索 rel=”tag”，修改此行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;a href&#x3D;&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel&#x3D;&quot;tag&quot;&gt;&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">替换为</span><br><span class="line"> &lt;a href&#x3D;&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel&#x3D;&quot;tag&quot;&gt;&lt;i class&#x3D;&quot;fa fa-tag&quot;&gt;&lt;&#x2F;i&gt; &#123;&#123; tag.name &#125;&#125;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h1 id="修改文章链接"><a href="#修改文章链接" class="headerlink" title="修改文章链接"></a>修改文章链接</h1><p>在做次优化之前，hexo-next文章链接默认的生成规则是：<code>:year/:month/:day/:title</code>，是按照年、月、日、标题来生成的。<br>比如：<code>https://zxiaoxuan.github.io/2019/08/12/hello-world/</code> 这样，如果文章标题是中文的话，URL链接是也会是中文，</p>
<p><strong>安装插件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行此命令可能会不成功，提示你缺少相应的依赖，比如babel-eslint、mini-css-extract-plugin、webpack-cli…<br>使用npm命令安装即可，比如npm install <a href="mailto:&#101;&#115;&#x6c;&#105;&#x6e;&#x74;&#64;&#x34;&#x2e;&#x78;">&#101;&#115;&#x6c;&#105;&#x6e;&#x74;&#64;&#x34;&#x2e;&#x78;</a> babel-eslint@8 –save-dev</p>
</blockquote>
<p>修改根目录站点配置文件<code>config.yml</code>，改为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">	<span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">	<span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>生成的链接将会是这样的(官方样例)：<br><strong>四种可供选择</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;66c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;65535.html</span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;8ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;1690090958.html</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<p>生成完后，原<code>md</code>文件的<code>Front-matter</code> 内会增加<code>abbrlink</code> 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。</p>
<h1 id="设置tag界面彩色标签"><a href="#设置tag界面彩色标签" class="headerlink" title="设置tag界面彩色标签"></a>设置tag界面彩色标签</h1><p>在<code>/themes/next/layout/</code>目录下，新增<code>tag-color.swig</code>文件，加入下方代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">     <span class="keyword">var</span> alltags = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;tag-cloud-tags&#x27;</span>);</span><br><span class="line">     <span class="keyword">var</span> tags = alltags[<span class="number">0</span>].getElementsByTagName(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = tags.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">       <span class="keyword">var</span> r=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">75</span>+<span class="number">130</span>);</span><br><span class="line">       <span class="keyword">var</span> g=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">75</span>+<span class="number">100</span>);</span><br><span class="line">       <span class="keyword">var</span> b=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">75</span>+<span class="number">80</span>);</span><br><span class="line">       tags[i].style.background = <span class="string">&quot;rgb(&quot;</span>+r+<span class="string">&quot;,&quot;</span>+g+<span class="string">&quot;,&quot;</span>+b+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    <span class="comment">/*font-family: Helvetica, Tahoma, Arial;*/</span></span><br><span class="line">    <span class="comment">/*font-weight: 100;*/</span></span><br><span class="line">    text-align: center;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a&#123;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin: 8px 5px 0px 0px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags a:hover&#123;</span><br><span class="line">     box-shadow: 0px 5px 15px 0px rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.4</span>);</span><br><span class="line">     transform: scale(<span class="number">1.1</span>);</span><br><span class="line">     <span class="comment">/*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*/</span></span><br><span class="line">     transition-duration: <span class="number">0.</span>15s;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在/themes/next/layout/page.swig/中引入tag-color.swig：</p>
<p>在下方加上 <code>&#123;% include 'tag-color.swig' %&#125;</code> 代码</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224235234.png" alt="image-20210224235234310"></p>
<h6 id="把标签放到首页"><a href="#把标签放到首页" class="headerlink" title="把标签放到首页"></a>把标签放到首页</h6><p>在路径：<code>/themes/next/layout/index.swig</code> 中<code>&#123;% block content %&#125;</code>下面添加下方代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;tag-cloud&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;tag-cloud-tags&quot; id&#x3D;&quot;tags&quot;&gt;</span><br><span class="line">	&#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &#39;#fff&#39;, end_color: &#39;#fff&#39;&#125;) &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&#123;% include &#39;tag-color.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224235556.png" alt="image-20210224235556099"></p>
<h1 id="归档页面增加月份归档"><a href="#归档页面增加月份归档" class="headerlink" title="归档页面增加月份归档"></a>归档页面增加月份归档</h1><p>在==themes/next/source/css/_common/components/post/post-collapse.styl==新增代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置也月份样式</span></span><br><span class="line">.collection-month &#123; <span class="comment">//属性不一定是这个名字，具体和你在swig文件中为其配置的class值有关，照着它来</span></span><br><span class="line">  font-size: $font-size-largest;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  margin: 60px <span class="number">0</span>;</span><br><span class="line">  position: relative;</span><br><span class="line"></span><br><span class="line">  &amp;::before &#123;</span><br><span class="line">    background: $grey;</span><br><span class="line">    border-radius: <span class="number">50</span>%;</span><br><span class="line">    content: <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    height: 8px;</span><br><span class="line">    left: <span class="number">0</span>;</span><br><span class="line">    margin-left: -4px;</span><br><span class="line">    margin-top: -4px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">50</span>%;</span><br><span class="line">    width: 8px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在==themes/next/layout/_macro/post-collapse.swig==中新增代码，位置如图</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">===========================================</span><br><span class="line">     &#123;%- set current_month = <span class="string">&#x27;0&#x27;</span> %&#125;</span><br><span class="line">===========================================</span><br><span class="line"> &#123;%- set month = date(post.date, <span class="string">&#x27;MMM&#x27;</span>) %&#125;</span><br><span class="line">  &#123;%- <span class="keyword">if</span> month !== current_month %&#125;</span><br><span class="line">    &#123;%- set current_month = month %&#125;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;collection-month&quot;</span>&gt;</span><br><span class="line">      &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;collection-header&quot;</span>&gt;&#123;&#123; current_month &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226093409.png" alt="image-20210226093408957"></p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署第三方主题next 7.8版本</title>
    <url>/posts/d23fb963/</url>
    <content><![CDATA[<h1 id="next-7-8-主题安装"><a href="#next-7-8-主题安装" class="headerlink" title="next 7.8 主题安装"></a>next 7.8 主题安装</h1><p><a href="https://github.com/theme-next/hexo-theme-next/archive/v7.8.0.zip">7.8.0版本下载连接</a></p>
<ol>
<li><p>将下载好的主题文件解压到hexo主目录下的themes文件夹下</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224204119.png" alt="image-20210224204118992"></p>
</li>
<li><p>在主目录的source下新建<strong>_data</strong>目录，将<strong>第三方主题</strong>中的<strong>_config.yml</strong>文件复制到该目录下重命名为next.yml,并修改文件中<strong>override为true</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224203110.png" alt="image-20210224203110673"></p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">override:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主目录的<strong>_config.yml</strong>文件，启用主题</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224203236.png" alt="image-20210224203236580"></p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成next主题开启的界面</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224203417.png"></p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo new page home</span><br><span class="line">hexo new page archives</span><br><span class="line">hexo new page about</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page commonweal</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>win10的typora配置gitee云图床</title>
    <url>/posts/fd71e1c8/</url>
    <content><![CDATA[<h1 id="相关准备准备"><a href="#相关准备准备" class="headerlink" title="相关准备准备"></a>相关准备准备</h1><ul>
<li><a href="https://www.typora.io/">Typora</a></li>
<li><a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a></li>
<li>gitee/github账号</li>
</ul>
<h1 id="gitee-github相关配置"><a href="#gitee-github相关配置" class="headerlink" title="gitee/github相关配置"></a>gitee/github相关配置</h1><ol>
<li><p>新建仓库（<strong>一定要是公开的，不然md到时候无法访问</strong>）</p>
</li>
<li><p>生成Token ，<strong>保存Token</strong></p>
<p> 在自已的用户中心生成私人令牌</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224175635.png" alt="image-20210224175635044"></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224175714.png" alt="image-20210224175714200"></p>
</li>
</ol>
<h1 id="PicGO相关配置"><a href="#PicGO相关配置" class="headerlink" title="PicGO相关配置"></a>PicGO相关配置</h1><h2 id="GitHub设置"><a href="#GitHub设置" class="headerlink" title="GitHub设置"></a>GitHub设置</h2><p><a href="https://blog.csdn.net/yefcion/article/details/88412025">原文地址</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224180016.png" alt="image-20210224180016463"></p>
<ul>
<li>仓库名 即你的仓库名</li>
<li>分支名 默认 <code>master</code></li>
<li>Token 就是刚刚复制的那一串字符</li>
<li>存储路径 这个可以填也可以不填，填了的话图片就上传到 git 中 <code>data</code> 这个文件夹</li>
<li>域名 <code>https://raw.githubusercontent.com/yefcion/cloudimg/master</code>这个要改一下 格式 <code>https://raw.githubusercontent.com/[username]/[仓库名]/master</code></li>
</ul>
<h2 id="Gitee设置"><a href="#Gitee设置" class="headerlink" title="Gitee设置"></a>Gitee设置</h2><ol>
<li><p>下载插件gitee-uploader</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224180247.png" alt="image-20210224180247392"></p>
</li>
<li><p>设置Gitee并设置为默认图床（Github是外网，可能会慢，故选择gitee为默认）</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224195106.png" alt="image-20210224195106781"></p>
</li>
</ol>
<h2 id="PicGO设置"><a href="#PicGO设置" class="headerlink" title="PicGO设置"></a>PicGO设置</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224195211.png" alt="image-20210224195211867"></p>
<h2 id="Typora设置"><a href="#Typora设置" class="headerlink" title="Typora设置"></a>Typora设置</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224195433.png" alt="image-20210224195433511"></p>
]]></content>
      <categories>
        <category>Typora</category>
        <category>Gitee</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Gitee</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>win10的搭建hexo博客</title>
    <url>/posts/1bab7c20/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p><strong>安装前准备</strong></p>
<ul>
<li>git</li>
<li>Nodejs</li>
</ul>
<h1 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h1><ol>
<li><p>首先配置npm的<strong>淘宝源</strong>,安装完成后可通过npm info hexo查看是否配置淘宝源成功</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装hexo</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定安装的hexo目录</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo init test</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> test     </span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试安装是否成功</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean      #清除缓存</span><br><span class="line">hexo g      #生成静态网页</span><br><span class="line">hexo s      #启动本地服务</span><br></pre></td></tr></table></figure>

<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224200606.png" alt="image-20210224200605821"></p>
</li>
</ol>
<h1 id="Gtihub相关配置"><a href="#Gtihub相关配置" class="headerlink" title="Gtihub相关配置"></a>Gtihub相关配置</h1><p>New repository创建新仓库，仓库名应该为：<strong>用户名</strong>.<a href="https://link.zhihu.com/?target=http://github.io">http://github.io</a> 这个<strong>用户名</strong>使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224200752.png" alt="image-20210224200752872"></p>
<h1 id="hexo配置远程部署"><a href="#hexo配置远程部署" class="headerlink" title="hexo配置远程部署"></a>hexo配置远程部署</h1><p>修改根目录下的<strong>_config.yml</strong> 文件中配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/CNRF/CNRF.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>使用相关命令进行部署</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d  # 第一次部署会提示输入github的账号和密码</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>redis入门</title>
    <url>/posts/eca8b4a8/</url>
    <content><![CDATA[<h4 id="1-redis相关介绍"><a href="#1-redis相关介绍" class="headerlink" title="1.redis相关介绍"></a>1.redis相关介绍</h4><p><a href="http://redis.cn/">redis中文网</a></p>
<h5 id="1-1-redis的介绍"><a href="#1-1-redis的介绍" class="headerlink" title="1.1 redis的介绍"></a>1.1 redis的介绍</h5><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113311.png" alt="image-20210211203040301"></p>
<h5 id="1-2-redis和memcached的区别"><a href="#1-2-redis和memcached的区别" class="headerlink" title="1.2  .redis和memcached的区别"></a>1.2  .redis和memcached的区别</h5><p>redis和memcached相比本质是解耦，用大数据说法是计算向数据移动</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113409.png" alt="image-20210218095611832"></p>
<h5 id="1-3-liunx下常见的redis命令"><a href="#1-3-liunx下常见的redis命令" class="headerlink" title="1.3 . liunx下常见的redis命令"></a>1.3 . liunx下常见的redis命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#连接redis</span><br><span class="line">redis-cli</span><br><span class="line">#连接redis是6379端口的8号库 指定库(不同库数据不可见)</span><br><span class="line">redis-cli -p 6379 -n 8</span><br><span class="line">#连接redis后使用help进行查询</span><br><span class="line">help </span><br></pre></td></tr></table></figure>

<h4 id="2-redis相关数据的操作常见命令"><a href="#2-redis相关数据的操作常见命令" class="headerlink" title="2.redis相关数据的操作常见命令"></a>2.redis相关数据的操作常见命令</h4><p>在redis客户端中使用help命令进行相关查询相关命令</p>
<h5 id="2-1-Strings类型"><a href="#2-1-Strings类型" class="headerlink" title="2.1 Strings类型"></a>2.1 Strings类型</h5><p><a href="https://redis.io/commands#string">Strings 数据操作相关文档</a></p>
<h6 id="2-1-1-查看string类型帮助命令"><a href="#2-1-1-查看string类型帮助命令" class="headerlink" title="2.1.1 查看string类型帮助命令"></a>2.1.1 查看string类型帮助命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help @string</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113419.png" alt="image-20210219155031906"></p>
<h6 id="2-1-2-string数据类型及相关的应用场景"><a href="#2-1-2-string数据类型及相关的应用场景" class="headerlink" title="2.1.2  string数据类型及相关的应用场景"></a>2.1.2  string数据类型及相关的应用场景</h6><ol>
<li><p>字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set设置key的value</span><br><span class="line">set k1 ooxx nx  （带nx，xx可用在分布式锁中）</span><br><span class="line">set k1 ooxx xx</span><br><span class="line">#mset批量设置</span><br><span class="line">mset k3 k3mest k4 k4mest</span><br><span class="line">#get获取key的value</span><br><span class="line">get k1</span><br><span class="line">#mget批量获取</span><br><span class="line">mget k3 k4</span><br><span class="line">#APPEND在字符串后面追加</span><br><span class="line">append k1 &quot; world&quot;</span><br><span class="line">#GETRANGE获取指定范围数据</span><br><span class="line">getrange k1 5 10</span><br><span class="line">#strlen获取字符串长度</span><br><span class="line">strlen k1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113426.png" alt="image-20210219155108071"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113517.png" alt="image-20210219160021217"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113555.png" alt="image-20210219160343269"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113600.png" alt="image-20210219160751857"></p>
</li>
<li><p>数值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">incr  将value的整数型+1</span><br><span class="line">incrby 将value的整数型加指定数</span><br><span class="line">decr </span><br><span class="line">descby</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>  <strong>应用场景</strong> ： 抢购，秒杀，详情页，点赞，评论规避并发下，对数据库的事务操作完全由redis内存操作代替，避免因数据库事务导致响应时间超时，<strong>但在银行等金融涉及金额不要放在redis中进行相关计算</strong></p>
<ol start="3">
<li><p>bitmap</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setbit  &#x2F;&#x2F;设置bit数值</span><br><span class="line">bitcount  </span><br><span class="line">bitpos</span><br><span class="line">bitop</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>应用场景</strong> ：</p>
<pre><code>1. 统计用户登陆天数

    方案：用户id为key，设计长度为9bit的数据即可存储用户当年所有登陆天数数据，当天登陆为1，即可统计指定时间段的相关数据

2. 统计当天所有用户登陆情况

    方案：日期为Key，设计一个合适长度的数据存储，每一位对应一位客户，登陆则为1，统计时直接进行二进制与运算，则可以去重，统计那些用户登陆
</code></pre>
<h5 id="2-2-Lists类型"><a href="#2-2-Lists类型" class="headerlink" title="2.2  Lists类型"></a>2.2  Lists类型</h5><h6 id="2-2-1-Lists常见命令"><a href="#2-2-1-Lists常见命令" class="headerlink" title="2.2.1 Lists常见命令"></a>2.2.1 Lists常见命令</h6><p><a href="https://redis.io/commands#list">Lists数据相关操作命令</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#lpush 存放顺序为f e d c b a</span><br><span class="line">lpush k1 a b c d e f</span><br><span class="line">#rpush 存放顺序为a b c d e f</span><br><span class="line">rpush k2 a b c d e f</span><br><span class="line">#取数据 lpop</span><br><span class="line">lpop k1 </span><br><span class="line">#lrange按照范围取</span><br><span class="line">lrange k1 0 -1（取全部）</span><br><span class="line">#lindex</span><br><span class="line">#lset</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113620.png" alt="image-20210219205233457"></p>
<h6 id="2-2-2应用场景"><a href="#2-2-2应用场景" class="headerlink" title="2.2.2应用场景"></a>2.2.2应用场景</h6><ol>
<li>使用lpush模拟栈，后进先出</li>
<li>使用rpush模拟队列，先进先出（买票排队问题）</li>
<li>lindex模拟数组，直接根据下标取相关数据</li>
<li>blpop模拟阻塞单播队列（blpop会让对应key有则弹出value，没有会阻塞等待key有值，并且只会弹出一次，当多个客户端同时对一个key使用blpop则可以实现阻塞单播）</li>
</ol>
<h5 id="2-3-hashes类型"><a href="#2-3-hashes类型" class="headerlink" title="2.3 hashes类型"></a>2.3 hashes类型</h5><p>类似java中的hashmap（key，hashmap（key，value））。这里面第一个key是hashes的key，hashmap（key，value）才是value</p>
<h6 id="2-3-1-hashes常见命令"><a href="#2-3-1-hashes常见命令" class="headerlink" title="2.3.1 hashes常见命令"></a>2.3.1 hashes常见命令</h6><p><a href="https://redis.io/commands#hash">hashes常见的命令</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdel</span><br><span class="line">hget</span><br><span class="line">hset</span><br><span class="line">hlen</span><br><span class="line">hincrbyfloat</span><br></pre></td></tr></table></figure>

<h6 id="2-3-2-应用场景："><a href="#2-3-2-应用场景：" class="headerlink" title="2.3.2 应用场景："></a>2.3.2 应用场景：</h6><ol>
<li>对员工薪水进行统计</li>
</ol>
<h5 id="2-4-sets数据类型"><a href="#2-4-sets数据类型" class="headerlink" title="2.4 sets数据类型"></a>2.4 sets数据类型</h5><p>Redis Set 是 String 的无序排列。<code>SADD</code> 指令把新的元素添加到 set 中。对 set 也可做一些其他的操作，比如测试一个给定的元素是否存在，对不同 set 取交集，并集或差，等等。</p>
<h6 id="2-4-1常见命令"><a href="#2-4-1常见命令" class="headerlink" title="2.4.1常见命令"></a>2.4.1常见命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sadd &#x2F;&#x2F;添加元素</span><br><span class="line">sadd myset 1 2 3</span><br><span class="line">smembers &#x2F;&#x2F;读取集合元素</span><br><span class="line">smembers myset</span><br><span class="line">sismember &#x2F;&#x2F;判断元素存在</span><br><span class="line">sismember myset 3 &#x2F;&#x2F;存在返回1，不存在为0</span><br><span class="line"> SINTER  &#x2F;&#x2F;获取多个集合的交集</span><br><span class="line"> SUNIONSTORE  &#x2F;&#x2F;多个集合取并集</span><br></pre></td></tr></table></figure>

<h6 id="2-4-2-应用场景"><a href="#2-4-2-应用场景" class="headerlink" title="2.4.2 应用场景"></a>2.4.2 应用场景</h6><ol>
<li><p>公平抽奖(随机事件) ：  SRANDMEMBER key count（用户作为value）</p>
<p> ​                        正数：取出一个去重的结果集（不能超过已有集）</p>
<p> ​                        负数：取出一个带重复的结果集，一定满足你要的数量如果：</p>
<p> ​                        0，不返回</p>
</li>
</ol>
<h5 id="2-5-sorted-sets数据类型"><a href="#2-5-sorted-sets数据类型" class="headerlink" title="2.5 sorted sets数据类型"></a>2.5 sorted sets数据类型</h5><h6 id="2-5-1-常见命令"><a href="#2-5-1-常见命令" class="headerlink" title="2.5.1 常见命令"></a>2.5.1 常见命令</h6><p><a href="https://redis.io/commands#sorted_set">sorted sets常见命令</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zadd</span><br><span class="line">zmenmber</span><br><span class="line">zinter</span><br><span class="line">zscore &#x2F;&#x2F;按照什么排序</span><br></pre></td></tr></table></figure>

<h6 id="2-5-2-排序底层实现"><a href="#2-5-2-排序底层实现" class="headerlink" title="2.5.2 排序底层实现"></a>2.5.2 排序底层实现</h6><p>通过Skip list（跳跃表）实现增删查改</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113634.png" alt="image-20210220102659707"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>安装redis出现的问题</title>
    <url>/posts/5e07a887/</url>
    <content><![CDATA[<p><strong>操作系统为centOs7  redis为6.0.8版本</strong></p>
<h3 id="1-当Make命令提示无cc环境时需要进行安装Gcc安装包重新安装，同时需要执行make-distclean清理相关文件，再执行make命令"><a href="#1-当Make命令提示无cc环境时需要进行安装Gcc安装包重新安装，同时需要执行make-distclean清理相关文件，再执行make命令" class="headerlink" title="1.当Make命令提示无cc环境时需要进行安装Gcc安装包重新安装，同时需要执行make distclean清理相关文件，再执行make命令"></a>1.当Make命令提示无cc环境时需要进行安装Gcc安装包重新安装，同时需要执行make distclean清理相关文件，再执行make命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一般错误为gcc套装错误</span><br><span class="line">yum install cpp</span><br><span class="line">yum install binutils</span><br><span class="line">yum install glibc</span><br><span class="line">yum install glibc-kernheaders</span><br><span class="line">yum install glibc-common</span><br><span class="line">yum install glibc-devel</span><br><span class="line">yum install gcc</span><br><span class="line">yum install make</span><br><span class="line">&#x2F;&#x2F;清理错误文件</span><br><span class="line">make distclean</span><br><span class="line">&#x2F;&#x2F;重新安装</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/m0_37952284/article/details/109012324">server.c:5307:31: 错误:‘struct redisServer’没有名为‘server_xxx’的成员</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113217.png" alt="image-20201103103148896"></p>
<ol start="2">
<li><h3 id="下载了redis版本6-0-6，正常解压，Centos用的7-6，make安装时报错"><a href="#下载了redis版本6-0-6，正常解压，Centos用的7-6，make安装时报错" class="headerlink" title="下载了redis版本6.0.6，正常解压，Centos用的7.6，make安装时报错:"></a>下载了redis版本6.0.6，正常解压，Centos用的7.6，make安装时报错:</h3></li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113232.png" alt="image-20201103104749570"></p>
<p>原因是redies用了c语言编写，centos7.6应该也有以下版本，默认安装的gcc4.8.5版本较低，需要在5.3以上版本，现更换为9.3，先查看当前版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<p>开始更换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>重连shell</strong>(不重连gcc版本不变)，重新make，即成功了</p>
<h3 id="3-安装Redis-6-0-6-install-server-sh报错"><a href="#3-安装Redis-6-0-6-install-server-sh报错" class="headerlink" title="3.安装Redis 6.0.6 ./install_server.sh报错"></a>3.安装Redis 6.0.6 ./install_server.sh报错</h3><p>产生原因:gcc9版本校验更加严格导致</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113249.png" alt="image-20201103111330639"></p>
<p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi .&#x2F;install_server.sh</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113254.png" alt="image-20201103111506170"></p>
<p><strong>注释掉代码</strong>重新运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#bail if this system is managed by systemd</span><br><span class="line">#_pid_1_exe&#x3D;&quot;$(readlink -f &#x2F;proc&#x2F;1&#x2F;exe)&quot;</span><br><span class="line">#if [ &quot;$&#123;_pid_1_exe##*&#x2F;&#125;&quot; &#x3D; systemd ]</span><br><span class="line">#then</span><br><span class="line">#       echo &quot;This systems seems to use systemd.&quot;</span><br><span class="line">#       echo &quot;Please take a look at the provided example service unit files in this directory, and adapt and install them. Sorry!&quot;</span><br><span class="line">#       exit 1</span><br><span class="line">#fi</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装redis</title>
    <url>/posts/725846d4/</url>
    <content><![CDATA[<p><strong>操作系统为centOS7  redis为6.0.8版本</strong></p>
<ol>
<li>安装wget命令 </li>
</ol>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure>

<p>   <img src="https://gitee.com/CNRF/image/raw/master/img/20210223112933.png" alt="image-20201026172631943"></p>
<ol start="2">
<li><p>安装GCC包（redis是c语言编写，liunx需要安装相关软件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223112947.png" alt="image-20201026172608587"></p>
</li>
<li><p>在指定目录获取安装包（或者下载之后移动到指定目录  ）</p>
<p><a href="https://redis.io/download%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%85%B3%E7%89%88%E6%9C%AC%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8B%E8%BD%BD6.0%E7%89%88%E6%9C%AC">https://redis.io/download获取相关版本连接，这里下载6.0版本</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-6.0.8.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113024.png" alt="image-20201026172901823"></p>
</li>
<li><p>解压gz包（下载的是源码）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xf redis-6.0.8.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据解压包中文件的REDME.md文档进行相关操作（重要：安装其他软件同理）</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113031.png" alt="image-20201103102727621"></p>
</li>
<li><p>使用make相关命令进行安装程序</p>
</li>
<li><p>安装可执行到指定目录（分离源码）</p>
<p>查看/home/redis-6.0.8/INSTALL，根据文档安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install PREFIX&#x3D;&#x2F;home&#x2F;redis6</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册redis为服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;执行vi &#x2F;etc&#x2F;profile命令，在文件最后新增内容</span><br><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line">&#x2F;&#x2F;REDIS_HOME的路径为第七步的安装路径</span><br><span class="line">export REDIS_HOME&#x3D;&#x2F;home&#x2F;redis6</span><br><span class="line">export PATH&#x3D;$PATH:$REDIS_HOME&#x2F;bin</span><br><span class="line">&#x2F;&#x2F;使配置文件生效</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">&#x2F;&#x2F;验证是否添加成功</span><br><span class="line">echo $PATH</span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">&#x2F;home&#x2F;redis-6.0.8&#x2F;utils&#x2F;install_server.sh脚本注册为服务</span><br><span class="line">.&#x2F;install_server.sh</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113126.png" alt="image-20201103103148896"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113145.png" alt="image-20201103112714896">   </p>
<ol start="9">
<li><p>修改配置文件，安装需求修改相关配置</p>
<p>redis常见配置参见<a href="https://blog.csdn.net/suprezheng/article/details/90679790">https://blog.csdn.net/suprezheng/article/details/90679790</a></p>
</li>
<li><p>将redis_6379(根据生成的配置文件名称)设置为开启</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;init.d</span><br><span class="line">  #init.d没有redis_6379文件的可以在源文件中找到redis.conf文件进行修改</span><br><span class="line">  chkconfig --add redis_6379</span><br><span class="line">  chkconfig redis_6379 on</span><br><span class="line">  #查看开机自启的列表</span><br><span class="line">  chkconfig --list</span><br><span class="line">  #重启redis</span><br><span class="line">  service redis_6379 restart</span><br><span class="line">  #手动启用</span><br><span class="line">  redis-server &#x2F;etc&#x2F;redis&#x2F;6379.conf</span><br><span class="line">  chkconfig --list的参数意义</span><br><span class="line">  1表示：单用户模式</span><br><span class="line">  2表示：无网络连接的多用户命令行模式</span><br><span class="line">  3表示：有网络连接的多用户命令行模式</span><br><span class="line">  4表示：不可用</span><br><span class="line">  5表示：带图形界面的多用户模式</span><br><span class="line">  6表示：重新启动</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPoolExecutor源码解析</title>
    <url>/posts/ca94e89b/</url>
    <content><![CDATA[<h1 id="ThreadPoolExecutor源码解析"><a href="#ThreadPoolExecutor源码解析" class="headerlink" title="ThreadPoolExecutor源码解析"></a>ThreadPoolExecutor源码解析</h1><h3 id="1、常用变量的解释"><a href="#1、常用变量的解释" class="headerlink" title="1、常用变量的解释"></a>1、常用变量的解释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. `ctl`，可以看做一个int类型的数字，高3位表示线程池状态，低29位表示worker数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 2. `COUNT_BITS`，`Integer.SIZE`为32，所以`COUNT_BITS`为29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 3. `CAPACITY`，线程池允许的最大线程数。1左移29位，然后减1，即为 2^29 - 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">// 4. 线程池有5种状态，按大小排序如下：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 5. `runStateOf()`，获取线程池状态，通过按位与操作，低29位将全部变成0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 6. `workerCountOf()`，获取线程池worker数量，通过按位与操作，高3位将全部变成0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 7. `ctlOf()`，根据线程池状态和线程池worker数量，生成ctl值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don&#x27;t require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 8. `runStateLessThan()`，线程池状态小于xx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9. `runStateAtLeast()`，线程池状态大于等于xx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 空指针校验</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="comment">// 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中</span></span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、提交执行task的过程"><a href="#3、提交执行task的过程" class="headerlink" title="3、提交执行task的过程"></a>3、提交执行task的过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// worker数量比核心线程数小，直接创建worker执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// worker数量超过核心线程数，任务直接进入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作。</span></span><br><span class="line">        <span class="comment">// 这儿为什么需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 这儿为什么需要判断0值，主要是在线程池构造方法中，核心线程数允许为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务。</span></span><br><span class="line">    <span class="comment">// 这儿有3点需要注意：</span></span><br><span class="line">    <span class="comment">// 1. 线程池不是运行状态时，addWorker内部会判断线程池状态</span></span><br><span class="line">    <span class="comment">// 2. addWorker第2个参数表示是否创建核心线程</span></span><br><span class="line">    <span class="comment">// 3. addWorker返回false，则说明任务执行失败，需要执行reject操作</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、addworker源码解析"><a href="#4、addworker源码解析" class="headerlink" title="4、addworker源码解析"></a>4、addworker源码解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 外层自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个条件写得比较难懂，我对其进行了调整，和下面的条件等价</span></span><br><span class="line">        <span class="comment">// (rs &gt; SHUTDOWN) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; firstTask != null) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于SHUTDOWN时，直接返回false</span></span><br><span class="line">        <span class="comment">// 2. 线程池状态等于SHUTDOWN，且firstTask不为null，直接返回false</span></span><br><span class="line">        <span class="comment">// 3. 线程池状态等于SHUTDOWN，且队列为空，直接返回false</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// worker数量超过容量，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 使用CAS的方式增加worker数量。</span></span><br><span class="line">            <span class="comment">// 若增加成功，则直接跳出外层循环进入到第二部分</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 线程池状态发生变化，对外层循环进行自旋</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 其他情况，直接内层循环进行自旋即可</span></span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// worker的添加必须是串行的，因此需要加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">// 这儿需要重新检查线程池状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// worker已经调用过了start()方法，则不再创建worker</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// worker创建并添加到workers成功</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 更新`largestPoolSize`变量</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动worker线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// worker线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown相关操作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、线程池worker任务单元"><a href="#5、线程池worker任务单元" class="headerlink" title="5、线程池worker任务单元"></a>5、线程池worker任务单元</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 这儿是Worker的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、核心线程执行逻辑-runworker"><a href="#6、核心线程执行逻辑-runworker" class="headerlink" title="6、核心线程执行逻辑-runworker"></a>6、核心线程执行逻辑-runworker</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 调用unlock()是为了让外部可以中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 这个变量用于判断是否进入过自旋（while循环）</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这儿是自旋</span></span><br><span class="line">        <span class="comment">// 1. 如果firstTask不为null，则执行firstTask；</span></span><br><span class="line">        <span class="comment">// 2. 如果firstTask为null，则调用getTask()从队列获取任务。</span></span><br><span class="line">        <span class="comment">// 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这儿对worker进行加锁，是为了达到下面的目的</span></span><br><span class="line">            <span class="comment">// 1. 降低锁范围，提升性能</span></span><br><span class="line">            <span class="comment">// 2. 保证每个worker执行的任务是串行的</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 如果线程池正在停止，则对当前线程进行中断操作</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="comment">// 执行任务，且在执行前后通过`beforeExecute()`和`afterExecute()`来扩展其功能。</span></span><br><span class="line">            <span class="comment">// 这两个方法在当前类里面为空实现。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 帮助gc</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 已完成任务数加一 </span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋操作被退出，说明线程池正在结束</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/posts/de7c53fe/</url>
    <content><![CDATA[<h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a><strong>Executor框架</strong></h3><p>线程池就是<strong>线程的集合</strong>，线程池集中管理线程，以实现线程的重用，降低资源消耗，提高响应速度等。线程用于执行异步任务，单个的线程既是工作单元也是执行机制，从JDK1.5开始，为了把工作单元与执行机制分离开，Executor框架诞生了，他是一个用于统一创建与运行的接口。<strong>Executor框架实现的就是线程池的功能</strong></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114336.png" alt="img"></p>
<p>说明：</p>
<ul>
<li><strong>Executor</strong> 执行器接口，该接口定义执行Runnable任务的方式。</li>
<li><strong>ExecutorService</strong> 该接口定义提供对Executor的服务。</li>
<li><strong>ScheduledExecutorService</strong> 定时调度接口。</li>
<li><strong>AbstractExecutorService</strong> 执行框架抽象类。</li>
<li><strong>ThreadPoolExecutor</strong> JDK中线程池的具体实现。</li>
<li><strong>Executors</strong> 线程池工厂类。</li>
</ul>
<h3 id="ThreadPoolExecutor（线程池类）"><a href="#ThreadPoolExecutor（线程池类）" class="headerlink" title="ThreadPoolExecutor（线程池类）"></a>ThreadPoolExecutor（<strong>线程池类</strong>）</h3><p>线程池是一个复杂的任务调度工具，它涉及到任务、线程池等的生命周期问题。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                         TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                         RejectedExecutionHandler handler)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线程池的七个参数"><a href="#线程池的七个参数" class="headerlink" title="线程池的七个参数"></a>线程池的七个参数</h4><ul>
<li><p>corePoolSize：核心线程数。</p>
</li>
<li><p>maximumPoolSize：最大线程数。</p>
</li>
<li><p>keepAliveTime：线程存活时间。当线程数大于core数，那么超过该时间的线程将会被终结。</p>
</li>
<li><p>unit：keepAliveTime的单位。java.util.concurrent.TimeUnit类存在静态静态属性： NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS</p>
</li>
<li><p>workQueue：Runnable的阻塞队列。若线程池已经被占满，则该队列用于存放无法再放入线程池中的Runnable。</p>
</li>
<li><p>threadFactory:创建一个新线程时使用的工厂，可以用来设定线程名、是否为守护线程等等</p>
</li>
<li><p>handler：拒绝策略</p>
</li>
</ul>
<h4 id="五种线程池"><a href="#五种线程池" class="headerlink" title="五种线程池"></a>五种线程池</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   ExecutorService threadPool = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//有缓冲的线程池，线程数 JVM 控制，线程太多会导致CUP一直进行切换，阻塞队列使用的是SynchronousQueue(容量为0),不希望任务堆积</span></span><br><span class="line">   threadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//固定大小的线程池，核心线程数和最大线程数保持一致，希望以恒定的处理速度使用线程</span></span><br><span class="line">   threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//可创建最大线程为int最大值，线程太多会导致CPU频繁切换</span></span><br><span class="line">   threadPool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//单线程的线程池，只有一个线程在工作，队列长度为int最大值，可能会堆积大量请求</span></span><br><span class="line">   threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//默认线程池，可控制参数比较多 </span></span><br><span class="line">   threadPool = <span class="keyword">new</span> ThreadPoolExecutor();</span><br><span class="line"><span class="comment">// 基于工作窃取算法，其中任务可以生成其他较小的任务，这些任务将添加到并行处理线程的队列中。如果一个线程完成了工作并且无事可做，则可以从另一线程的队列中“窃取”工作</span></span><br><span class="line">   threadPool = Executors.newWorkStealingPool();</span><br></pre></td></tr></table></figure>



<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">null</span>;</span><br><span class="line">workQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);<span class="comment">//基于数组的先进先出队列，有界</span></span><br><span class="line">workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();<span class="comment">//基于链表的先进先出队列，无界</span></span><br><span class="line">workQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();<span class="comment">//无缓冲的等待队列，无界</span></span><br></pre></td></tr></table></figure>



<h4 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h4><blockquote>
<p>阿里出品的规范不建议使用这些拒绝策略，建议自定义策略（可保存到redis，kafaka或日志文件等中）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RejectedExecutionHandler rejected = <span class="keyword">null</span>;</span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy();<span class="comment">//默认，队列满了丢任务抛出异常</span></span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy();<span class="comment">//队列满了丢任务不异常</span></span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy();<span class="comment">//将最早进入队列的任务删，之后再尝试加入队列</span></span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy();<span class="comment">//如果添加到线程池失败，那么主线程会自己去执行该任务</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的容器</title>
    <url>/posts/5c0b6c7e/</url>
    <content><![CDATA[<h1 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h1><p>Collection</p>
<ul>
<li><p>List</p>
<ul>
<li>Vector</li>
<li>ArrayList</li>
<li>LinkList</li>
<li>CopyOnWriteList</li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li><p>HashSet</p>
<ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li><p>SortedSet</p>
<ul>
<li>TreeSet</li>
</ul>
</li>
<li><p>EnumSet</p>
</li>
<li><p>CopyOnwriteArraySet</p>
</li>
<li><p>ConcurrentSkipListSet</p>
</li>
</ul>
</li>
<li><p>Queue（JDK1.5新增，对多线程友好，多线程优先使用）</p>
<ul>
<li><p>阻塞队列（BlockingQueue）</p>
<ul>
<li><p>TransferQueue</p>
</li>
<li><p>PriorityBlockingQueue</p>
</li>
<li><p>ArrayBlockingQueue</p>
</li>
<li><p>LinkedBlockingQueue</p>
</li>
<li><p>SynchonousQueue</p>
</li>
<li><p>DelayQueue</p>
</li>
</ul>
</li>
<li><p>非阻塞队列</p>
<ul>
<li>Deque（双端队列，两边都可以进出）</li>
<li>ConcurrentLinkedQueue</li>
<li>priorityQueue</li>
</ul>
</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li>HashTable</li>
<li>HashMap<ul>
<li>LinkHashMap</li>
<li>ConcurrentHashMap</li>
<li>TreeMap</li>
<li>ConcurrentSkipListMap</li>
<li>WeakHashMap</li>
<li>IdentityHashMap</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114233.gif" alt="img"></p>
<h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>​    List是用于存放多个元素，能够维护元素的次序，并且允许元素的重复</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ArrayList是最常用的List实现类，内部是通过<strong>数组</strong>实现的，它允许对元素进行<strong>快速随机访问</strong>。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有<strong>数组的数据复制到新的存储空间</strong>中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它<strong>适合随机查找和遍历</strong>，<strong>不适合插入和删除</strong></p>
<ul>
<li>继承了AbstractList,此类提供 List 接口的骨干实现，以最大限度地减少实现”随机访问”数据存储（如数组）支持的该接口所需的工作.对于连续的访问数据（如链表），应优先使用 AbstractSequentialList，而不是此类。</li>
<li>实现了List接口,意味着ArrayList元素是有序的,可以重复的,<strong>可以有null元素</strong>的集合.</li>
<li>实现了RandomAccess接口标识着其支持随机快速访问,实际上,我们查看RandomAccess源码可以看到,其实里面什么都没有定义.因为ArrayList底层是数组,那么随机快速访问是理所当然的,访问速度O(1)。</li>
<li>实现了Cloneable接口,标识着可以它可以被复制.注意,ArrayList里面的clone()复制其实是浅复制。</li>
<li>实现了Serializable 标识着集合可被序列化</li>
</ul>
<h3 id="ArrayList的属性"><a href="#ArrayList的属性" class="headerlink" title="ArrayList的属性"></a>ArrayList的属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//JDK1.8版本</span></span><br><span class="line">    <span class="comment">//序列化ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="comment">//默认的数组大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 一个空对象，如果使用默认构造函数创建，则默认对象内容默认是该值 </span></span><br><span class="line">    <span class="comment">//如果使用的是默认的构造函数创建的对象，则返回DEFAULTCAPACITY_EMPTY_ELEMENTDATA；如果是用户在指定容量的大小为0的时候返回的，则返回的是EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 当前数据对象存放地方，当前对象不参与序列化(主要是关键字transient起作用的)  </span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    <span class="comment">//当前数组长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//数组最大程度为2^32-8为2147483639</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList的相关方法"><a href="#ArrayList的相关方法" class="headerlink" title="ArrayList的相关方法"></a>ArrayList的相关方法</h3><h4 id="ArrayList的构造方法"><a href="#ArrayList的构造方法" class="headerlink" title="ArrayList的构造方法"></a>ArrayList的构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造 </span></span><br><span class="line"><span class="comment">//创建的时候elementData长度为0.当进行第一次add之后，会变成默认的长度10</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="comment">//传入参数，则代表指定ArrayList的初始数组长度，传入参数如果是大于等于0，则使用用户的参数初始化，如果用户传入的参数小于0，则抛出异常</span></span><br><span class="line"><span class="comment">//当</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+  </span><br><span class="line">                                           initialCapacity);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//将Collection&lt;T&gt; c 中保存的数据，首先转换成数组形式（toArray（）方法），然后判断当前数组长度是否为0，为 0 则只想默认数组（EMPTY_ELEMENTDATA）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：此时我们创建的ArrayList对象中的elementData中的长度是0，size是0,<strong>当进行第一次add的时候，elementData将会变成默认的长度：10.</strong></p>
<ul>
<li>ArrayList（）：指向 <strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong>，当列表使用的时候，才会进行初始化，会通过判断是不是 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 这个对象而设置数组默认大小。</li>
<li>ArrayList(int initialCapacity)：当 initialCapacity &gt;0 的时候，设置该长度。如果 initialCapacity =0，则指向 <strong>EMPTY_ELEMENTDATA</strong> 在使用的时候，并不会设置默认数组长度 。</li>
<li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA 与 EMPTY_ELEMENTDATA 的本质区别就在于，会不会设置默认的数组长度</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//ArrayList的size方法获取的是list中的元素个数</span></span><br><span class="line"> <span class="comment">//通过反射获取list的长度</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListCapacity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getArrayListCapacity</span><span class="params">(ArrayList&lt;?&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        Class&lt;ArrayList&gt; arrayListClass = ArrayList.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取 elementData 字段</span></span><br><span class="line">            Field field = arrayListClass.getDeclaredField(<span class="string">&quot;elementData&quot;</span>);</span><br><span class="line">            <span class="comment">//开始访问权限</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//把示例传入get，获取实例字段elementData的值</span></span><br><span class="line">            Object[] objects = (Object[])field.get(arrayList);</span><br><span class="line">            <span class="comment">//返回当前ArrayList实例的容量值</span></span><br><span class="line">            <span class="keyword">return</span> objects.length;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-2-ArrayList的方法"><a href="#2-1-3-2-ArrayList的方法" class="headerlink" title="2.1.3.2 ArrayList的方法"></a>2.1.3.2 ArrayList的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新增元素</span></span><br><span class="line">add(E element)</span><br><span class="line">add(<span class="keyword">int</span> i , E element)</span><br><span class="line">addAll(Collection)</span><br><span class="line">addAll(<span class="keyword">int</span> index，Collection)</span><br><span class="line"><span class="comment">//移除元素</span></span><br><span class="line">remove（<span class="keyword">int</span> i）<span class="comment">//移除指定位置元素</span></span><br><span class="line">remove（E element）<span class="comment">//移除数组中第一个与element相同的元素</span></span><br><span class="line">removeRange（<span class="keyword">int</span> start,<span class="keyword">int</span> end）<span class="comment">//移除指定范围的元素</span></span><br><span class="line">clear()<span class="comment">//清除所有元素</span></span><br><span class="line">removeAll(Collection c)<span class="comment">//移除数组中所有和c中有交集的元素</span></span><br><span class="line">size() ;<span class="comment">//获取数组的元素个数（非数组长度）</span></span><br><span class="line">set();<span class="comment">//设置数组中指定位置元素值</span></span><br><span class="line">get(<span class="keyword">int</span> index);  <span class="comment">//index -- 该元素返回的索引值</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-ArrayList的扩容机制"><a href="#2-1-4-ArrayList的扩容机制" class="headerlink" title="2.1.4 ArrayList的扩容机制"></a>2.1.4 ArrayList的扩容机制</h3><h5 id="扩容步骤"><a href="#扩容步骤" class="headerlink" title="扩容步骤"></a>扩容步骤</h5><p>​     总的来说就是分两步：</p>
<p>1、扩容</p>
<p>​      把原来的数组复制到另一个内存空间更大的数组中</p>
<p> 2、添加元素</p>
<p>​        把新元素添加到扩容以后的数组中，扩容长度未原数组的1.5倍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//右移运算符(提高效率)   原来长度的一半 再加上原长度也就是每次扩容是原来的1.5倍</span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = minCapacity;</span><br><span class="line">      <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">      <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">      elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-实现ArrayList线程安全方式"><a href="#2-1-5-实现ArrayList线程安全方式" class="headerlink" title="2.1.5 实现ArrayList线程安全方式"></a>2.1.5 实现ArrayList线程安全方式</h3><ol>
<li>添加Synchronize关键字（Vector容器）</li>
<li>使用Collections的Collections.<strong>synchronizedList</strong>(new ArrayList&lt;&gt;());方法</li>
<li><strong>CopyOnWriteArrayList（详情见下）</strong></li>
</ol>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它<strong>支持线程的同步</strong>，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。<strong>Vector每次请求其大小的双倍空间</strong></p>
<h2 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h2><p>LinkedList是一个<strong>双向循环链表</strong>的，在<strong>添加和删除元素时具有比ArrayList更好的性能</strong>。但在get与set方面弱于ArrayList。<strong>线程非安全</strong>，可以用<strong>Collections的synchronizedList</strong>中相关方法实现线程安全</p>
<h2 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h2><p>CopyOnWriteArrayList这是一个ArrayList的<strong>线程安全的变体</strong>，其原理大概可以通俗的理解为:初始化的时候只有一个容器，很常一段时间，这个容器数据、数量等没有发生变化的时候，大家(多个线程)，都是读取(假设这段时间里只发生读取的操作)同一个容器中的数据，所以这样大家读到的数据都是唯一、一致、安全的，但是后来有人往里面增加了一个数据，这个时候<strong>CopyOnWriteArrayList 底层实现添加的原理是先copy出一个容器</strong>(可以简称副本)，<strong>再往新的容器里添加这个新的数据，最后把新的容器的引用地址赋值给了之前那个旧的的容器地址，但是在添加这个数据的期间，其他线程如果要去读取数据，仍然是读取到旧的容器里的数据，这样只能保证数据一致性，但不能保证数据的实时性，并且内存占用多</strong></p>
<h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p>Set接口的特点是<strong>无序(没有下标) 集合中的元素不重复</strong>，Set判断两个对象相同不是使用==运算符，而是根据<strong>equals</strong>方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul>
<li>它存储唯一元素并允许空值（只能有一个NULL值）</li>
<li>它由HashMap支持</li>
<li>它不保持插入顺序</li>
<li>它不是线程安全的</li>
</ul>
<p><strong>HashSet底层声明了一个HashMap，HashSet做了一层包装，操作HashSet里的元素时其实是在操作HashMap里的元素</strong></p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>   LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用<strong>链表</strong>维护元素的次序。这样使得元素看起 来像是以插入顺 序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>   LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p>
<h3 id="SortedSet（接口）"><a href="#SortedSet（接口）" class="headerlink" title="SortedSet（接口）"></a>SortedSet（接口）</h3><p>SortedSet 是一个有序的接口,集合内元素有2种排序规则,一种是Comparable(自然排序) 另一则是Comparator(比较器排序),</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p><strong>TreeSet底层也是声明了一个TreeMap，操作TreeSet里的元素其实是操作TreeMap里的元素</strong></p>
<p>TreeSet是SortedSet接口的<strong>唯一实现类</strong>，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，<strong>自然排序</strong> 和<strong>定制排序</strong>，其中自然排序为默认的排序方式。向 TreeSet中加入的应该是同一个类的对象。</p>
<p>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0</p>
<h3 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h3><p><strong>EnumSet 是一个专为枚举设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或隐式地指定</strong></p>
<ol>
<li>EnumSet的集合元素也是<strong>有序</strong>的，EnumSet以枚举值在Enum类内的定义顺序来决定集合元素的顺序。</li>
<li>EnumSet在内部以位向量的形式存储，这种存储形式非常紧凑、高效,因此EnumSet对象占用内存很小，而且运行效率很好。尤其是进行批量操作（如调用containsAll()和retainAll()方法）时，如果其参数也是EnumSet集合，则该批量操作的执行速度也非常快。</li>
<li>EnumSet集合不允许加入null元素，如果试图插入null元素，EnumSet将抛出NullPointerException异常。</li>
<li>EnumSet类没有暴露任何构造器来创建该类的实例，程序应该通过它提供的类方法来创建EnumSet对象。</li>
<li>如果只是想判断EnumSet是否包含null元素或试图删除null元素都不会抛出异常，只是删除操作将返回false，因为没有任何null元素被删除。</li>
</ol>
<p><strong>方法介绍：</strong></p>
<ul>
<li><strong>EnumSet allOf(Class elementType)</strong>: 创建一个包含指定枚举类里所有枚举值的EnumSet集合。</li>
<li><strong>EnumSet complementOf(EnumSet e)</strong>: 创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合，新EnumSet集合包含原EnumSet集合所不包含的、此类枚举类剩下的枚举值（即新EnumSet集合和原EnumSet集合的集合元素加起来是该枚举类的所有枚举值）。</li>
<li><strong>EnumSet copyOf(Collection c)</strong>: 使用一个普通集合来创建EnumSet集合。</li>
<li><strong>EnumSet copyOf(EnumSet e)</strong>: 创建一个指定EnumSet具有相同元素类型、相同集合元素的EnumSet集合。</li>
<li><strong>EnumSet noneOf(Class elementType)</strong>: 创建一个元素类型为指定枚举类型的空EnumSet。</li>
<li><strong>EnumSet of(E first,E…rest)</strong>: 创建一个包含一个或多个枚举值的EnumSet集合，传入的多个枚举值必须属于同一个枚举类。</li>
<li><strong>EnumSet range(E from,E to)</strong>: 创建一个包含从from枚举值到to枚举值范围内所有枚举值的EnumSet集合。</li>
</ul>
<h3 id="CopyOnwriteArraySet"><a href="#CopyOnwriteArraySet" class="headerlink" title="CopyOnwriteArraySet"></a>CopyOnwriteArraySet</h3><p>类似于<strong>CopyOnWriteArrayList</strong>，只是复制的容器有所不同</p>
<h3 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h3><p>ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。<br>ConcurrentSkipListSet和TreeSet，它们虽然都是有序的集合。但是，第一，它们的线程安全机制不同，TreeSet是非线程安全的，而ConcurrentSkipListSet是线程安全的。第二，ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114252.jpg" alt="ConcurrentSkipListSet的数据结构"></p>
<p><strong>说明</strong>：<br>(01) ConcurrentSkipListSet继承于AbstractSet。因此，它本质上是一个集合。<br>(02) ConcurrentSkipListSet实现了NavigableSet接口。因此，ConcurrentSkipListSet是一个有序的集合。<br>(03) ConcurrentSkipListSet是通过<strong>ConcurrentSkipListMap</strong>实现的。它包含一个ConcurrentNavigableMap对象m，而m对象实际上是ConcurrentNavigableMap的实现类ConcurrentSkipListMap的实例。ConcurrentSkipListMap中的元素是key-value键值对；而ConcurrentSkipListSet是集合，它只用到了ConcurrentSkipListMap中的key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个新的空 set，该 set 按照元素的自然顺序对其进行排序。</span></span><br><span class="line">ConcurrentSkipListSet()</span><br><span class="line"><span class="comment">// 构造一个包含指定 collection 中元素的新 set，这个新 set 按照元素的自然顺序对其进行排序。</span></span><br><span class="line">ConcurrentSkipListSet(Collection&lt;? extends E&gt; c)</span><br><span class="line"><span class="comment">// 构造一个新的空 set，该 set 按照指定的比较器对其元素进行排序。</span></span><br><span class="line">ConcurrentSkipListSet(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span><br><span class="line"><span class="comment">// 构造一个新 set，该 set 所包含的元素与指定的有序 set 包含的元素相同，使用的顺序也相同。</span></span><br><span class="line">ConcurrentSkipListSet(SortedSet&lt;E&gt; s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果此 set 中不包含指定元素，则添加指定元素。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">ceiling</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此 set 中移除所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 ConcurrentSkipListSet 实例的浅表副本。</span></span></span><br><span class="line"><span class="function">ConcurrentSkipListSet&lt;E&gt; <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。</span></span></span><br><span class="line"><span class="function">Comparator&lt;? <span class="keyword">super</span> E&gt; <span class="title">comparator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 包含指定的元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回在此 set 的元素上以降序进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中所包含元素的逆序视图。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比较指定对象与此 set 的相等性。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中当前第一个（最低）元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">floor</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素严格小于 toElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素小于（或等于，如果 inclusive 为 true）toElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">higher</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 不包含任何元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回在此 set 的元素上以升序进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中当前最后一个（最高）元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">last</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">lower</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 中存在指定的元素，则将其移除。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此 set 中移除包含在指定 collection 中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中的元素数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive, E toElement, <span class="keyword">boolean</span> toInclusive)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素大于等于 fromElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span></span></span><br></pre></td></tr></table></figure>

<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p><strong>Queue（JDK1.5新增，对多线程友好，多线程优先使用，线程安全（底层有CAS操作等等进行同步））</strong></p>
<p>队列是一种特殊的线性表，是一种先进先出（FIFO）的数据结构。它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114258.png" alt="队列的继承关系"></p>
<h2 id="阻塞队列（BlockingQueue）"><a href="#阻塞队列（BlockingQueue）" class="headerlink" title="阻塞队列（BlockingQueue）"></a>阻塞队列（BlockingQueue）</h2><p>BlockingQueue即阻塞队列，它是基于<strong>ReentrantLock</strong>实现相关过程，依据它的基本原理，我们可以实现Web中的长连接聊天功能，当然其最常用的还是用于实现生产者与消费者模式，大致如下图所示</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114301.png" alt="img"></p>
<blockquote>
<p>在Java中，BlockingQueue是一个接口，它的实现类有<strong>ArrayBlockingQueue</strong>、<strong>DelayQueue</strong>、 <strong>LinkedBlockingDeque</strong>、<strong>PriorityBlockingQueue</strong>、<strong>SynchronousQueue</strong>、<strong>TransferQueue</strong>等，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的。</p>
</blockquote>
<p><code>BlockingQueue</code> 方法以四种形式出现，对于不能立即满足但可能在将来某一时刻可以满足的操作，这四种形式的处理方式不同：第一种是抛出一个异常，第二种是返回一个特殊值（<code>null</code> 或 <code>false</code>，具体取决于操作），第三种是在操作可以成功前，无限期地阻塞当前线程，第四种是在放弃前只在给定的最大时间限制内阻塞。下表中总结了这些方法：</p>
<table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td><code>add(e)</code></td>
<td><code>offer(e)</code></td>
<td><code>put(e)</code></td>
<td><code>offer(e, time, unit)</code></td>
</tr>
<tr>
<td>移除</td>
<td><code>remove()</code></td>
<td><code>poll()</code></td>
<td><code>take()</code></td>
<td><code>poll(time, unit)</code></td>
</tr>
<tr>
<td>检查</td>
<td><code>element()</code></td>
<td><code>peek()</code></td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue和LinkedList一样，内部基于<strong>链表</strong>来存放元素。LinkedBlockingQueue如果不指定容量，默认为<code>Integer.MAX_VALUE</code>，也就是<strong>无界队列</strong>。所以为了<strong>避免队列过大造成机器负载或者内存爆满</strong>的情况出现，我们在使用的时候建议手动传一个队列的大小。</p>
<p>LinkedBlockingQueue内部由<strong>单链表实现</strong>，只能从head取元素，从tail添加元素。添加元素和获取元素都有独立的锁，也就是说<strong>LinkedBlockingQueue是读写分离的</strong>，读写操作可以并行执行。LinkedBlockingQueue采用可重入锁(**ReentrantLock)**来保证在并发情况下的线程安全。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点类，用于存储数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 阻塞队列的大小，默认为Integer.MAX_VALUE */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前阻塞队列中的元素个数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列的头结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列的尾节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 获取并移除元素时使用的锁，如take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** notEmpty条件对象，当队列没有数据时用于挂起执行删除的线程 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 添加元素时使用的锁如 put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** notFull条件对象，当队列数据已满时用于挂起执行添加的线程 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>LinkedBlockingQueue队列中的数据都将被封装成Node节点，添加的链表队列中，其中head和last分别指向队列的头结点和尾结点</li>
<li>LinkedBlockingQueue内部分别使用了takeLock 和 putLock 对并发进行控制，也就是说，添加和删除操作并不是互斥操作，可以同时进行，这样也就可以大大提高吞吐量。</li>
<li>LinkedBlockingQueue对每一个lock锁都提供了一个Condition用来挂起和唤醒其他线程。</li>
</ol>
</blockquote>
<p>LinkedBlockingQueue常用操作</p>
<h5 id="取数据"><a href="#取数据" class="headerlink" title="取数据"></a>取数据</h5><p><strong>take()：首选。当队列为空时阻塞</strong></p>
<p>poll()：弹出队顶元素，队列为空时，返回空</p>
<p>peek()：和poll烈性，返回队队顶元素，但顶元素不弹出。队列为空时返回null</p>
<p>remove(Object o)：移除某个元素，队列为空时抛出异常。成功移除返回true</p>
<h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><p><strong>put()：首选。队满是阻塞</strong></p>
<p>offer()：队满时返回false</p>
<h5 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h5><p><strong>size()方法会遍历整个队列，时间复杂度为O(n),所以最好选用isEmtpy</strong></p>
<h5 id="put元素原理"><a href="#put元素原理" class="headerlink" title="put元素原理"></a>put元素原理</h5><p>基本过程：</p>
<p>1.判断元素是否为null，为null抛出异常</p>
<p>2.加锁(可中断锁<strong>ReentrantLock</strong>实现)</p>
<p>3.判断队列长度是否到达容量，如果到达一直等待</p>
<p>4.如果没有队满，enqueue()在队尾加入元素</p>
<p>5.队列长度加1，此时如果队列还没有满，调用signal唤醒其他堵塞队列</p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue是一个<strong>阻塞式的队列</strong>，继承自AbstractBlockingQueue,间接的实现了Queue接口和Collection接口。底层以数组的形式保存数据(实际上可看作一个循环数组)。常用的操作包括 add，offer，put，remove，poll，take，peek。</p>
<p>ArrayBlockingQueue 进队操作采用了加锁的方式保证并发安全。源代码里面有一个 <strong>while</strong>() 判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e); <span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="comment">// 一直阻塞，知道队列非满时，被唤醒</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e); <span class="comment">// 进队</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">        <span class="comment">// 阻塞，知道队列不满</span></span><br><span class="line">        <span class="comment">// 或者超时时间已过，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码分析，我们可以发现下面的规律：</p>
<ul>
<li>阻塞调用方式 put(e)或 offer(e, timeout, unit)</li>
<li>阻塞调用时，唤醒条件为超时或者队列非满（因此，要求在出队时，要发起一个唤醒操作）</li>
<li>进队成功之后，执行notEmpty.signal()唤起被阻塞的出队线程</li>
</ul>
<p>出队的源码类似。ArrayBlockingQueue 队列我们可以在创建线程池时进行使用。</p>
<blockquote>
<p>在进行某项业务存储操作时，建议采用<strong>offer</strong>进行添加，可及时获取boolean进行判断，如用put要考虑阻塞情况（队列的出队操作慢于进队操作），资源占用</p>
</blockquote>
<h3 id="SynchonousQueue"><a href="#SynchonousQueue" class="headerlink" title="SynchonousQueue"></a>SynchonousQueue</h3><p>SynchronousQueue 是一个很奇怪的队列，感觉都不能叫队列，因为内部没有数据的存储空间，队列不能peek，因为不存在元素，任何入队的线程都会阻塞，直到有线程来出队，也就是这个队列是一组操作，入队和出队要一起离开，出队也是一样，必须等入队，必须结伴而行；队列支持公平和非公平的模式(指的是队列匹配线程的顺序)，<strong>公平模式的数据结构是队列</strong>（FIFO），<strong>非公平模式使用的是栈</strong>（LIFO）。</p>
<h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114309.png" alt="image-20200831164258224"></p>
<h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 出队入队都是这一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// npu数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPUS = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时时间的自旋次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimedSpins = (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有超时的自旋次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxUntimedSpins = maxTimedSpins * <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<h5 id="TransferStack-非公平的实现，主要方法"><a href="#TransferStack-非公平的实现，主要方法" class="headerlink" title="TransferStack 非公平的实现，主要方法"></a>TransferStack 非公平的实现，主要方法</h5><p>TransferStack 继承 Transferer</p>
<p>注意：<strong>这几个状态很重要，因为继承了Transferer，所以出队和入队都是使用的transfer方法，状态是用来区分的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/** 0表示消费者 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST    = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 1表示数据的生产者 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA       = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** 2 表示数据正在匹配 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> SNode next;        <span class="comment">// 下一个节点</span></span><br><span class="line">        <span class="keyword">volatile</span> SNode match;       <span class="comment">// 匹配的节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// 等待的线程</span></span><br><span class="line">        Object item;                <span class="comment">// 数据</span></span><br><span class="line">        <span class="keyword">int</span> mode;                   <span class="comment">// 模式 0 ， 1 ， 2</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 头结点 */</span></span><br><span class="line"><span class="keyword">volatile</span> SNode head;</span><br></pre></td></tr></table></figure>

<h5 id="TransferQueue-公平实现，主要成员"><a href="#TransferQueue-公平实现，主要成员" class="headerlink" title="TransferQueue 公平实现，主要成员"></a>TransferQueue 公平实现，主要成员</h5><p>TransferQueue 继承 Transferer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">          <span class="keyword">volatile</span> QNode next;          <span class="comment">// next 节点</span></span><br><span class="line">          <span class="keyword">volatile</span> Object item;         <span class="comment">// 数据项</span></span><br><span class="line">          <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// 等待线程</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> isData;         <span class="comment">// 区分生产和消费</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 头结点 */</span></span><br><span class="line">      <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">      <span class="comment">/** 尾节点 */</span></span><br><span class="line">      <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SynchronousQueue 的实现还是很复杂的，我们可以发现虽然是个阻塞队列，可是没有使用锁；这个队列适合传递的场景，队列没有存储元素的队列，出队和入队必须结伴而行。</p>
<p>详细的源码解析可看  <a href="https://blog.51cto.com/14220760/2416470">https://blog.51cto.com/14220760/2416470</a></p>
</blockquote>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue是一个支持优先级的无<strong>界阻塞队列</strong>，直到系统资源耗尽。<strong>默认情况下元素采用自然顺序升序排列</strong>。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。但需要注意的是不能保证同优先级元素的顺序。PriorityBlockingQueue也是基于最小二叉堆实现，使用基于<strong>CAS实现的自旋锁</strong>来控制队列的<strong>动态扩容</strong>，保证了扩容操作不会阻塞take操作的执行<strong>PriorityBlockingQueue有四个构造方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的构造方法，该方法会调用this(DEFAULT_INITIAL_CAPACITY, null)，即默认的容量是11</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 根据initialCapacity来设置队列的初始容量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 根据initialCapacity来设置队列的初始容量，并根据comparator对象来对数据进行排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 根据集合来创建队列</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>源码解析可看<a href="https://zhuanlan.zhihu.com/p/63801130">https://zhuanlan.zhihu.com/p/63801130</a> </p>
</blockquote>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue是线程安全的，DelayQueue的特点就是插入Queue中的数据可以按照自定义的delay时间进行排序。只有delay时间小于0的元素才能够被取出</p>
<p>DelayQueue的底层存储是一个PriorityQueue，PriorityQueue是一个可排序的Queue，其中的元素必须实现Comparable方法。而getDelay方法则用来判断排序后的元素是否可以从Queue中取出</p>
<blockquote>
<p>源码解析可看 <a href="https://zhuanlan.zhihu.com/p/138368078">https://zhuanlan.zhihu.com/p/138368078</a></p>
</blockquote>
<h3 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从类的源码可以看到TransferQueue同时也是一个阻塞队列，它具备<strong>阻塞队列的所有特性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 如果可能，立即将元素转移给等待的消费者。 </span></span><br><span class="line">    <span class="comment">// 更确切地说，如果存在消费者已经等待接收它（在 take 或 timed poll（long，TimeUnit）poll）中，则立即传送指定的元素，否则返回 false。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素转移给消费者，如果需要的话等待。 </span></span><br><span class="line">    <span class="comment">// 更准确地说，如果存在一个消费者已经等待接收它（在 take 或timed poll（long，TimeUnit）poll）中，则立即传送指定的元素，否则等待直到元素由消费者接收。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面方法的基础上设置超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果至少有一位消费者在等待，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasWaitingConsumer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回等待消费者人数的估计值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWaitingConsumerCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>transfer</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xfer(e, <span class="keyword">true</span>, SYNC, <span class="number">0</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.interrupted(); <span class="comment">// failure possible only due to interrupt</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>tryTransfer</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> xfer(e, <span class="keyword">true</span>, NOW, <span class="number">0</span>) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-1-xfer-方法分析"><a href="#1-6-1-xfer-方法分析" class="headerlink" title="1.6.1 xfer 方法分析"></a>1.6.1 xfer 方法分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">xfer</span><span class="params">(E e, <span class="keyword">boolean</span> haveData, <span class="keyword">int</span> how, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="keyword">null</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node s = <span class="keyword">null</span>;                        <span class="comment">// the node to append, if needed</span></span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                            <span class="comment">// restart on append race</span></span><br><span class="line">        <span class="comment">// 从  head 开始</span></span><br><span class="line">        <span class="keyword">for</span> (Node h = head, p = h; p != <span class="keyword">null</span>;) &#123; <span class="comment">// find &amp; match first node</span></span><br><span class="line">            <span class="comment">// head 的类型。</span></span><br><span class="line">            <span class="keyword">boolean</span> isData = p.isData;</span><br><span class="line">            <span class="comment">// head 的数据</span></span><br><span class="line">            Object item = p.item;</span><br><span class="line">            <span class="comment">// item != null 有 2 种情况,一是 put 操作, 二是 take 的 itme 被修改了(匹配成功)</span></span><br><span class="line">            <span class="comment">// (itme != null) == isData 要么表示 p 是一个 put 操作, 要么表示 p 是一个还没匹配成功的 take 操作</span></span><br><span class="line">            <span class="keyword">if</span> (item != p &amp;&amp; (item != <span class="keyword">null</span>) == isData) &#123; </span><br><span class="line">                <span class="comment">// 如果当前操作和 head 操作相同，就没有匹配上，结束循环，进入下面的 if 块。</span></span><br><span class="line">                <span class="keyword">if</span> (isData == haveData)   <span class="comment">// can&#x27;t match</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果操作不同,匹配成功, 尝试替换 item 成功,</span></span><br><span class="line">                <span class="keyword">if</span> (p.casItem(item, e)) &#123; <span class="comment">// match</span></span><br><span class="line">                    <span class="comment">// 更新 head</span></span><br><span class="line">                    <span class="keyword">for</span> (Node q = p; q != h;) &#123;</span><br><span class="line">                        Node n = q.next;  <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">                        <span class="keyword">if</span> (head == h &amp;&amp; casHead(h, n == <span class="keyword">null</span> ? q : n)) &#123;</span><br><span class="line">                            h.forgetNext();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;                 <span class="comment">// advance and retry</span></span><br><span class="line">                        <span class="keyword">if</span> ((h = head)   == <span class="keyword">null</span> ||</span><br><span class="line">                            (q = h.next) == <span class="keyword">null</span> || !q.isMatched())</span><br><span class="line">                            <span class="keyword">break</span>;        <span class="comment">// unless slack &lt; 2</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 唤醒原 head 线程.</span></span><br><span class="line">                    LockSupport.unpark(p.waiter);</span><br><span class="line">                    <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找下一个</span></span><br><span class="line">            Node n = p.next;</span><br><span class="line">            p = (p != n) ? n : (h = head); <span class="comment">// Use head if p offlist</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果这个操作不是立刻就返回的类型    </span></span><br><span class="line">        <span class="keyword">if</span> (how != NOW) &#123;                 <span class="comment">// No matches available</span></span><br><span class="line">            <span class="comment">// 且是第一次进入这里</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 创建一个 node</span></span><br><span class="line">                s = <span class="keyword">new</span> Node(e, haveData);</span><br><span class="line">            <span class="comment">// 尝试将 node 追加对队列尾部，并返回他的上一个节点。</span></span><br><span class="line">            Node pred = tryAppend(s, haveData);</span><br><span class="line">            <span class="comment">// 如果返回的是 null, 表示不能追加到 tail 节点,因为 tail 节点的模式和当前模式相反.</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 重来</span></span><br><span class="line">                <span class="keyword">continue</span> retry;           <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">            <span class="comment">// 如果不是异步操作(即立刻返回结果)</span></span><br><span class="line">            <span class="keyword">if</span> (how != ASYNC)</span><br><span class="line">                <span class="comment">// 阻塞等待匹配值</span></span><br><span class="line">                <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e; <span class="comment">// not waiting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑如下:<br>                        找到 <code>head</code> 节点,如果 <code>head</code> 节点是匹配的操作,就直接赋值,如果不是,添加到队列中。</p>
<p>​                注意：队列中永远只有一种类型的操作,要么是 <code>put</code> 类型, 要么是 <code>take</code> 类型.</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114320.png" alt="img"></p>
<p>相比较 <code>SynchronousQueue</code> 多了一个可以存储的队列，相比较 <code>LinkedBlockingQueue</code> 多了直接传递元素，少了用锁来同步。</p>
<p>性能更高，用处更大</p>
<h4 id="1-6-2-总结"><a href="#1-6-2-总结" class="headerlink" title="1.6.2  总结"></a>1.6.2  总结</h4><p><code>LinkedTransferQueue</code>是 <code>SynchronousQueue</code> 和 <code>LinkedBlockingQueue</code> 的合体，性能比 <code>LinkedBlockingQueue</code> 更高（没有锁操作），比 <code>SynchronousQueue</code>能存储更多的元素。</p>
<p>当 <code>put</code> 时，如果有等待的线程，就直接将元素 “交给” 等待者， 否则直接进入队列。</p>
<p><code>put</code>和 <code>transfer</code> 方法的区别是，put 是立即返回的， transfer 是阻塞等待消费者拿到数据才返回。<code>transfer</code>方法和 <code>SynchronousQueue</code>的 put 方法类似。</p>
<h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><h3 id="Deque（双端队列，两边都可以进出）"><a href="#Deque（双端队列，两边都可以进出）" class="headerlink" title="Deque（双端队列，两边都可以进出）"></a>Deque（双端队列，两边都可以进出）</h3><p>deque容器为一个给定<strong>类型</strong>的元素进行<strong>线性处理</strong>，像向量一样，<strong>能够快速地随机访问任一个元素</strong>，并且能够<strong>高效地插入和删除容器的尾部元素</strong>。但它又与vector不同，<strong>deque支持高效插入和删除容器的头部元素</strong>，因此也叫做<strong>双端队列</strong>。deque类常用的函数如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line">deque():创建一个空deque</span><br><span class="line"></span><br><span class="line">deque(<span class="keyword">int</span> nSize):创建一个deque,元素个数为nSize</span><br><span class="line"></span><br><span class="line">deque(<span class="keyword">int</span> nSize,<span class="keyword">const</span> T&amp; t):创建一个deque,元素个数为nSize,且值均为t</span><br><span class="line"></span><br><span class="line">deque(<span class="keyword">const</span> deque &amp;):复制构造函数</span><br><span class="line"></span><br><span class="line"><span class="comment">//  增加函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span>:双端队列头部增加一个元素X</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span>:双端队列尾部增加一个元素x</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="keyword">const</span> T&amp; x)</span>:双端队列中某一元素前增加一个元素x</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator it,<span class="keyword">int</span> n,<span class="keyword">const</span> T&amp; x)</span>:双端队列中某一元素前增加n个相同的元素x</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator it,const_iterator first,const_iteratorlast)</span>:双端队列中某一元素前插入另一个相同类型向量的[forst,last)间的数据</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 删除函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Iterator <span class="title">erase</span><span class="params">(iterator it)</span>:删除双端队列中的某一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span>:删除双端队列中[first,last）中的元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span>:删除双端队列中最前一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span>:删除双端队列中最后一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>:删除所有的元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 遍历函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">reference <span class="title">at</span><span class="params">(<span class="keyword">int</span> pos)</span>:返回pos位置元素的引用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span>:返回首元素的引用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span>:返回尾元素的引用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span>:返回向量头指针，指向第一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span>:返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span>:反向迭代器，指向最后一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span>:反向迭代器，指向第一个元素的前一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bool <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span>:向量是否为空，若<span class="keyword">true</span>,则向量中无元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 大小函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Int <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span>:返回向量中元素的个数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span>:返回最大可允许的双端对了元素数量值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 其他函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(deque&amp;)</span>:交换两个同类型向量的数据</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">const</span> T&amp; x)</span>:向量中第n个元素的值设置为x</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>详细分析  <a href="https://blog.csdn.net/u011630575/article/details/79923132">https://blog.csdn.net/u011630575/article/details/79923132</a></p>
</blockquote>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue是一个基于<strong>链接节点的无界线程安全队列</strong>，它采用<strong>先进先出的规则对节点进行排序</strong>，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现</p>
<p>ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列</p>
<p> <strong>总结</strong></p>
<p>ConcurrentLinkedQueue 的非阻塞算法实现可概括为下面 5 点：</p>
<ul>
<li>使用 CAS 原子指令来处理对数据的并发访问，这是非阻塞算法得以实现的基础。</li>
<li>head/tail 并非总是指向队列的头 / 尾节点，也就是说允许队列处于不一致状态。 这个特性把入队 / 出队时，原本需要一起原子化执行的两个步骤分离开来，从而缩小了入队 / 出队时需要原子化更新值的范围到唯一变量。这是非阻塞算法得以实现的关键。</li>
<li>由于队列有时会处于不一致状态。为此，ConcurrentLinkedQueue 使用<a href="https://www.ibm.com/developerworks/cn/java/j-lo-concurrent/index.html">三个不变式</a>来维护非阻塞算法的正确性。</li>
<li>以批处理方式来更新 head/tail，从整体上减少入队 / 出队操作的开销。</li>
<li>为了有利于垃圾收集，队列使用特有的 head 更新机制；为了确保从已删除节点向后遍历，可到达所有的非删除节点，队列使用了特有的向后推进策略。</li>
</ul>
<blockquote>
<p>详细分析   <a href="https://blog.csdn.net/qq_38293564/article/details/80798310">https://blog.csdn.net/qq_38293564/article/details/80798310</a></p>
</blockquote>
<h3 id="priorityQueue"><a href="#priorityQueue" class="headerlink" title="priorityQueue"></a>priorityQueue</h3><p>PriorityQueue 一个基于优先级的<strong>无界优先级队列</strong>。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。该队列不允许使用 null 元素也不允许插入不可比较的对象(没有实现Comparable接口的对象)。<br> PriorityQueue 队列的头指排序规则最小那哥元素。如果多个元素都是最小值则随机选一个。<br> PriorityQueue 是一个无界队列，但是初始的容量(实际是一个Object[])，随着不断向优先级队列添加元素，其容量会自动扩容，无需指定容量增加策略的细节</p>
<ol>
<li>PriorityQueue是一种无界的，线程不安全的队列</li>
<li>PriorityQueue是一种通过数组实现的，并拥有优先级的队列</li>
<li>PriorityQueue存储的元素要求必须是可比较的对象， 如果不是就必须明确指定比较器</li>
</ol>
<blockquote>
<p>详细分析    <a href="https://www.jianshu.com/p/f1fd9b82cb72">https://www.jianshu.com/p/f1fd9b82cb72</a></p>
</blockquote>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map用于保存具有映射关系的数据，Map集合里保存着两组值，一组用于保存Map的ley，另一组保存着Map的value</p>
<p><strong>Map中的常用方法</strong>：</p>
<ul>
<li><code>void clear()</code>:删除该Map对象中所有键值对；</li>
<li><code>boolean containsKey(Object key)</code>:查询Map中是否包含指定的key值；</li>
<li><code>boolean containsValue(Object value)</code>:查询Map中是否包含一个或多个value;</li>
<li><code>Set entrySet()</code>:返回map中包含的键值对所组成的Set集合，每个集合都是Map.Entry对象。</li>
<li><code>Object get()</code>：返回指定key对应的value，如果不包含key则返回null；</li>
<li><code>boolean isEmpty()</code>:查询该Map是否为空；</li>
<li><code>Set keySet()</code>:返回Map中所有key组成的集合；</li>
<li><code>Collection values()</code>:返回该Map里所有value组成的Collection。</li>
<li><code>Object put(Object key,Object value)</code>:添加一个键值对，如果集合中的key重复，则覆盖原来的键值对；</li>
<li><code>void putAll(Map m)</code>:将Map中的键值对复制到本Map中；</li>
<li><code>Object remove(Object key)</code>:删除指定的key对应的键值对，并返回被删除键值对的value，如果不存在，则返回null；</li>
<li><code>boolean remove(Object key,Object value)</code>:删除指定键值对，删除成功返回true；</li>
<li><code>int size()</code>:返回该Map里的键值对个数</li>
</ul>
<p><strong>内部类Entry</strong></p>
<p>Map中包括一个内部类Entry,该类封装一个键值对，常用方法：</p>
<ul>
<li><code>Object getKey()</code>:返回该Entry里包含的key值；</li>
<li><code>Object getvalue()</code>:返回该Entry里包含的value值；</li>
<li><code>Object setValue(V value)</code>:设置该Entry里包含的value值，并设置新的value值。</li>
</ul>
<p><strong>Map的遍历四种方法</strong></p>
<p>在java中所有的map都实现了Map接口，因此所有的Map（如HashMap, TreeMap, LinkedHashMap, Hashtable等）都可以用以下的方式去遍历。</p>
<p>方法一：在for循环中使用entries实现Map的遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 最常见也是大多数情况下用的最多的，一般在键值对都需要使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Map &lt;String,String&gt;map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;熊大&quot;</span>, <span class="string">&quot;棕色&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;熊二&quot;</span>, <span class="string">&quot;黄色&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    String mapKey = entry.getKey();</span><br><span class="line">    String mapValue = entry.getValue();</span><br><span class="line">    System.out.println(mapKey+<span class="string">&quot;:&quot;</span>+mapValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法二：在for循环中遍历key或者values，一般适用于只需要map中的key或者value时使用，在性能上比使用entrySet较好；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map &lt;String,String&gt;map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;熊大&quot;</span>, <span class="string">&quot;棕色&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;熊二&quot;</span>, <span class="string">&quot;黄色&quot;</span>);</span><br><span class="line"><span class="comment">//key</span></span><br><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value</span></span><br><span class="line"><span class="keyword">for</span>(String value : map.values())&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法三：通过Iterator遍历；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(entries.hasNext())&#123;</span><br><span class="line">    Entry&lt;String, String&gt; entry = entries.next();</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法四：通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    String value = map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashTable和HashMap"><a href="#HashTable和HashMap" class="headerlink" title="HashTable和HashMap"></a>HashTable和HashMap</h2><h3 id="HashMap的工作原理"><a href="#HashMap的工作原理" class="headerlink" title="HashMap的工作原理"></a>HashMap的工作原理</h3><p>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。<strong>HashMap最多只允许一条记录的键为null</strong>，允许多条记录的值为null</p>
<p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p>
<h3 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h3><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p>
<ol>
<li>HashMap几乎可以等价于Hashtable，除了<strong>HashMap是非synchronized的，并可以接受null</strong>(HashMap可以接受为null的键值(key)和值(value)，而<strong>Hashtable不能接受null的key</strong>)。</li>
<li>HashMap是非synchronized，而Hashtable是synchronized，这意味着<strong>Hashtable是线程安全的</strong>，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，<strong>HashMap不是线程安全的</strong>。Java 5提供了<strong>ConcurrentHashMap</strong>，<strong>它是HashTable的替代</strong>，比HashTable的扩展性更好。</li>
<li>另一个区别是<strong>HashMap的迭代器(Iterator)是fail-fast迭代器</strong>，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li>
<li>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</li>
<li>HashMap不能保证随着时间的推移Map中的元素次序是不变的。</li>
</ol>
<h3 id="解决Hsah冲突的方法"><a href="#解决Hsah冲突的方法" class="headerlink" title="解决Hsah冲突的方法"></a>解决Hsah冲突的方法</h3><p>HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用<strong>开放地址法和链地址法</strong>等来解决问题，Java中HashMap采用了<strong>链地址法</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/21673805">https://zhuanlan.zhihu.com/p/21673805</a></p>
<p>HashMap就是使用<strong>哈希表来存储</strong>的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，<strong>Java中HashMap采用了链地址法</strong>。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上</p>
<p>例如程序执行下面代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">map.put(&quot;美团&quot;,&quot;小美&quot;);</span><br></pre></td></tr></table></figure>

<p>系统将调用”美团”这个key的hashCode()方法得到其<strong>hashCode</strong> 值（该方法适用于每个Java对象），然后再<strong>通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞</strong>。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>
<h3 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h3><p><a href="https://zhuanlan.zhihu.com/p/92481037">https://zhuanlan.zhihu.com/p/92481037</a></p>
<p>初始化大小为16，扩展因子为0.75（泊松分布）</p>
<h3 id="LinkHashMap"><a href="#LinkHashMap" class="headerlink" title="LinkHashMap"></a>LinkHashMap</h3><p>LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。（转list的时候可以按照顺序转化）</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><a href="https://zhuanlan.zhihu.com/p/35668936">https://zhuanlan.zhihu.com/p/35668936</a></p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p><a href="https://zhuanlan.zhihu.com/p/35598760">https://zhuanlan.zhihu.com/p/35598760</a></p>
<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p><a href="https://zhuanlan.zhihu.com/p/138021927">https://zhuanlan.zhihu.com/p/138021927</a></p>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p><a href="https://zhuanlan.zhihu.com/p/24887482">https://zhuanlan.zhihu.com/p/24887482</a></p>
<h2 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h2><p><a href="https://zhuanlan.zhihu.com/p/125093062">https://zhuanlan.zhihu.com/p/125093062</a></p>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程的强软弱虚四种引用</title>
    <url>/posts/d6b7922e/</url>
    <content><![CDATA[<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>spring的声明式事务会使用到，保证当前线程中数据库连接是同一个连接</p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>只要一对象有强引用，垃圾回收机制不会回收</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>在内存不够用时，会优先回收只有软引用的内存空间，主要是做缓存用</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>只要是触发垃圾回收机制进行回收，只具有弱引用的对象就会被回收</p>
<ul>
<li>tomcat中就是使用的弱应用</li>
<li>ThreadLocal也是使用弱应用</li>
</ul>
<p>weakhashmap</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>主要是管理堆外内存的，主要是给写jvm的使用</p>
<p>主要检测队列配合使用，虚引用API无法get到值，主要是通知对象已经被回收，去清理堆外的内存</p>
<table>
<thead>
<tr>
<th align="left">引用类型</th>
<th align="left">被垃圾回收时间</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody><tr>
<td align="left">强引用</td>
<td align="left">从来不会</td>
<td>对象的一般状态</td>
<td>JVM停止运行时终止</td>
</tr>
<tr>
<td align="left">软引用</td>
<td align="left">当内存不足时</td>
<td>对象缓存</td>
<td>内存不足时终止</td>
</tr>
<tr>
<td align="left">弱引用</td>
<td align="left">正常垃圾回收时</td>
<td>对象缓存</td>
<td>垃圾回收后终止</td>
</tr>
<tr>
<td align="left">虚引用</td>
<td align="left">正常垃圾回收时</td>
<td>跟踪对象的垃圾回收</td>
<td>垃圾回收后终止</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程的AQS</title>
    <url>/posts/1008f972/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>AbstractQueuedSynchronizer抽象队列同步器简称AQS，它是实现同步器的基础组件，juc下面Lock的实现以及一些并发工具类就是通过AQS来实现的，这里我们通过AQS的类图先看一下大概，下面我们总结一下AQS的实现原理。先看看AQS的类图。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114112.png" alt="img"></p>
<p> <strong>(1)**AQS是一个通过内置的</strong>FIFO**双向队列来完成线程的排队工作(内部通过结点head和tail记录队首和队尾元素，元素的结点类型为Node类型，后面我们会看到Node的具体构造)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*等待队列的队首结点(懒加载，这里体现为竞争失败的情况下，加入同步队列的线程执行到enq方法的时候会创</span></span><br><span class="line"><span class="comment">建一个Head结点)。该结点只能被setHead方法修改。并且结点的waitStatus不能为CANCELLED*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">/**等待队列的尾节点，也是懒加载的。（enq方法）。只在加入新的阻塞结点的情况下修改*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>

<p> <strong>(2)**其中</strong>Node**中的thread用来存放进入AQS队列中的线程引用，Node结点内部的SHARED表示标记线程是因为获取共享资源失败被阻塞添加到队列中的；Node中的EXCLUSIVE表示线程因为获取独占资源失败被阻塞添加到队列中的。waitStatus表示当前线程的等待状态</p>
<p> ①CANCELLED=1：表示线程因为中断或者等待超时，需要从等待队列中取消等待；</p>
<p> ②SIGNAL=-1：当前线程thread1占有锁，队列中的head(仅仅代表头结点，里面没有存放线程引用)的后继结点node1处于等待状态，如果已占有锁的线程thread1释放锁或被CANCEL之后就会通知这个结点node1去获取锁执行。</p>
<p> ③CONDITION=-2：表示结点在等待队列中(这里指的是等待在某个lock的condition上，关于Condition的原理下面会写到)，当持有锁的线程调用了Condition的signal()方法之后，结点会从该condition的等待队列转移到该lock的同步队列上，去竞争lock。(注意：这里的同步队列就是我们说的AQS维护的FIFO队列，等待队列则是每个condition关联的队列)</p>
<p> ④PROPAGTE=-3：表示下一次共享状态获取将会传递给后继结点获取这个共享同步状态。</p>
<p>**(3)**AQS中维持了一个单一的volatile修饰的状态信息state(AQS通过Unsafe的相关方法，以原子性的方式由线程去获取这个state)。AQS提供了getState()、setState()、compareAndSetState()函数修改值(实际上调用的是unsafe的compareAndSwapInt方法)。下面是AQS中的部分成员变量以及更新state的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这就是我们刚刚说到的head结点，懒加载的（只有竞争失败需要构建同步队列的时候，才会创建这个head），如果头节点存在，它的waitStatus不能为CANCELLED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">//当前同步队列尾节点的引用，也是懒加载的，只有调用enq方法的时候会添加一个新的wait node</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="comment">//AQS核心：同步状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>(4)**AQS的设计师基于</strong>模板方法**模式的。使用时候需要继承同步器并重写指定的方法，并且通常将子类推荐为定义同步组件的静态内部类，子类重写这些方法之后，AQS工作时使用的是提供的模板方法，在这些模板方法中调用子类重写的方法。其中子类可以重写的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//独占式的获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;	<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();&#125;</span><br><span class="line"><span class="comment">//独占式的释放同步状态，等待获取同步状态的线程可以有机会获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;	<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();&#125;</span><br><span class="line"><span class="comment">//共享式的获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();&#125;</span><br><span class="line"><span class="comment">//尝试将状态设置为以共享模式释放同步状态。 该方法总是由执行释放的线程调用。 </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(); &#125;</span><br><span class="line"><span class="comment">//当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">isHeldExclusively</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;	<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(5)**AQS的内部类</strong>ConditionObject**是通过结合锁实现线程同步，ConditionObject可以直接访问AQS的变量(state、queue)，ConditionObject是个条件变量 ，每个ConditionObject对应一个队列用来存放线程调用condition条件变量的await方法之后被阻塞的线程。</p>
<h3 id="非公平锁的加锁流程"><a href="#非公平锁的加锁流程" class="headerlink" title="非公平锁的加锁流程"></a>非公平锁的加锁流程</h3><p>AQS会把所有的请求线程构成一个<strong>CLH队列</strong>，当一个线程执行完毕（lock.unlock()）时会激活自己的后继节点，但正在执行的线程并不在队列中，而那些等待执行的线程全部处于阻塞状态(park())。如下图所示。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114118.png" alt="img"></p>
<p> **(1)**假设这个时候在初始情况下，还没有多任务来请求竞争这个state，这时候如果第一个线程thread1调用了lock方法请求获得锁，首先会通过CAS的方式将state更新为1，表示自己thread1获得了锁，并将独占锁的线程持有者设置为thread1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">//setExclusiveOwnerThread是AbstractOwnableSynchronizer的方法，AQS继承了AbstractOwnableSynchronizer</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> **(2)**这个时候有另一个线程thread2来尝试或者锁，同样也调用lock方法，尝试通过CAS的方式将state更新为1，但是由于之前已经有线程持有了state，所以thread2这一步CAS失败（前面的thread1已经获取state并且没有释放），就会调用acquire(1)方法（该方法是AQS提供的模板方法，它会调用子类的tryAcquire方法）。非公平锁的实现中，AQS的模板方法acquire(1)就会调用NofairSync的tryAcquire方法，而tryAcquire方法又调用的Sync的nonfairTryAcquire方法，所以我们看看nonfairTryAcquire的流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NofairSync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//（1）获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//（2）获得当前同步状态state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//（3）如果state==0，表示没有线程获取</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//（3-1）那么就尝试以CAS的方式更新state的值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//（3-2）如果更新成功，就设置当前独占模式下同步状态的持有者为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="comment">//（3-3）获得成功之后，返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（4）这里是重入锁的逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">//（4-1）判断当前占有state的线程就是当前来再次获取state的线程之后，就计算重入后的state</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">//（4-2）这里是风险处理</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">//（4-3）通过setState无条件的设置state的值，（因为这里也只有一个线程操作state的值，即</span></span><br><span class="line">        <span class="comment">//已经获取到的线程，所以没有进行CAS操作）</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（5）没有获得state，也不是重入，就返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结来说就是：</p>
<p>1、获取当前将要去获取锁的线程thread2。</p>
<p>2、获取当前AQS的state的值。如果此时state的值是0，那么我们就通过CAS操作获取锁，然后设置AQS的线程占有者为thread2。很明显，在当前的这个执行情况下，state的值是1不是0，因为我们的thread1还没有释放锁。所以CAS失败，后面第3步的重入逻辑也不会进行</p>
<p>3、如果当前将要去获取锁的线程等于此时AQS的exclusiveOwnerThread的线程，则此时将state的值加1，这是重入锁的实现方式。</p>
<p>4、最终thread2执行到这里会返回false。</p>
<p> **(3)**上面的thread2加锁失败，返回false。那么根据开始我们讲到的AQS概述就应该将thread2构造为一个Node结点加入同步队列中。因为NofairSync的tryAcquire方法是由AQS的模板方法acquire()来调用的，那么我们看看该方法的源码以及执行流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(1)tryAcquire，这里thread2执行返回了false，那么就会执行addWaiter将当前线程构造为一个结点加入同步队列中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 那么我们就看一下addWaiter方法的执行流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1)将当前线程以及阻塞原因(是因为SHARED模式获取state失败还是EXCLUSIVE获取失败)构造为Node结点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//(2)这一步是快速将当前线程插入队列尾部</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//(2-1)将构造后的node结点的前驱结点设置为tail</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//(2-2)以CAS的方式设置当前的node结点为tail结点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">//(2-3)CAS设置成功，就将原来的tail的next结点设置为当前的node结点。这样这个双向队</span></span><br><span class="line">            <span class="comment">//列就更新完成了</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(3)执行到这里，说明要么当前队列为null，要么存在多个线程竞争失败都去将自己设置为tail结点，</span></span><br><span class="line">    <span class="comment">//那么就会有线程在上面（2-2）的CAS设置中失败，就会到这里调用enq方法</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 那么总结一下add Waiter方法</p>
<p> 1、将当前将要去获取锁的线程也就是thread2和独占模式封装为一个node对象。</p>
<p> 2、尝试快速的将当前线程构造的node结点添加作为tail结点(这里就是直接获取当前tail，然后将node的前驱结点设置为tail)，并且以CAS的方式将node设置为tail结点(CAS成功后将原tail的next设置为node，然后这个队列更新成功)。</p>
<p> 3、如果2设置失败，就进入enq方法。</p>
<p> 在刚刚的thread1和thread2的环境下，开始时候线程阻塞队列是空的(因为thread1获取了锁，thread2也是刚刚来请求锁，所以线程阻塞队列里面是空的)。很明显，这个时候队列的尾部tail节点也是null，那么将直接进入到enq方法。所以我们看看enq方法的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//(4)还是先获取当前队列的tail结点</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//(5)如果tail为null，表示当前同步队列为null，就必须初始化这个同步队列的head和tail（建</span></span><br><span class="line">        <span class="comment">//立一个哨兵结点）</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">//（5-1）初始情况下，多个线程竞争失败，在检查的时候都发现没有哨兵结点，所以需要CAS的</span></span><br><span class="line">            <span class="comment">//设置哨兵结点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//(6)tail不为null</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//(6-1)直接将当前结点的前驱结点设置为tail结点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">//(6-2)前驱结点设置完毕之后，还需要以CAS的方式将自己设置为tail结点，如果设置失败，</span></span><br><span class="line">            <span class="comment">//就会重新进入循环判断一遍</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> enq方法内部是一个自旋循环，第一次循环默认情况如下图所示</p>
<p> 1、首先代码块（4）处将t指向了tail，判断得到t==null，如图(1)所示；</p>
<p> 2、于是需要新建一个哨兵结点作为整个同步队列的头节点(代码块5-1处执行)</p>
<p> 3、完了之后如图(2)所示。这样第一次循环执行完毕。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114125.png" alt="img"></p>
<p> 第二次循环整体执行如下图所示。</p>
<p> 1、还是先获取当前tail结点然后将t指向tail结点。如下图的(3)</p>
<p> 2、然后判断得到当前t!=null，所以enq方法中进入代码块(6).</p>
<p> 3、在(6-1)代码块中将node的前驱结点设置为原来队列的tail结点，如下图的(4)所示。</p>
<p> 4、设置完前驱结点之后，代码块(6-2)会以CAS的方式将当前的node结点设置为tail结点,如果设置成功，就会是下图(5)所示。更新完tail结点之后，需要保证双向队列的，所以将原来的指向哨兵结点的t的next结点指向node结点，如下图(6)所示。最后返回</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114131.png" alt="img"></p>
<p> 总结来说，即使在多线程情况下，enq方法还是能够保证每个线程结点会被安全的添加到同步队列中，因为enq通过CAS方式将结点添加到同步队列之后才会返回，否则就会不断尝试添加(这样实际上就是在并发情况下，把向同步队列添加Node变得串行化了)</p>
<p> **(4)**在上面AQS的模板方法中，acquire()方法还有一步acquireQueued，这个方法的主要作用就是在同步队列中嗅探到自己的前驱结点，如果前驱结点是头节点的话就会尝试取获取同步状态，否则会先设置自己的waitStatus为-1，然后调用LockSupport的方法park自己。具体的实现如下面代码所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//在这样一个循环中尝试tryAcquire同步状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//(1)如果前驱结点是头节点，就尝试取获取同步状态，这里的tryAcquire方法相当于还是调</span></span><br><span class="line">            <span class="comment">//用NofairSync的tryAcquire方法，在上面已经说过</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//如果前驱结点是头节点并且tryAcquire返回true，那么就重新设置头节点为node</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">//将原来的头节点的next设置为null，交由GC去回收它</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//(2)如果不是头节点,或者虽然前驱结点是头节点但是尝试获取同步状态失败就会将node结点</span></span><br><span class="line">            <span class="comment">//的waitStatus设置为-1(SIGNAL),并且park自己，等待前驱结点的唤醒。至于唤醒的细节</span></span><br><span class="line">            <span class="comment">//下面会说到</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在上面的代码中我们可以看出，这个方法也是一个自旋循环，继续按照刚刚的thread1和thread2这个情况分析。在enq方法执行完之后，同步队列的情况大概如下所示。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114138.png" alt="img"></p>
<p>当前的node结点的前驱结点为head，所以会调用tryAcquire()方法去获得同步状态。但是由于state被thread1占有，所以tryAcquire失败。这里就是执行acquireQueued方法的代码块(2)了。代码块(2)中首先调用了shouldParkAfterFailedAcquire方法，该方法会将同步队列中node结点的前驱结点的waitStatus为CANCELLED的线程移除，并将当前调用该方法的线程所属结点自己和他的前驱结点的waitStatus设置为-1(SIGNAL)，然后返回。具体方法实现如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//（1）获取前驱结点的waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//（2）如果前驱结点的waitStatus为SINGNAL，就直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//前驱结点的状态为SIGNAL，那么该结点就能够安全的调用park方法阻塞自己了。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//（3）这里就是将所有的前驱结点状态为CANCELLED的都移除</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//CAS操作将这个前驱节点设置成SIGHNAL。</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 所以shouldParkAfterFailedAcquire方法执行完毕，现在的同步队列情况大概就是这样子，即哨兵结点的waitStatus值变为-1。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114141.png" alt="img"></p>
<p>上面的执行完毕返回到acquireQueued方法的时候，在acquireQueued方法中就会进行第二次循环了，但是还是获取state失败，而当再次进入shouldParkAfterFailedAcquire方法的时候，当前结点node的前驱结点head的waitStatus已经为-1(SIGNAL)了，就会返回true，然后acquireQueued方法中就会接着执行parkAndCheckInterrupt将自己park阻塞挂起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> **(5)**我们梳理一下整个方法调用的流程，假设现在又有一个thread3线程竞争这个state，那么这个方法调用的流程是什么样的呢。</p>
<p> ①首先肯定是调用**ReentrantLock.lock()**方法去尝试加锁;</p>
<p> ②因为是非公平锁，所以就会转到调用**NoFairSync.lock()**方法;</p>
<p> ③在NoFairSync.lock()方法中，会首先尝试设置state的值，因为已经被占有那么肯定就是失败的。这时候就会调用AQS的模板方法**AQS.acquire(1)**。</p>
<p> ④在AQS的模板方法acquire(1)中，实际首先会调用的是子类的tryAcquire()方法，而在非公平锁的实现中即**Sync.nofairTryAcquire()**方法。</p>
<p> ⑤显然tryAcquire()会返回false，所以acquire()继续执行，即调用**AQS.addWaiter()**，就会将当前线程构造称为一个Node结点,初始状况下waitStatus为0。</p>
<p> ⑥在addWaiter方法中，会首先尝试直接将构建的node结点以CAS的方式(存在多个线程尝试将自己设置为tail)设置为tail结点，如果设置成功就直接返回，失败的话就会进入一个自旋循环的过程。即调用**enq()**方法。最终保证自己成功被添加到同步队列中。</p>
<p> ⑦加入同步队列之后，就需要将自己挂起或者嗅探自己的前驱结点是否为头结点以便尝试获取同步状态。即调用**acquireQueued()**方法。</p>
<p> ⑧在这里thread3的前驱结点不是head结点，所以就直接调用**shouldParkAfterFailedAcquire()**方法，该方法首先会将刚刚的thread2线程结点中的waitStatue的值改变为-1(初始的时候是没有改变这个waitStatus的，每个新节点的添加就会改变前驱结点的waitStatus值)。</p>
<p> ⑨thread2所在结点的waitStatus改变后，shouldParkAfterFailedAcquire方法会返回false。所以之后还会在acquireQueued中进行第二次循环。并再次调用shouldParkAfterFailedAcquire方法，然后返回true。最终调用**parkAndCheckInterrupt()**将自己挂起。</p>
<p> 每个线程去竞争这个同步状态失败的话大概就会经历上面的这些过程。假设现在thread3经历上面这些过程之后也进入同步队列，那么整个同步队列大概就是下面这样了.</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114215.png" alt="image-20210223114214953"></p>
<p> 将上面的流程整理一下大概就是下面这个图</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114151.png" alt="img"></p>
<h3 id="非公平锁的释放流程"><a href="#非公平锁的释放流程" class="headerlink" title="非公平锁的释放流程"></a>非公平锁的释放流程</h3><p>上面说一ReentrantLock为例到了怎样去获得非公平锁，那么thread1获取锁，执行完释放锁的流程是怎样的呢。首先肯定是在finally中调用ReentrantLock.unlock()方法，所以我们就从这个方法开始看起。</p>
<p> **(1)**从下面的unlock方法中我们可以看出，实际上是调用AQS的release()方法，其中传递的参数为1，表示每一次调用unlock方法都是释放所获得的一次state。重入的情况下会多次调用unlock方法，也保证了lock和unlock是成对的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>); <span class="comment">//这里ReentrantLock的unlock方法调用了AQS的release方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里调用了子类的tryRelease方法，即ReentrantLock的内部类Sync的tryRelease方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> **(2)**上面看到release方法首先会调用ReentrantLock的内部类Sync的tryRelease方法。而通过下面代码的分析，大概知道tryRelease做了这些事情。</p>
<p> ①获取当前AQS的state，并减去1；</p>
<p> ②判断当前线程是否等于AQS的exclusiveOwnerThread，如果不是，就抛IllegalMonitorStateException异常，这就保证了加锁和释放锁必须是同一个线程；</p>
<p> ③如果(state-1)的结果不为0，说明锁被重入了，需要多次unlock，这也是lock和unlock成对的原因；</p>
<p> ④如果(state-1)等于0，我们就将AQS的ExclusiveOwnerThread设置为null；</p>
<p> ⑤如果上述操作成功了，也就是tryRelase方法返回了true；返回false表示需要多次unlock。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//（1）获取当前的state，然后减1，得到要更新的state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">//（2）判断当前调用的线程是不是持有锁的线程，如果不是抛出IllegalMonitorStateException</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//（3）判断更新后的state是不是0</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//（3-1）将当前锁持者设为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（4）设置当前state=c=getState()-releases</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="comment">//（5）只有state==0，才会返回true</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> **(3)**那么当tryRelease返回true之后，就会执行release方法中if语句块中的内容。从上面我们看到，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">//（1）获取当前队列的头节点head</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">//（2）判断头节点不为null，并且头结点的waitStatus不为0(CACCELLED)</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//（3-1）调用下面的方法唤醒同步队列head结点的后继结点中的线程</span></span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> **(4)**在获取锁的流程分析中，我们知道当前同步队列如下所示，所以判断得到head!=null并且head的waitStatus=-1。所以会执行unparkSuccessor方法，传递的参数为指向head的一个引用h.那下面我们就看看unparkSuccessor方法中处理了什么事情。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114221.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//（1）获得node的waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">//（2）判断waitStatus是否小于0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//（2-1）如果waitStatus小于0需要将其以CAS的方式设置为0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（2）获得s的后继结点，这里即head的后继结点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//（3）判断后继结点是否已经被移除，或者其waitStatus==CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//（3-1）如果s！=null，但是其waitStatus=CANCELLED需要将其设置为null</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//（3-2）会从尾部结点开始寻找，找到离head最近的不为null并且node.waitStatus的结点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（4）node.next!=null或者找到的一个离head最近的结点不为null</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//（4-1）唤醒这个结点中的线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 从上面的代码实现中可以总结，unparkSuccessor主要做了两件事情:</p>
<p> ①获取head节点的waitStatus，如果小于0，就通过CAS操作将head节点的waitStatus修改为0</p>
<p> ②寻找head节点的下一个节点，如果这个节点的waitStatus小于0，就唤醒这个节点，否则遍历下去，找到第一个waitStatus&lt;=0的节点，并唤醒。</p>
<p> **(5)**下面我们应该分析的是释放掉state之后，唤醒同步队列中的结点之后程序又是是怎样执行的。按照上面的同步队列示意图，那么下面会执行这些</p>
<p> <strong>①</strong>thread1(获取到锁的线程)调用unlock方法之后，最终执行到unparkSuccessor方法会唤醒thread2结点。<strong>所以thread2被unpark</strong>。</p>
<p> <strong>②</strong>再回想一下，当时thread2是在调用acquireQueued方法之后的parkAndCheckInterrupt里面被park阻塞挂起了，所以thread2被唤醒之后<strong>继续执行acquireQueued方法中的for循环</strong>（到这里可以往前回忆看一下acquireQueued方法中的for循环做了哪些事情）；</p>
<p> <strong>③</strong>for循环中做的第一件事情就是<strong>查看自己的前驱结点是不是头结点</strong>（按照上面的同步队列情况是满足的）；</p>
<p> <strong>④</strong>前驱结点是head结点，就会<strong>调用tryAcquire方法尝试获取state</strong>，因为thread1已经释放了state，即state=0，所以thread2调用tryAcquire方法时候，以<strong>CAS的方式去将state从0更新为1是成功的</strong>，所以这个时候<strong>thread2就获取到了锁</strong></p>
<p> <strong>⑤</strong>thread2获取state成功，就会从acquireQueued方法中退出。注意这时候的acquireQueued返回值为false，所以在AQS的模板方法的acquire中会直接从if条件退出，最后执行自己锁住的代码块中的程序。</p>
<h3 id="varhandle"><a href="#varhandle" class="headerlink" title="varhandle"></a>varhandle</h3><p>jdk1.9新增的，可以实现原子性操作</p>
<p>原文地址：<a href="https://www.cnblogs.com/fsmly/p/11274572.html#_labelTop">https://www.cnblogs.com/fsmly/p/11274572.html#_labelTop</a></p>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程常见的同步机制</title>
    <url>/posts/e8a097d2/</url>
    <content><![CDATA[<h3 id="ReentrantLock（可重入锁）"><a href="#ReentrantLock（可重入锁）" class="headerlink" title="ReentrantLock（可重入锁）"></a>ReentrantLock（可重入锁）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>​    ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，<strong>支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞</strong>。在java关键字synchronized隐式支持重入性，synchronized通过获取自增，释放自减的方式实现重入。与此同时，ReentrantLock还支持<strong>公平锁和非公平锁</strong>两种方式。那么，要想完完全全的弄懂ReentrantLock的话，主要也就是ReentrantLock同步语义的学习：<strong>1. 重入性的实现原理；2. 公平锁和非公平锁</strong></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>ReentrantLock常常对比着synchronized来分析</p>
<p>ReentrantLock常常对比着synchronized来分析，我们先对比着来看然后再一点一点分析。</p>
<p>（1）synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活。ReentrantLock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。</p>
<p>（2）synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。（<strong>ReentrantLock等lock方法一定要在finally进行unlock</strong>）</p>
<p>（3）synchronized不可响应中断，一个线程获取不到锁就一直等着；ReentrantLock可以相应中断。</p>
<p>（4 ）ReentrantLock和synchronized最主要的就<strong>区别是ReentrantLock还可以实现公平锁机制</strong>。也就是在锁上等待时间最长的线程将获得锁的使用权。通俗的理解就是谁排队时间最长谁先执行获取锁（不公平锁是只要锁被释放，其他线程一起争抢锁）</p>
<h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><p> 从ReentrantLock的构造中可以看到，ReentrantLock提供两种锁：公平锁和非公平锁，其内部实现了两种同步器<strong>NonfairSync</strong>、<strong>FairSync</strong>派生自<strong>AQS</strong>，主要才采用了模板方法模式，主要<strong>重写了AQS的tryAcquire、lock方法</strong></p>
<h4 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a>ReentrantLock的实现原理</h4><p>ReentrantLock在内部使用了内部类Sync来管理锁，所以真正的获取锁是由Sync的实现类控制的。Sync有两个实现，分别为NonfairSync（非公平锁）和FairSync（公平锁）。Sync通过继承AQS实现，在AQS中维护了一个<strong>private volatile int state</strong>来计数重入次数，避免了频繁的持有释放操作带来效率问题。所以说本质上常见的同步锁是使用CAS+volatile来实现的</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_ReentrantLock2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//非公平锁</span></span><br><span class="line">	Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock(); <span class="comment">//synchronized(this)</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">				System.out.println(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			System.out.println(<span class="string">&quot;m2 ...&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T02_ReentrantLock2 rl = <span class="keyword">new</span> T02_ReentrantLock2();</span><br><span class="line">		<span class="keyword">new</span> Thread(rl::m1).start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">new</span> Thread(rl::m2).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果</span><br><span class="line">==========================================</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">m2 ...     </span><br><span class="line">==========================================  </span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li> 发现该操作已经在执行中则不再执行</li>
<li>如果该操作已经在执行，则等待一个个执行（同步执行，与synchronized类似）</li>
<li>如果该操作已经在执行，则尝试等待一段时间，超时则放弃执行</li>
<li>如果发现该操作已经在执行，等待执行。这时可中断正在进行的操作立刻释放锁继续下一操作</li>
</ul>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul>
<li>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</li>
<li>CountDownLatch是一个同步容器，但是有人叫它发令枪，也有人叫它门闩。初始化设定线程的个数，调用countDownLatch.await()阻塞所有线程，直到countDownLatch.countDown()为0，那么将继续执行剩余的操作。</li>
</ul>
<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><ul>
<li><p>countDownLatch类中只提供了一个构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>类中有三个方法是最重要的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;   </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;  </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new CountDownLatch(2);这里设置成2是因为下面只创建了两个新线程，如果大于2，则会到countDownLatch.countDown()方法中不肯能为0.导致主线程一直阻塞</span></span><br><span class="line">       <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始执行&quot;</span>);</span><br><span class="line">        <span class="comment">//第一个子线程开始执行</span></span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// countDownLatch.countDown(); 这一句话要写在finally中，不然的话出现异常会导致无法减一，然后出现死锁的</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">//第二个子线程开始执行</span></span><br><span class="line">        ExecutorService executorService2 = Executors.newSingleThreadExecutor();</span><br><span class="line">        executorService2.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService2.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待两个线程执行完毕&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;两个子线程执行完毕，继续执行主线程&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">========================================</span><br><span class="line">主线程开始执行</span><br><span class="line">等待两个线程执行完毕</span><br><span class="line">子线程pool-<span class="number">2</span>-thread-<span class="number">1</span></span><br><span class="line">子线程pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">两个子线程执行完毕，继续执行主线程</span><br><span class="line">主线程执行完毕</span><br><span class="line">========================================</span><br><span class="line">使用CountDownLatch使主线程阻塞，直到线程<span class="number">1</span>，<span class="number">2</span>执行完主线程才会继续执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>游戏多线程加载图片，音乐等相关资源，需要全部加载完必须的资源才能正常的进入游戏</li>
</ul>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>从字面上的意思可以知道，这个类的中文意思是“循环栅栏”。大概的意思就是一个可循环利用的屏障。它的作用就是会让所有线程都等待完成后才会继续下一步行动</p>
<p>例子：当你和朋友一起吃饭，有人先到，有人后到，正常情况下就会等到一起才会点菜吃饭</p>
<h4 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h4><ul>
<li>CyclicBarrier提供了一个构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示需要等到几个线程一起才能执行下一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"> <span class="comment">//parties 是参与线程的个数， Runnable 参数，这个参数的意思是最后一个到达线程要做的任务</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction这个线程做什么处理)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>类中有两个重要方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程调用 await() 表示自己已经到达栅栏</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span></span><br><span class="line"><span class="function"><span class="comment">//BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span></span><br></pre></td></tr></table></figure>

<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_TestCyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        CyclicBarrier barrier = new CyclicBarrier(20);</span></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">20</span>, () -&gt; System.out.println(<span class="string">&quot;满20&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=====================================</span><br><span class="line">满<span class="number">20</span></span><br><span class="line">满<span class="number">20</span></span><br><span class="line">满<span class="number">20</span></span><br><span class="line">满<span class="number">20</span></span><br><span class="line">满<span class="number">20</span></span><br></pre></td></tr></table></figure>

<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>可以用于多线程计算数据，最后合并计算结果的场景。</li>
</ul>
<h3 id="phaser"><a href="#phaser" class="headerlink" title="phaser"></a>phaser</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>​    phaser与CountDownLatch非常相似，允许我们协调线程的执行。与CountDownLatch相比，它具有一些额外的功能。Phaser是在线程动态数需要继续执行之前等待的屏障。在CountDownLatch中，该数字无法动态配置，需要在创建实例时提供</p>
<h4 id="主要方法-2"><a href="#主要方法-2" class="headerlink" title="主要方法"></a>主要方法</h4><ul>
<li>构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造默认阶段数为0，创建一个没有初始注册方，没有父级且初始阶段号为0的新相位器。使用此相位器的任何线程都需要首先为其注册  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建指定数量为parties的相位器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, parties);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>核心方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//使线程阻塞，等待指定线程数目之后再继续运行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndAwaitAdvance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//注销到达的相关线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndDeregister</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//注册一个新线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doRegister(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_TestPhaser2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">static</span> MarriagePhaser phaser = <span class="keyword">new</span> MarriagePhaser();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        phaser.bulkRegister(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;p&quot;</span> + i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;新郎&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;新娘&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MarriagePhaser</span> <span class="keyword">extends</span> <span class="title">Phaser</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">//该方法会在phaser.arriveAndAwaitAdvance();进行相关判断，phase阶段一定是从0开始进行系列操作，只有当前Phaser中有指定数量的线程时才会进行运行</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (phase) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人到齐了！&quot;</span> + registeredParties);</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人吃完了！&quot;</span> + registeredParties);</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人离开了！&quot;</span> + registeredParties);</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;婚礼结束！新郎新娘抱抱！&quot;</span> + registeredParties);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">milliSleep</span><span class="params">(<span class="keyword">int</span> milli)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(milli);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            milliSleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s 到达现场！\n&quot;</span>, name);</span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            milliSleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s 吃完!\n&quot;</span>, name);</span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            milliSleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s 离开！\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(<span class="string">&quot;新郎&quot;</span>) || name.equals(<span class="string">&quot;新娘&quot;</span>)) &#123;</span><br><span class="line">                milliSleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s 洞房！\n&quot;</span>, name);</span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phaser.arriveAndDeregister();</span><br><span class="line">          <span class="comment">/*      phaser.register();</span></span><br><span class="line"><span class="comment">                System.out.println(phaser.getPhase());*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            arrive();</span><br><span class="line">            eat();</span><br><span class="line">            leave();</span><br><span class="line">            hug();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">======================================</span><br><span class="line">p3 到达现场！</span><br><span class="line">新郎 到达现场！</span><br><span class="line">p2 到达现场！</span><br><span class="line">p1 到达现场！</span><br><span class="line">p0 到达现场！</span><br><span class="line">p4 到达现场！</span><br><span class="line">新娘 到达现场！</span><br><span class="line">所有人到齐了！<span class="number">7</span></span><br><span class="line"></span><br><span class="line">新娘 吃完!</span><br><span class="line">p0 吃完!</span><br><span class="line">p1 吃完!</span><br><span class="line">p4 吃完!</span><br><span class="line">新郎 吃完!</span><br><span class="line">p2 吃完!</span><br><span class="line">p3 吃完!</span><br><span class="line">所有人吃完了！<span class="number">7</span></span><br><span class="line"></span><br><span class="line">p0 离开！</span><br><span class="line">p3 离开！</span><br><span class="line">新郎 离开！</span><br><span class="line">新娘 离开！</span><br><span class="line">p2 离开！</span><br><span class="line">p4 离开！</span><br><span class="line">p1 离开！</span><br><span class="line">所有人离开了！<span class="number">7</span></span><br><span class="line"></span><br><span class="line">新娘 洞房！</span><br><span class="line">新郎 洞房！</span><br><span class="line">婚礼结束！新郎新娘抱抱！<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>在需要对数据进行拦截的时候</li>
</ul>
<h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>ReadWriteLock是JDK5中提供的读写分离锁。读写分离锁可以有效地帮助减少锁竞争，以提高系统性能</p>
<p>读写锁允许多个线程同时读，使得B1,B2,B3之间真正并行。但是，考虑都数据完整性，<strong>写写操作和读写操作间依然时需要相互等待和持有锁的</strong></p>
<h4 id="主要方法-3"><a href="#主要方法-3" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读锁</span></span><br><span class="line"><span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//写锁</span></span><br><span class="line"><span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T10_TestReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">static</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;read over!&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Lock lock, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            value = v;</span><br><span class="line">            System.out.println(<span class="string">&quot;write over!&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟写操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable readR = ()-&gt; read(readLock);</span><br><span class="line">        Runnable writeR = ()-&gt;write(writeLock, <span class="keyword">new</span> Random().nextInt());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) <span class="keyword">new</span> Thread(readR).start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) <span class="keyword">new</span> Thread(writeR).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==========</span><br><span class="line">read over!</span><br><span class="line">read over!</span><br><span class="line">read over!</span><br><span class="line">read over!</span><br><span class="line">read over!</span><br><span class="line">write over!</span><br><span class="line">write over!</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><p>semaphore 是一个计数信号量，必须由获取它的线程释放。</p>
<p>常用于限制可以访问某些资源的线程数量，例如通过 Semaphore 限流。</p>
<p>Semaphore 只有3个操作：</p>
<ol>
<li>初始化</li>
<li>增加</li>
<li>减少</li>
</ol>
<h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T11_TestSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Semaphore s = new Semaphore(2);</span></span><br><span class="line">        Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">2</span>, <span class="keyword">true</span>);<span class="comment">//设置是否是公平锁，默认是非公平锁</span></span><br><span class="line">        <span class="comment">//允许一个线程同时执行</span></span><br><span class="line">        <span class="comment">//Semaphore s = new Semaphore(1);</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//进行请求</span></span><br><span class="line">                s.acquire();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;T1 running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;T1 running...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                s.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;T2 running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;T2 running...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                s.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==========================</span><br><span class="line">T1 running...</span><br><span class="line">T2 running...</span><br><span class="line">T1 running...</span><br><span class="line">T2 running...</span><br></pre></td></tr></table></figure>



<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><h4 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h4><p>一个用于两个工作线程之间交换数据的封装工具类，简单说就是一个线程在完成一定的事务后想与另一个线程交换数据，则第一个先拿出数据的线程会一直等待第二个线程，直到第二个线程拿着数据到来时才能彼此交换对应数据</p>
<h4 id="主要方法-4"><a href="#主要方法-4" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exchanger()：无参构造方法。</span><br><span class="line"><span class="function">V <span class="title">exchange</span><span class="params">(V v)</span>：等待另一个线程到达此交换点（除非当前线程被中断），然后将给定的对象传送给该线程，并接收该线程的对象。</span></span><br><span class="line"><span class="function">V <span class="title">exchange</span><span class="params">(V v, <span class="keyword">long</span> timeout, TimeUnit unit)</span>：等待另一个线程到达此交换点（除非当前线程被中断或超出了指定的等待时间），然后将给定的对象传送给该线程，并接收该线程的对象。</span></span><br></pre></td></tr></table></figure>



<h4 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T12_TestExchanger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * exchanger只能是两个线程之间，多个线程需要进行线程同步</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String s = <span class="string">&quot;T1&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//在此会阻塞等待T2线程进行数据交换</span></span><br><span class="line">                s = exchanger.exchange(s);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + s);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String s = <span class="string">&quot;T2&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s = exchanger.exchange(s);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + s);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=============================</span><br><span class="line">t2 T1</span><br><span class="line">t1 T2</span><br></pre></td></tr></table></figure>



<h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><h4 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h4><p>LockSupport是一个线程工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞，也可以在任意位置唤醒。它的内部其实两类主要的方法：<strong>park</strong>（停车阻塞线程）和<strong>unpark</strong>（启动唤醒线程）。</p>
<h4 id="主要方法-5"><a href="#主要方法-5" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span></span>; <span class="comment">// 暂停当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span></span>; <span class="comment">// 暂停当前线程，不过有超时时间的限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span></span>; <span class="comment">// 暂停当前线程，直到某个时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span></span>; <span class="comment">// 无期限暂停当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(<span class="keyword">long</span> nanos)</span></span>; <span class="comment">// 暂停当前线程，不过有超时时间的限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(<span class="keyword">long</span> deadline)</span></span>; <span class="comment">// 暂停当前线程，直到某个时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span>; <span class="comment">// 恢复当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBlocker</span><span class="params">(Thread t)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T13_TestLockSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="comment">//                    当前线程停止，进入到阻塞状态</span></span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//LockSupport.park()之后，可以使用unpark方法使进程继续运行</span></span><br><span class="line">        <span class="comment">//不进行 LockSupport.unpark(t)则会导致线程一直都会阻塞</span></span><br><span class="line">       LockSupport.unpark(t);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="park和unpark的优点"><a href="#park和unpark的优点" class="headerlink" title="park和unpark的优点"></a>park和unpark的优点</h4><p><strong>一个线程它有可能在别的线程unPark之前，或者之后，或者同时调用了park，那么因为park的特性，它可以不用担心自己的park的时序问题，否则，如果park必须要在unpark之前，那么给编程带来很大的麻烦！！</strong></p>
<p>考虑一下，两个线程同步，要如何处理？</p>
<p>在Java5里是用wait/notify/notifyAll来同步的。wait/notify机制有个很蛋疼的地方是，比如<strong>线程B要用notify通知线程A，那么线程B要确保线程A已经在wait调用上等待了，否则线程A可能永远都在等待。</strong>另外，<strong>是调用notify，还是notifyAll？</strong></p>
<p>notify只会唤醒一个线程，如果错误地有两个线程在同一个对象上wait等待，那么又悲剧了。为了安全起见，貌似只能调用notifyAll了。</p>
<p><strong>park/unpark模型真正解耦了线程之间的同步，线程之间不再需要一个Object或者其它变量来存储状态，不再需要关心对方的状态。</strong></p>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程2</title>
    <url>/posts/56eb878c/</url>
    <content><![CDATA[<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><p>保证线程可见性</p>
<p><strong>使用volatile，将会强制所有线程都去堆内存中读取变量的值</strong></p>
<p>-MESI（CPU的缓存一致性协议）</p>
<p><strong>详细可看</strong></p>
<p><a href="https://www.cnblogs.com/z00377750/p/9180644.html">https://www.cnblogs.com/z00377750/p/9180644.html</a></p>
</li>
<li><p>禁止指令重排序（CPU级别的支持）</p>
<ul>
<li>cpu级别增加读写屏障</li>
</ul>
</li>
</ul>
<h4 id="图解说明："><a href="#图解说明：" class="headerlink" title="图解说明："></a>图解说明：</h4><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113818.png" alt="image-20200814153856725"></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道，不知B线程何时去修改真正的变量的值，此时使用volatile关键字，会让所有线程都会读到变量的修改值</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="volatie和synchronized区别"><a href="#volatie和synchronized区别" class="headerlink" title="volatie和synchronized区别"></a>volatie和synchronized区别</h4><ul>
<li><p>volatile本质是在告诉<strong>jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取</strong>； synchronized则是<strong>锁定当前变量</strong>，只有当<strong>前线程可以访问</strong>该变量，<strong>其他线程被阻塞住</strong>。</p>
</li>
<li><p>volatile<strong>仅能使用在变量级别</strong>；synchronized则可以使用<strong>在变量、方法、和类级别</strong>的</p>
</li>
<li><p>volatile<strong>仅能实现变量的修改可见性</strong>，<strong>不能保证原子性</strong>；而<strong>synchronized则可以保证变量的修改可见性和原子性</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile并不能保证多个线程共同修改变量时所带来的不一致问题，也就是说volatile不能替代synchronized</span><br></pre></td></tr></table></figure>


</li>
<li><p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞</p>
</li>
<li><p>volatile标记的变量<strong>不会被编译器优化，不会进行指令重排序</strong>；synchronized标记的变量可以<strong>被编译器优化</strong></p>
</li>
</ul>
<h4 id="volatile其他"><a href="#volatile其他" class="headerlink" title="volatile其他"></a>volatile其他</h4><ol>
<li><p><strong>volatile 引用类型（包括数组）只能保证引用本身的可见性</strong>，不能保证内部字段的可见性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_VolatileNotSync</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) count++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T04_VolatileNotSync t = <span class="keyword">new</span> T04_VolatileNotSync();</span><br><span class="line">		</span><br><span class="line">		List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">			threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">&quot;thread-&quot;</span>+i));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		threads.forEach((o)-&gt;o.start());</span><br><span class="line">		</span><br><span class="line">		threads.forEach((o)-&gt;&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				o.join();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		System.out.println(t.count);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line"> 输出结果的原因是：<span class="keyword">volatile</span>虽然能够保证count的可见性，但是不能够保障count++的原子性</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113823.png" alt="image-20200814160705502"></p>
</li>
</ol>
<h3 id="CAS（compare-and-swap）"><a href="#CAS（compare-and-swap）" class="headerlink" title="CAS（compare and swap）"></a>CAS（compare and swap）</h3><h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h4><p>CAS：Compare and Swap，即比较再交换。</p>
<p>jdk5增加了并发包java.util.concurrent.*,其下面的类使用CAS算法实现了区别于synchronouse同步锁的一种乐观锁。JDK 5之前Java语言是靠synchronized关键字保证同步的，这是一种独占锁，也是是悲观锁。</p>
<p><strong>CAS属于CPU原语级别的支持，正常程序不会被打断</strong></p>
<h4 id="CAS算法理解"><a href="#CAS算法理解" class="headerlink" title="CAS算法理解"></a>CAS算法理解</h4><p>CAS有3个操作数，<strong>内存值V，旧的预期值A，要修改的新值B</strong>。<strong>当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</strong></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114037.png" alt="image-20210223114037788"></p>
<h4 id="CAS实现原理"><a href="#CAS实现原理" class="headerlink" title="CAS实现原理"></a>CAS实现原理</h4><h4 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h4><ul>
<li>循环时间太长；</li>
<li>只能保证一个共享变量原子操作；</li>
<li>会出现ABA问题；</li>
</ul>
<h6 id="循环时间长开销很大："><a href="#循环时间长开销很大：" class="headerlink" title="循环时间长开销很大："></a>循环时间长开销很大：</h6><p>CAS 通常是配合无限循环一起使用的，我们可以看到 getAndAddInt 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p>
<h6 id="只能保证一个变量的原子操作："><a href="#只能保证一个变量的原子操作：" class="headerlink" title="只能保证一个变量的原子操作："></a>只能保证一个变量的原子操作：</h6><p>当对一个变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个变量操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：1）使用互斥锁来保证原子性；2）将多个变量封装成对象，通过 AtomicReference 来保证原子性。</p>
<h6 id="什么是ABA问题？ABA问题怎么解决？"><a href="#什么是ABA问题？ABA问题怎么解决？" class="headerlink" title="什么是ABA问题？ABA问题怎么解决？"></a>什么是ABA问题？ABA问题怎么解决？</h6><p>CAS 的使用流程通常如下：1）首先从地址 V 读取值 A；2）根据 A 计算目标值 B；3）通过 CAS 以原子的方式将地址 V 中的值从 A 修改为 B。</p>
<p>但是在第1步中读取的值是A，并且在第3步修改成功了，我们就能说它的值在第1步和第3步之间没有被其他线程改变过了吗？</p>
<p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的类“<strong>AtomicStampedReference</strong>”，它<strong>可以通过控制变量值的版本</strong>来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h3 id="AutomicXXX（CAS-volatile）"><a href="#AutomicXXX（CAS-volatile）" class="headerlink" title="AutomicXXX（CAS+ volatile）"></a>AutomicXXX（CAS+ volatile）</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul>
<li><p>Java从JDK1.5开始提供了java.util.concurrent.atomic包，方便程序员在多线程环境下，无锁的进行原子操作。原子变量的底层使用了处理器提供的原子指令，但是不同的CPU架构可能提供的原子指令不一样，也有可能需要某种形式的内部锁,所以该方法不能绝对保证线程不被阻塞。</p>
</li>
<li><p>原子类其内部实现不是简单的使用synchronized，而是一个更为高效的方式CAS (compare and swap) + volatile和native方法（同步的工作更多的交给了硬件），从而避免了synchronized的高开销，执行效率大为提升</p>
</li>
<li><p>虽然基于CAS的线程安全机制很好很高效，但要说的是，并非所有线程安全都可以用这样的方法来实现，这只适合一些粒度比较小，型如计数器这样的需求用起来才有效，否则也不会有锁的存在了</p>
</li>
<li><p>在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。Atomic包里的类基本都是使用Unsafe实现的包装类</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113841" alt="这里写图片描述"></p>
</li>
</ul>
<h4 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h4><p>主要以AtomicInteger为例</p>
<ul>
<li><strong>有参构造函数</strong>：从构造函数函数可以看出，数值存放在成员变量value中;</li>
<li>成员变量value声明为volatile类型，说明了多线程下的可见性，即任何一个线程的修改，在其它线程中都会被立刻看到</li>
<li><strong>compareAndSet</strong>方法（value的值通过内部this和valueOffset传递）</li>
<li>接收2个参数，一个是期望数据(expected)，一个是新数据(new)；如果atomic里面的数据和期望数据一致，则将新数据设定给atomic的数据，返回true，表明成功；否则就不设定，并返回false。</li>
</ul>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程1</title>
    <url>/posts/cfe2d636/</url>
    <content><![CDATA[<h2 id="线程的状态图"><a href="#线程的状态图" class="headerlink" title="线程的状态图"></a><strong>线程的状态图</strong></h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113754.jpg" alt="img"></p>
<ol>
<li><p>**新建(NEW)**：新创建了一个线程对象。</p>
</li>
<li><p>**可运行(RUNNABLE)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p>
</li>
<li><p>**运行(RUNNING)**：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p>
</li>
<li><p>**阻塞(BLOCKED)**：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</span><br><span class="line">(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</span><br><span class="line">(三). 其他阻塞：运行(running)的线程执行Thread.sleep(<span class="keyword">long</span> ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</span><br></pre></td></tr></table></figure>


</li>
<li><p>**死亡(DEAD)**：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run方法是thread里面的一个普通的方法，所以我们直接调用run方法，这个时候它是会运行在我们的主线程中的，因为这个时候我们的程序中只有主线程一个线程，所以如果有两个线程，都是直接调用的run方法，那么他们的执行顺序一定是顺序执行</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="启动线程方式"><a href="#启动线程方式" class="headerlink" title="启动线程方式"></a>启动线程方式</h2><ol>
<li>继承Thread</li>
<li>实现Runable接口</li>
<li>Executors.newCachedTread（线程池，本质还是上面两种方式其中一种去实现线程）</li>
<li>使用Lamda表达式（本质还是继承Thread）</li>
<li>实现Callable接口</li>
</ol>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="synchronized概述"><a href="#synchronized概述" class="headerlink" title="synchronized概述"></a>synchronized概述</h3><p><strong>synchronized是Java的内建锁，用来确保线程安全，是解决并发问题的一种重要手段</strong>,<strong>synchronized可以保证在多线程状态下，每次仅有一个线程访问共享资源</strong></p>
<p><strong>synchronized的作用主要有以下三个：</strong></p>
<ol>
<li>原子性：线程互斥的访问同步代码块，可以将小原子合成大原子</li>
<li>可见性：synchronized解锁之前，必须将工作内存中的数据同步到主内存，其它线程操作该变量时每次都可以看到被修改后的值。</li>
<li>有序性：一个线程的加锁，必须等到其它线程将锁释放；一个线程要释放锁，首先要加锁。</li>
</ol>
<h3 id="synchronized同步原理"><a href="#synchronized同步原理" class="headerlink" title="synchronized同步原理"></a>synchronized同步原理</h3><p>synchronized仅是Java中的一个关键字，在使用的过程中并没有看到显示的加锁和解锁过程。因此有必要通过<strong>javap</strong>命令，查看相应的字节码文件。</p>
<h5 id="synchronized修饰代码块"><a href="#synchronized修饰代码块" class="headerlink" title="synchronized修饰代码块"></a>synchronized修饰代码块</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁操作</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>javap查看相应的class文件：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113800.png" alt="img"></p>
<p><strong>可以看出在执行同步代码块之前之后都有一个monitor字样，其中前面的是monitorenter，后面的是离开monitorexit，不难想象一个线程也执行同步代码块，首先要获取锁，而获取锁的过程就是monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行monitorexit指令。</strong></p>
<p><strong>为什么会有两个monitorexit呢？</strong></p>
<p><strong>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</strong></p>
<h5 id="synchronized修饰方法"><a href="#synchronized修饰方法" class="headerlink" title="synchronized修饰方法"></a>synchronized修饰方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>   <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello again&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113803.png" alt="在这里插入图片描述"></p>
<p><strong>仅有ACC_SYNCHRONIZED这么一个标志，该标记表明线程进入该方法时，需要monitorenter，退出该方法时需要monitorexit。</strong></p>
<h3 id="synchronized可重入的原理"><a href="#synchronized可重入的原理" class="headerlink" title="synchronized可重入的原理"></a>synchronized可重入的原理</h3><p><strong>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。</strong>底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>JDK1.6之前，synchronized是一个重量级锁，何谓重量级锁？就是多个线程竞争同一把锁，未获得锁的线程都会被阻塞，等到持有锁的线程将锁释放之后，这些线程又被唤醒。其中线程的阻塞和唤醒都与操作系统有关，是一个极其耗费CPU资源的过程。因此为了提高synchronized的性能特地在JDK1.6做了优化</p>
<h4 id="Java对象内存模型"><a href="#Java对象内存模型" class="headerlink" title="Java对象内存模型"></a><strong>Java对象内存模型</strong></h4><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113805.png" alt="java中对象内存模型"></p>
<p>一个Java对象由，对象标记，类型指针，真实数据，内存对齐四部分组成。</p>
<ul>
<li>对象标记也称Mark Word字段，存储当前对象的一些运行时数据。</li>
<li>类型指针，JVM根据该指针确定该对象是哪个类的实例化对象。</li>
<li>真实数据自然是对象的属性值。</li>
<li>内存补齐，是当数据不是对齐数的整数倍的时候，进行调整，使得对象的整体大小是对齐数的整数倍方便寻址。典型的以空间换时间的思想。</li>
</ul>
<p><strong>其中对象标记和类型指针统称为Java对象头。</strong></p>
<h5 id="Mark-Word字段"><a href="#Mark-Word字段" class="headerlink" title="Mark Word字段"></a>Mark Word字段</h5><p>Mark Word用于存储对象自身运行时的数据，如hashcode，GC分代年龄，锁状态标志位，线程持有的锁，偏向线程ID，等等。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113808.jpg" alt="img"></p>
<h5 id="为社么Java的任意对象都可以作为锁？"><a href="#为社么Java的任意对象都可以作为锁？" class="headerlink" title="为社么Java的任意对象都可以作为锁？"></a>为社么Java的任意对象都可以作为锁？</h5><p><strong>在Java对象头中，存在一个monitor对象</strong>，每个对象自创建之后在对象头中就含有monitor对象，monitor是线程私有的，不同的对象monitor自然也是不同的，因此对象作为锁的本质是对象头中的monitor对象作为了锁。这便是为什么Java的任意对象都可以作为锁的原因。</p>
<blockquote>
<p>当对象在<strong>无锁的状态下进行了hashcode</strong>的计算（equals方法等）时，无法进入到偏向锁的状态（<strong>因为偏向锁会在前56位中记录线程id，但是如果有hashcode时无法记录id</strong>，如内存图所示）</p>
</blockquote>
<h4 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h4><h6 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h6><p>偏向锁针对的是锁不存在竞争，每次仅有一个线程来获取该锁，为了提高获取锁的效率，因此将该锁偏向该线程。提升性能。</p>
<p><strong>偏向锁的获取：</strong></p>
<blockquote>
<p>1.首先检测是否为可偏向状态（锁标识是否设置成1，锁标志位是否为01）.<br>        2.如果处于可偏向状态，测试Mark Word中的线程ID是否指向自己，如果是，不需要再次获取锁，直接执行同步代码。<br>        3.如果线程Id，不是自己的线程Id，通过CAS获取锁，获取成功表明当前偏向锁不存在竞争，获取失败，则说明当前偏向锁存在        锁竞争，偏向锁膨胀为轻量级锁。</p>
</blockquote>
<p><strong>偏向锁的撤销：</strong></p>
<p>偏向锁只有当出现竞争时，才会出现锁撤销。</p>
<blockquote>
<p>1。等待一个全局安全点，此时所有的线程都是暂停的，检查持有锁的线程状态，如果能找到说明当前线程还存活，说明还在执            行同步块中的代码，首相将该线程阻塞，然后进行锁升级，升级到轻量级锁，唤醒该线程继续执行代同步码。</p>
<p>2.如果持有偏向锁的线程未存活，将对象头中的线程置null，然后直接锁升级。</p>
</blockquote>
<h6 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a><strong>轻量级锁：</strong></h6><p>偏向锁考虑的是不存在多个线程竞争同一把锁，而轻量级锁考虑的是，多个线程不会在同一时刻来竞争同一把锁。</p>
<p><strong>轻量级锁的获取：</strong></p>
<blockquote>
<p>1.在线程的栈帧中创建用于存储锁记录得空间，</p>
<p>2.并将Mark Word复制到锁记录中，（这一步不论是否存在竞争都可以执行）。</p>
<p>3.尝试使用CAS将对象头中得Mark word字段变成指向锁记录得指针。</p>
<p>4 操作成功，不存在锁竞争，执行同步代码。</p>
<p>5操作失败，锁已经被其它线程抢占了，这时轻量级锁膨胀为重量级锁。</p>
</blockquote>
<p><strong>轻量级锁得释放：</strong></p>
<blockquote>
<p>反替换，使用CAS将栈帧中得锁录空间替换到对象头，成功没有锁竞争，锁得以释放，失败说明存在竞争，那块指向锁记录得指针有别的线程在用，因此锁膨胀升级为重量级锁。</p>
</blockquote>
<h6 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a><strong>重量级锁：</strong></h6><p>重量级锁描述同一时刻有多个线程竞争同一把锁。</p>
<blockquote>
<p>当多个线程共同竞争同一把锁时，竞争失败得锁会被阻塞，等到持有锁的线程将锁释放后再次唤醒阻塞的线程，因为线程的唤醒和阻塞是一个很耗费CPU资源的操作，因此此处采取自适应自旋来获取重量级锁来获取重量级锁。</p>
</blockquote>
<h6 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h6><p><strong>无锁 – &gt; 偏向锁 —–&gt; 轻量级锁 —- &gt; 重量级锁</strong></p>
<h6 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a>其它优化</h6><p><strong>自旋锁：</strong></p>
<p>线程未获得锁后，不是一昧的阻塞，而是让线程不断尝试获取锁。</p>
<p>缺点：若线程占用锁时间过长，导致CPU资源白白浪费。</p>
<p>解决方式：当尝试次数(一般是10次，具体看JVM的实现)达到每个值得时候，线程挂起。</p>
<p><strong>自适应自旋锁：</strong></p>
<p>自旋得次数由上一次获取锁的自旋次数决定，次数稍微延长一点点。</p>
<p><strong>锁消除</strong></p>
<p>对于线程的私有变量，不存在并发问题，没有必要加锁，即使加锁编译后，也会去掉。</p>
<p><strong>锁粗化</strong></p>
<p>当一个循环中存在加锁操作时，可以将加锁操作提到循环外面执行，一次加锁代替多次加锁，提升性能。</p>
<p><strong>执行时间短（加锁代码），线程数少，偏向用自旋锁</strong><br><strong>执行时间长，线程数多，用系统重量级</strong></p>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
</search>
