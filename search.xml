<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客文章汇总</title>
    <url>/posts/ce83d112/</url>
    <content><![CDATA[<h2 id="多线程和高并发"><a href="#多线程和高并发" class="headerlink" title="多线程和高并发"></a>多线程和高并发</h2><ol>
<li><a href="/posts/cfe2d636/" title="多线程1">多线程1</a></li>
<li><a href="/posts/56eb878c/" title="多线程2">多线程2</a></li>
<li><a href="/posts/e8a097d2/" title="多线程常见的同步机制">多线程常见的同步机制</a></li>
<li><a href="/posts/1008f972/" title="多线程的AQS">多线程的AQS</a></li>
<li><a href="/posts/d6b7922e/" title="多线程的强软弱虚四种引用">多线程的强软弱虚四种引用</a></li>
<li><a href="/posts/5c0b6c7e/" title="Java中的容器">Java中的容器</a></li>
<li><a href="/posts/de7c53fe/" title="线程池">线程池</a></li>
<li><a href="/posts/ca94e89b/" title="ThreadPoolExecutor源码解析">ThreadPoolExecutor源码解析</a>
</li>
</ol>
<h2 id="网络到分布式（集群高并发redis）"><a href="#网络到分布式（集群高并发redis）" class="headerlink" title="网络到分布式（集群高并发redis）"></a>网络到分布式（集群高并发redis）</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ol>
<li><a href="/posts/725846d4/" title="centos安装redis">centos安装redis</a></li>
<li><a href="/posts/5e07a887/" title="安装redis出现的问题">安装redis出现的问题</a></li>
<li><a href="/posts/eca8b4a8/" title="redis入门">redis入门</a></li>
<li><a href="/posts/400dad18/" title="redis快的原因">redis快的原因</a></li>
<li><a href="/posts/d09e787/" title="redis的消息订阅，pipeline，事务">redis的消息订阅，pipeline，事务</a></li>
<li><a href="/posts/dcfaa904/" title="redis持久化">redis持久化</a></li>
<li><a href="/posts/b153a32a/" title="redis集群">redis集群</a></li>
<li><a href="/posts/8f6adc3b/" title="Redis 的击穿，穿透，雪崩，分布式锁，缓存一致性">Redis 的击穿，穿透，雪崩，分布式锁，缓存一致性</a></li>
<li><a href="/posts/bfb49b3b/" title="Redis分布式锁实现">Redis分布式锁实现</a>
</li>
</ol>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ol>
<li><a href="/posts/b439f21c/" title="ZooKeeper的安装和简单操作">ZooKeeper的安装和简单操作</a></li>
<li><a href="/posts/6afaddd1/" title="分布式一致性理论，CAP，BASE理论">分布式一致性理论，CAP，BASE理论</a></li>
<li><a href="/posts/fe45d335/" title="分布式一致性协议——paxos算法">分布式一致性协议——paxos算法</a></li>
<li><a href="/posts/b369a3b6/" title="分布式一致性协议——Zab算法">分布式一致性协议——Zab算法</a></li>
<li><a href="/posts/5af4d7fe/" title="ZooKeeper集群简单介绍">ZooKeeper集群简单介绍</a></li>
<li><a href="/posts/60085ed9/" title="ZooKeeper实现分布式锁">ZooKeeper实现分布式锁</a>
</li>
</ol>
<h2 id="MySQL相关文章"><a href="#MySQL相关文章" class="headerlink" title="MySQL相关文章"></a>MySQL相关文章</h2><ol>
<li><a href="/posts/5a759233/" title="MySQL的安装与卸载">MySQL的安装与卸载</a></li>
<li><a href="/posts/4ae76812/" title="MySQL的常见命令">MySQL的常见命令</a></li>
<li><a href="/posts/c746dd2d/" title="MySQL的多表查询及约束">MySQL的多表查询及约束</a></li>
<li><a href="/posts/6b5d697/" title="MySQL的Sql执行流程">MySQL的Sql执行流程</a></li>
<li><a href="/posts/9edcaf99/" title="MySQL的索引">MySQL的索引</a></li>
<li><a href="/posts/d1898e04/" title="MySQL优化分析思路">MySQL优化分析思路</a></li>
<li><a href="/posts/f1e1e97a/" title="MySQL的优化">MySQL的优化</a></li>
<li><a href="/posts/d2eae622/" title="MySQL的事务">MySQL的事务</a></li>
<li><a href="/posts/9ee789ff/" title="MySQL的主从复制">MySQL的主从复制</a></li>
<li><a href="/posts/85c1a08/" title="MySQL的分库分表">MySQL的分库分表</a>
</li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol>
<li><a href="/posts/99e6d3f8/" title="设计模式的分类">设计模式的分类</a></li>
<li><a href="/posts/f1601c3e/" title="单例模式">单例模式</a></li>
<li><a href="/posts/91ad9ce3/" title="原型模式">原型模式</a></li>
<li><a href="/posts/48598499/" title="工厂方法模式">工厂方法模式</a></li>
<li><a href="/posts/fe816c3c/" title="建造者模式">建造者模式</a></li>
<li><a href="/posts/7b510e10/" title="代理模式">代理模式</a></li>
<li><a href="/posts/2a7709eb/" title="桥接模式的定义与特点">桥接模式的定义与特点</a></li>
<li><a href="/posts/e671036b/" title="装饰模式">装饰模式</a></li>
<li><a href="/posts/f7de8aa8/" title="外观模式">外观模式</a></li>
<li><a href="/posts/e19da94a/" title="享元模式">享元模式</a></li>
<li><a href="/posts/df879792/" title="组合模式">组合模式</a></li>
<li><a href="/posts/5029c2a3/" title="模版方法模式">模版方法模式</a></li>
<li><a href="/posts/72e3b671/" title="策略模式">策略模式</a></li>
<li><a href="/posts/78134e07/" title="命令模式">命令模式</a></li>
<li><a href="/posts/6208627e/" title="责任链模式">责任链模式</a></li>
<li><a href="/posts/9a246216/" title="观察者模式">观察者模式</a></li>
<li><a href="/posts/d036071c/" title="中介者模式">中介者模式</a></li>
<li><a href="/posts/9055d217/" title="迭代器模式">迭代器模式</a></li>
<li><a href="/posts/64b51ed9/" title="访问者模式">访问者模式</a></li>
<li><a href="/posts/f5c535ea/" title="适配器模式">适配器模式</a></li>
<li><a href="/posts/8acb1976/" title="状态模式">状态模式</a></li>
<li><a href="/posts/30cf0cd2/" title="解释器模式">解释器模式</a></li>
<li><a href="/posts/c3176455/" title="备忘录模式">备忘录模式</a>
</li>
</ol>
<h2 id="博客搭建相关"><a href="#博客搭建相关" class="headerlink" title="博客搭建相关"></a>博客搭建相关</h2><ol>
<li><a href="/posts/fd71e1c8/" title="win10的typora配置gitee云图床">win10的typora配置gitee云图床</a></li>
<li><a href="/posts/1bab7c20/" title="win10的搭建hexo博客">win10的搭建hexo博客</a></li>
<li><a href="/posts/d23fb963/" title="hexo部署第三方主题next 7.8版本">hexo部署第三方主题next 7.8版本</a></li>
<li><a href="/posts/33ffdf26/" title="hexo博客优化Next7主题优化">hexo博客优化Next7主题优化</a></li>
<li><a href="/posts/14f8dec7/" title="修复点击目录无法跳转">修复点击目录无法跳转</a></li>
<li><a href="/posts/558e0cc4/" title="win10添加新建文件md方式以及设置md模版">win10添加新建文件md方式以及设置md模版</a></li>
<li><a href="/posts/be9758cd/" title="Hexo+NexT博客归档&#x2F;标签&#x2F;分类页美化">Hexo+NexT博客归档&#x2F;标签&#x2F;分类页美化</a>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>RocketMQ高级功能</title>
    <url>/posts/a716b72/</url>
    <content><![CDATA[<h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><p>分布式队列因为有<strong>高可靠性的要求(HA)</strong>，所以数据要进行持久化存储</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506113239.png" alt="image-20210506113237530"></p>
<ol>
<li>消息生成者发送消息</li>
<li>MQ收到消息，将消息进行持久化，在存储中新增一条记录</li>
<li>MQ返回ACK给生产者</li>
<li>MQ push 消息给对应的消费者，然后等待消费者返回ACK</li>
<li>如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,重复执行4、5、6步骤</li>
<li>MQ删除消息</li>
</ol>
<h3 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h3><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><p>ActiveMQ（默认采用的KahaDB做消息存储）可选用JDBC的方式来做消息持久化，通过简单的xml配置信息即可实现JDBC消息存储。<font color=red><strong>由于，普通关系型数据库（如Mysql）在单表数据量达到千万级别的情况下，其IO读写性能往往会出现瓶颈。在可靠性方面，该种方案非常依赖DB，如果一旦DB出现故障，则MQ的消息就无法落盘存储会导致线上故障。</strong></font></p>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p><strong>RocketMQ</strong>/Kafka/RabbitMQ均采用的是消息刷盘至所部署虚拟机/物理机的文件系统来做持久化（刷盘一般可以分为异步刷盘和同步刷盘两种模式）。<strong>消息刷盘为消息存储提供了一种高效率、高可靠性和高性能的数据持久化方式。</strong>除非部署MQ机器本身或是本地磁盘挂了，否则一般是不会出现无法持久化的故障问题。</p>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>文件系统&gt;关系型数据库DB</p>
<h3 id="消息存储和发送"><a href="#消息存储和发送" class="headerlink" title="消息存储和发送"></a>消息存储和发送</h3><h4 id="消息存储-1"><a href="#消息存储-1" class="headerlink" title="消息存储"></a>消息存储</h4><p>磁盘如果使用得当，磁盘的速度完全可以匹配上网络的数据传输速度。目前的高性能磁盘，<strong>顺序写速度可以达到600MB/s</strong>， 超过了一般网卡的传输速度。但是<strong>磁盘随机写的速度只有大概100KB/s</strong>，和顺序写的性能相差6000倍！因为有如此巨大的速度差别，好的消息队列系统会比普通的消息队列系统速度快多个数量级。<strong><u>RocketMQ的消息用顺序写</u></strong>,保证了消息存储的速度。</p>
<h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p>inux操作系统分为【用户态】和【内核态】，文件操作、网络操作需要涉及这两种形态的切换，免不了进行数据复制。</p>
<p>一台服务器把本机磁盘文件的内容发送到客户端，一般分为两个步骤：</p>
<ol>
<li>read；读取本地文件内容； </li>
<li>write；将读取的内容通过网络发送出去。</li>
</ol>
<p>这两个看似简单的操作，实际进行了4 次数据复制，分别是：</p>
<ol>
<li><p>从磁盘复制数据到内核态内存；</p>
</li>
<li><p>从内核态内存复 制到用户态内存；</p>
</li>
<li><p>然后从用户态 内存复制到网络驱动的内核态内存；</p>
</li>
<li><p>最后是从网络驱动的内核态内存复 制到网卡中进行传输。</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210506114245.png" alt="image-20210506114244010"></p>
</li>
</ol>
<p>通过使用<a href="https://baike.baidu.com/item/mmap/1322217?fr=aladdin">mmap</a>的方式，可以省去向用户态的内存复制，提高速度。这种机制在Java中是通过<strong>MappedByteBuffer</strong>实现的。</p>
<p>RocketMQ充分利用了上述特性，也就是所谓的“<strong>零拷贝</strong>”技术，提高消息存盘和网络发送的速度。</p>
<blockquote>
<p>这里需要注意的是，采用MappedByteBuffer这种内存映射的方式有几个限制，其中之一是一次只能映射1.5~2G 的文件至用户态的虚拟内存，这也是为何<strong>RocketMQ默认设置单个CommitLog日志数据文件为1G</strong>的原因了。</p>
<h5 id="内存映射MappedByteBuffer-API"><a href="#内存映射MappedByteBuffer-API" class="headerlink" title="内存映射MappedByteBuffer API"></a>内存映射MappedByteBuffer API</h5><ol>
<li>MappedByteBuffer使用虚拟内存，因此分配(map)的内存大小不受JVM的-Xmx参数限制，但是也是有大小限制的。</li>
<li>如果当文件超出1.5G限制时，可以通过position参数重新map文件后面的内容。</li>
<li>MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。<br> javadoc中也提到：<strong>A mapped byte buffer and the file mapping that it represents remain* valid until the buffer itself is garbage-collected.</strong></li>
</ol>
</blockquote>
<h3 id="消息存储结构"><a href="#消息存储结构" class="headerlink" title="消息存储结构"></a>消息存储结构</h3><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成的，<strong>消息真正的物理存储文件是CommitLog</strong>，<strong>ConsumeQueue是消息的逻辑队列，类似数据库的索引文件</strong>，存储的是指向物理存储的地址。<strong>每个Topic下的每个Message Queue都有一个对应的ConsumeQueue文件。</strong></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506140631.png" alt=""></p>
<ul>
<li>CommitLog：存储消息的元数据</li>
<li>ConsumerQueue：存储消息在CommitLog的索引</li>
<li>IndexFile：为了消息查询提供了一种通过key或时间区间来查询消息的方法，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程</li>
</ul>
<h5 id="存储目录"><a href="#存储目录" class="headerlink" title="存储目录"></a>存储目录</h5><h5 id="broker-conf的常见配置"><a href="#broker-conf的常见配置" class="headerlink" title="broker.conf的常见配置"></a>broker.conf的常见配置</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">default-cluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-b</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master   - SYNC_MASTER 同步双写Master   - SLAVE 从节点</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SYNC_MASTER</span></span><br><span class="line"><span class="comment">#集群的ip</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">100.100.100.100:9876;100.100.100.101:9876</span></span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数 </span></span><br><span class="line"><span class="attr">defaultTopicQueueNums</span>=<span class="string">4</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line"><span class="attr">listenPort</span>=<span class="string">10911</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">120</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G </span></span><br><span class="line"><span class="attr">mapedFileSizeCommitLog</span>=<span class="string">1073741824 </span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整 </span></span><br><span class="line"><span class="attr">mapedFileSizeConsumeQueue</span>=<span class="string">300000 </span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line"><span class="attr">diskMaxUsedSpaceRatio</span>=<span class="string">75</span></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/data/mq/rocketmq4.3/store</span></span><br><span class="line"><span class="comment">#commitLog 存储路径 </span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/data/mq/rocketmq4.3/store/commitlog </span></span><br><span class="line"><span class="comment">#消费队列存储路径存储路径 </span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">/data/mq/rocketmq4.3/store/consumequeue</span></span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">/data/mq/rocketmq4.3/store/index</span></span><br><span class="line"><span class="comment">#checkpoint 文件存储路径 </span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">/data/mq/rocketmq4.3/store/checkpoint </span></span><br><span class="line"><span class="comment">#abort 文件存储路径 </span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">/data/mq/rocketmq4.3/store/abort </span></span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line"><span class="attr">maxMessageSize</span>=<span class="string">65536</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘 </span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘 </span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">SYNC_FLUSH</span></span><br><span class="line"><span class="comment">#并发send线程数，多线程来发送消息可能会出现broker busy</span></span><br><span class="line"><span class="attr">sendMessageThreadPoolNums</span>=<span class="string">128</span></span><br><span class="line"><span class="attr">useReentrantLockWhenPutMessage</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<ol>
<li>RocketMQ的存储目录</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506142228.png" alt="image-20210506142219636"></p>
<ol>
<li><p>commitlog目录</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506142410.png" alt="image-20210506142409666"></p>
<ul>
<li><p>使用<code>ls -lh</code>命令（RocketMQ默认设置单个commitLog大小为1G）</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210506143146.png" alt="image-20210506143145996"></p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>consumerQueue目录</p>
<ul>
<li>文件目录和Topic对应，<font color=red>一个Topic有一个对应名字的文件夹</font></li>
<li><p>进入到其中的一个Topic文件夹，发现显示出来的目录其实是对应的queue</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506143353.png" alt="image-20210506143353700"></p>
</li>
</ul>
</li>
</ol>
<blockquote>
<ul>
<li><strong>consumerqueue丢失其实是没有关系的，因为commitlog存储了消息的全部元数据信息，通过commitlog可以恢复consumerqueue文件。</strong></li>
<li><strong>consumerqueue存储的消息的偏移量，其实就是消息的索引，所以consumerqueue其实是根据消息的偏移量查询消息的。</strong></li>
</ul>
</blockquote>
<ol>
<li><p>index目录</p>
<p> 一个索引文件，这其实是rocketmq为我们提供的另一种的消息的查询方式，<strong>index是通过key或者时间区间来查询消息的。</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210506143748.png" alt=""></p>
</li>
<li><p>config</p>
<p> 以json格式存储消费信息</p>
</li>
<li><p>consumerFilter.json</p>
<p>消息过滤器</p>
</li>
<li><p>consumerOffset.json</p>
<p> 客户端的消费进度</p>
</li>
<li><p>delayOffset.json</p>
<p> 延迟消息进度</p>
</li>
<li><p>subscriptionGroup.json</p>
<p> group的订阅数据</p>
</li>
<li><p>topics.json</p>
<p>Topic的配置信息</p>
</li>
</ol>
<h3 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><p>RocketMQ的消息是存储到磁盘上的，这样既能保证断电后恢复， 又可以让存储的消息量超出内存的限制。RocketMQ为了提高性能，会尽可能地保证磁盘的顺序写。消息在通过Producer写入RocketMQ的时 候，有两种写磁盘方式，<font color=red>分布式同步刷盘和异步刷盘</font>。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506144911.png" alt="image-20210506144911556"></p>
<h4 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h4><p>在返回写成功状态时，消息已经被写入磁盘</p>
<p><strong>具体流程</strong>：消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。</p>
<p><strong>优点</strong>：可靠性高</p>
<p><strong>缺点</strong>：效率比异步低</p>
<h4 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><p>在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，<strong>写操作的返回快，吞吐量大</strong>；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入</p>
<p><strong>优点</strong>：效率高</p>
<p><strong>缺点</strong>：可能存在数据丢失</p>
<h4 id="刷盘机制配置"><a href="#刷盘机制配置" class="headerlink" title="刷盘机制配置"></a>刷盘机制配置</h4><p>在Broker配置文件中新增配置（单机的一般为broker.conf）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘 </span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘 </span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">SYNC_FLUSH</span></span><br></pre></td></tr></table></figure>
<h2 id="高可用性机制"><a href="#高可用性机制" class="headerlink" title="高可用性机制"></a>高可用性机制</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210426164754" alt=""></p>
<p>RocketMQ分布式集群是<strong>通过Master和Slave的配合达到高可用性的</strong>。</p>
<p><strong>Master和Slave的区别</strong>：</p>
<ul>
<li>在Broker的配置文件中，参数 brokerId的值为0表明这个Broker是Master，大于0表明这个Broker是 Slave，同时brokerRole参数也会说明这个Broker是Master还是Slave。</li>
<li><strong>Master角色的Broker支持读和写</strong>，<strong>Slave角色的Broker仅支持读</strong>，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。（类似于redis的主从关系）</li>
</ul>
<h3 id="集群服务的高可用"><a href="#集群服务的高可用" class="headerlink" title="集群服务的高可用"></a>集群服务的高可用</h3><p>NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能</p>
<ol>
<li><strong>Broker管理</strong>，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；</li>
<li><strong>路由信息管理</strong>，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消</li>
<li>NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。<strong>Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息</strong>。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer，Consumer仍然可以动态感知Broker的路由的信息</li>
<li>NameServer实例时间互不通信，这本身也是其设计亮点之一，<strong>即允许不同NameServer之间数据不同步(像Zookeeper那样保证各节点数据强一致性会带来额外的性能消耗)</strong></li>
</ol>
<h3 id="消息消费端的高可用"><a href="#消息消费端的高可用" class="headerlink" title="消息消费端的高可用"></a>消息消费端的高可用</h3><p>在Consumer的配置文件中，并不需要设置是从Master读还是从Slave 读，<strong>默认从Master中读取，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave 读</strong>。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性</p>
<h3 id="消息生产端的高可用"><a href="#消息生产端的高可用" class="headerlink" title="消息生产端的高可用"></a>消息生产端的高可用</h3><p>在创建Topic的时候，<strong>把Topic的多个MessageQueue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可 用后，其他组的Master仍然可用，Producer仍然可以发送消息</strong>。 RocketMQ目前还不支持把Slave自动转成Master，如果机器资源不足，需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文件，用新的配置文件启动Broker。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506150603.png" alt="image-20210506150603601"></p>
<h3 id="消息主从复制"><a href="#消息主从复制" class="headerlink" title="消息主从复制"></a>消息主从复制</h3><p>如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。</p>
<h4 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h4><p>同步复制方式是等Master和Slave均写 成功后才反馈给客户端写成功状态。</p>
<p><strong>优点</strong>：当Master出故障， Slave上有全部的备份数据，容易恢复</p>
<p><strong>缺点</strong>：同步复制会增大数据写入 延迟，降低系统吞吐量。</p>
<h4 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h4><p>异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。</p>
<p><strong>优点</strong>：系统拥有较低的延迟和较高的吞吐量</p>
<p><strong>缺点</strong>：Master出了故障，有些数据因为没有被写 入Slave，<strong>有可能会丢失</strong>。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>同步复制和异步复制是通过Broker配置文件里的brokerRole参数进行设置的，这个参数可以被设置成ASYNC_MASTER、 SYNC_MASTER、SLAVE三个值中的一个。</p>
<p>对于Master才有ASYNC_MASTER、 SYNC_MASTER；Slave只有SLAVE一个值。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master   - SYNC_MASTER 同步双写Master   - SLAVE 从节点</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SYNC_MASTER</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>通常情况下，应该把Master和Save配置成ASYNC_FLUSH的刷盘方式，主从之间配置成SYNC_MASTER的复制方式，这样即使有一台机器出故障，仍然能保证数据不丢。</strong></p>
</blockquote>
<h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h4><ol>
<li><p><strong>单Master模式</strong></p>
<p> 只有一个 Master节点</p>
<p> <strong>优点</strong>：配置简单，方便部署</p>
<p> <strong>缺点</strong>：这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用，不建议线上环境使用</p>
</li>
<li><p><strong>多Master模式</strong></p>
<p>  一个集群无 Slave，全是 Master，例如 2 个 Master 或者 3 个 Master</p>
<p> <strong>优点</strong>：配置简单，单个Master 宕机或重启维护对应用无影响，在磁盘配置为RAID10 时，即使机器宕机不可恢复情况下，由与 RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。多 Master 多 Slave 模式，异步复制</p>
<p>  <strong>缺点</strong>：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到受到影响</p>
</li>
<li><p><strong>多Master多Slave模式（异步复制）</strong></p>
<p> 每个 Master 配置一个 Slave，有多对Master-Slave， HA，采用异步复制方式，主备有短暂消息延迟，毫秒级。</p>
<p> <strong>优点</strong>：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为Master 宕机后，消费者仍然可以从 Slave消费，此过程对应用透明。不需要人工干预。性能同多 Master 模式几乎一样。</p>
<p> <strong>缺点</strong>： Master 宕机，磁盘损坏情况，会丢失少量消息。</p>
</li>
<li><p><strong>多Master多Slave模式（同步双写）</strong></p>
<p> 每个 Master 配置一个 Slave，有多对Master-Slave， HA采用同步双写方式，主备都写成功，向应用返回成功。</p>
<p>  <strong>优点</strong>：数据与服务都无单点， Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高</p>
<p> <strong>缺点</strong>：性能比异步复制模式略低，大约低 10%左右，发送单个消息的 RT会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能</p>
</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506152345.png" alt=""></p>
<h2 id="RocketMQ负载均衡"><a href="#RocketMQ负载均衡" class="headerlink" title="RocketMQ负载均衡"></a>RocketMQ负载均衡</h2><h3 id="Producer负载均衡"><a href="#Producer负载均衡" class="headerlink" title="Producer负载均衡"></a>Producer负载均衡</h3><p>Producer端，每个实例在发消息的时候，<strong>默认会轮询所有的message queue发送，以达到让消息平均落在不同的queue上。而由于queue可以散落在不同的broker</strong>，所以消息就发送到不同的broker下，如下图：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506152837.png" alt="image-20210506152837045"></p>
<h3 id="Consumer负载均衡"><a href="#Consumer负载均衡" class="headerlink" title="Consumer负载均衡"></a>Consumer负载均衡</h3><h4 id="集群模式-1"><a href="#集群模式-1" class="headerlink" title="集群模式"></a>集群模式</h4><p>在集群消费模式下，每条消息只需要投递到订阅这个topic的Consumer Group下的一个实例即可。RocketMQ采用主动拉取的方式拉取并消费消息，在拉取的时候需要明确指定拉取哪一条message queue。</p>
<p><strong>而每当实例的数量有变更，都会触发一次所有实例的负载均衡</strong>，这时候会按照queue的数量和实例的数量平均分配queue给每个实例。</p>
<ol>
<li><p>默认的分配算法是<code>AllocateMessageQueueAveragely</code>，如下图：</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210507112905.png" alt="img"></p>
</li>
<li><p>另外一种平均的算法是<code>AllocateMessageQueueAveragelyByCircle</code>，也是平均分摊每一条queue，只是以环状轮流分queue的形式，如下图：</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210507112943.png" alt="img"></p>
</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>集群模式下，queue都是只允许分配只一个实例，这是由于如果多个实例同时消费一个queue的消息，由于拉取哪些消息是consumer主动控制的，那样会导致同一个消息在不同的实例下被消费多次，所以算法上都是<strong>一个queue只分给一个consumer实例，一个consumer实例可以允许同时分到不同的queue</strong>。</li>
<li>通过增加consumer实例去分摊queue的消费，可以起到水平扩展的消费能力的作用。而有实例下线的时候，会重新触发负载均衡，这时候原来分配到的queue将分配到其他实例上继续消费。</li>
<li><strong>但是如果consumer实例的数量比message queue的总数量还多的话，多出来的consumer实例将无法分到queue，也就无法消费到消息，也就无法起到分摊负载的作用了</strong>。<u>所以需要控制让queue的总数量大于等于consumer的数量</u>。</li>
</ul>
<h4 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h4><p>广播模式下要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。</p>
<p><strong>在实现上，其中一个不同就是在consumer分配queue的时候，所有consumer都分到所有的queue。</strong></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210507143958.png" alt="img"></p>
<h2 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h2><p>消息重试的目的就是保证消息一定被消费掉。</p>
<h3 id="顺序消息的重试"><a href="#顺序消息的重试" class="headerlink" title="顺序消息的重试"></a>顺序消息的重试</h3><p>对于顺序消息，当消费者消费消息失败后，消息队列RocketMQ会自动不断进行消息重试（每次间隔时间为 1 秒），这时，应用会出现消息消费被阻塞的情况（<u>其实就是前面消息消费失败后，后面的顺序消息会被阻塞</u>）。因此，<strong>在使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生。</strong></p>
<h3 id="无序消息的重试"><a href="#无序消息的重试" class="headerlink" title="无序消息的重试"></a>无序消息的重试</h3><p>对于无序消息（普通、定时、延时、事务消息），当消费者消费消息失败时，您可以通过设置返回状态达到消息重试的结果。</p>
<p><strong>无序消息的重试只针对集群消费方式生效</strong>；<strong>广播方式不提供失败重试特性</strong>，即消费失败后，失败消息不再重试，继续消费新的消息（即：广播模式不管消费成功或失败，只能被消费一次）。</p>
<h4 id="重试次数"><a href="#重试次数" class="headerlink" title="重试次数"></a>重试次数</h4><p>消息队列 RocketMQ 默认允许每条消息最多重试16次，每次重试的间隔时间如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">第几次重试</th>
<th style="text-align:center">与上次重试的间隔时间</th>
<th style="text-align:center">第几次重试</th>
<th style="text-align:center">与上次重试的间隔时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">10 秒</td>
<td style="text-align:center">9</td>
<td style="text-align:center">7 分钟</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">30 秒</td>
<td style="text-align:center">10</td>
<td style="text-align:center">8 分钟</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1 分钟</td>
<td style="text-align:center">11</td>
<td style="text-align:center">9 分钟</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2 分钟</td>
<td style="text-align:center">12</td>
<td style="text-align:center">10 分钟</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">3 分钟</td>
<td style="text-align:center">13</td>
<td style="text-align:center">20 分钟</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">4 分钟</td>
<td style="text-align:center">14</td>
<td style="text-align:center">30 分钟</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">5 分钟</td>
<td style="text-align:center">15</td>
<td style="text-align:center">1 小时</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">6 分钟</td>
<td style="text-align:center">16</td>
<td style="text-align:center">2 小时</td>
</tr>
</tbody>
</table>
</div>
<p>消息重试16次后仍然失败，消息将不再投递。如果严格按照上述重试时间间隔计算，某条消息在一直消费失败的前提下，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，超过这个时间范围消息将不再重试投递，而是将消息放入<strong>死信队列</strong>中</p>
<blockquote>
<p>一条消息无论重试多少次，这些重试消息的 <strong>Message ID 不会改变</strong>。</p>
</blockquote>
<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；<strong>达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息</strong>，此时，<strong>消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</strong></p>
<p>在消息队列 RocketMQ 中，这种正常情况下无法被消费的消息称为<u><strong>死信消息</strong></u>（Dead-Letter Message），存储死信消息的特殊队列称为<u><strong>死信队列</strong></u>（Dead-Letter Queue）。</p>
<h3 id="死信消息特性"><a href="#死信消息特性" class="headerlink" title="死信消息特性"></a>死信消息特性</h3><ol>
<li>不会再被消费者正常的消费</li>
<li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，请在死信消息产生后的 3 天内及时处理。<font color=red>处理超时会导致MQ的消息丢失</font></li>
</ol>
<h3 id="死信队列特性"><a href="#死信队列特性" class="headerlink" title="死信队列特性"></a>死信队列特性</h3><ol>
<li>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例；</li>
<li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列；</li>
<li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li>
</ol>
<h3 id="处理死信队列消息"><a href="#处理死信队列消息" class="headerlink" title="处理死信队列消息"></a>处理死信队列消息</h3><p>一条消息进入死信队列，意味着某些因素导致消费者无法正常消费该消息，需要进行他叔处理，主要的以下处理方式：</p>
<ol>
<li>排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息，让消费者重新消费一次</li>
<li>重写一个consumer去消费</li>
</ol>
<h2 id="消费幂等"><a href="#消费幂等" class="headerlink" title="消费幂等"></a>消费幂等</h2><p>消息队列 RocketMQ 消费者在接收到消息以后，有必要根据业务上的唯一 Key 对消息做幂等处理的必要性。（<strong>RocketMQ不提供幂等性控制</strong>，需要我们自己控制）</p>
<h3 id="消息幂等的必要性"><a href="#消息幂等的必要性" class="headerlink" title="消息幂等的必要性"></a>消息幂等的必要性</h3><p>在互联网应用中，尤其在网络不稳定的情况下，消息队列 RocketMQ 的消息有可能会出现重复，这个重复简单可以概括为以下情况：</p>
<ol>
<li><p><strong>发送时消息重复</strong></p>
<p> 当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li><p><strong>投递时消息重复</strong></p>
<p> 消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。 为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li><p><strong>负载均衡时消息重复</strong>（包括但不限于网络抖动、Broker 重启以及订阅方应用重启）</p>
<p> 当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时会导致不同的消费者消费了重复的消息，消费者可能会收到重复消息。</p>
</li>
</ol>
<h3 id="消息幂等处理方式"><a href="#消息幂等处理方式" class="headerlink" title="消息幂等处理方式"></a>消息幂等处理方式</h3><p>RocketMQ不保证Message ID 的唯一性，所以 Message ID 有可能出现冲突（重复）的情况，故而真正安全的幂等处理，不建议以 Message ID 作为处理依据。 最好的方式是<strong>以业务唯一标识作为幂等处理的关键依据</strong>，而业务的唯一标识可以通过消息 Key 进行设置，订阅方收到消息时可以根据消息的 Key 进行幂等处理。</p>
<p><strong>将发送的消息和消费的消息存到数据库中，然后在进行消息消费的时候，去数据库中查看消息中是否包含业务key，如果包含说明被消费过了，就不要进行消费了。</strong></p>
]]></content>
      <categories>
        <category>RocketMQ</category>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot集成RocketMQ</title>
    <url>/posts/bf1c4a65/</url>
    <content><![CDATA[<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        添加MQ相关依赖--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置属性"><a href="#配置属性" class="headerlink" title="配置属性"></a>配置属性</h3><h4 id="添加相关依赖"><a href="#添加相关依赖" class="headerlink" title="添加相关依赖"></a>添加相关依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        添加MQ相关依赖--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2.1.1对应rocketmq版本为4.7.1， 2.2.0对应rocketmq版本为：4.8.0 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="comment"># name-server服务发现者ip地址</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="number">192.168</span><span class="number">.232</span><span class="number">.128</span><span class="string">:9876</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="comment"># RocketMQ官方建议，生产者组统一以 PID_ 开头，消费者组统一以 CID_ 开头</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">PID_test</span></span><br><span class="line">    <span class="comment"># 当消息发送失败时重试2次（默认）</span></span><br><span class="line">    <span class="attr">retry-times-when-send-failed:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h4><p>对外暴露一个接口用于发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对外发送消息的接口</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;PID_test&quot;</span>,msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消费监听"><a href="#消费监听" class="headerlink" title="消费监听"></a>消费监听</h4><p>消费者需要实现<code>RocketMQListener&lt;T&gt;</code>接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">//consumerGroup配置自身的消费相关信息, topic配置消费队列topic</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(consumerGroup = &quot;CID_test&quot;, topic = &quot;PID_test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketConsumer</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;接收到消息&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RocketMQ</category>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ消息</title>
    <url>/posts/1369e54/</url>
    <content><![CDATA[<h2 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h2><h3 id="发送同步消息"><a href="#发送同步消息" class="headerlink" title="发送同步消息"></a>发送同步消息</h3><p>使用场景：</p>
<ol>
<li>重要消息通知</li>
<li>短信通知（接短信平台）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rocketmqdemo.message.Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/6 15:35</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 发送同步消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者Producer，指定生产者的生产组</span></span><br><span class="line">        DefaultMQProducer defaultMQProducer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;group01&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定nameserver的地址</span></span><br><span class="line">        defaultMQProducer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            defaultMQProducer.start();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//3. 创建需要发送的消息</span></span><br><span class="line">                Message message = <span class="keyword">new</span> Message(<span class="string">&quot;base&quot;</span>, <span class="string">&quot;tag1&quot;</span>, ((<span class="string">&quot;Hello MQ&quot;</span>) + i).getBytes());</span><br><span class="line">                SendResult send = defaultMQProducer.send(message);</span><br><span class="line">                System.out.println(send);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                defaultMQProducer.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506154349.png" alt="image-20210506154349188"></p>
<h3 id="发送异步消息"><a href="#发送异步消息" class="headerlink" title="发送异步消息"></a>发送异步消息</h3><p><strong>使用场景</strong>：通常使用在对相应时间敏感的业务场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rocketmqdemo.message.async;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/6 15:47</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者Producer，指定生产者的生产组</span></span><br><span class="line">        DefaultMQProducer defaultMQProducer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;group02&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定nameserver的地址</span></span><br><span class="line">        defaultMQProducer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            defaultMQProducer.start();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//3. 创建需要发送的消息</span></span><br><span class="line">                Message message = <span class="keyword">new</span> Message(<span class="string">&quot;base&quot;</span>, <span class="string">&quot;tag2&quot;</span>, ((<span class="string">&quot;Hello MQ&quot;</span>) + i).getBytes());</span><br><span class="line">                defaultMQProducer.send(message, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="comment">//异步发送之后，MQ会在此进行回调，此时对消息的状态进行相关处理</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//对成功发送的数据进行处理</span></span><br><span class="line">                        System.out.println(sendResult);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//发送失败的数据处理</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//线程等待1s</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                defaultMQProducer.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="单向发送消息"><a href="#单向发送消息" class="headerlink" title="单向发送消息"></a>单向发送消息</h3><p><strong>使用场景</strong>：日志发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rocketmqdemo.message.oneway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/6 15:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 发送单边消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者Producer，指定生产者的生产组</span></span><br><span class="line">        DefaultMQProducer defaultMQProducer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;group03&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定nameserver的地址</span></span><br><span class="line">        defaultMQProducer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            defaultMQProducer.start();</span><br><span class="line">            <span class="comment">//设置消息发送失败之后的重试次数</span></span><br><span class="line">            defaultMQProducer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//3. 创建需要发送的消息</span></span><br><span class="line">                Message message = <span class="keyword">new</span> Message(<span class="string">&quot;base&quot;</span>, <span class="string">&quot;tag2&quot;</span>, ((<span class="string">&quot;Hello MQ&quot;</span>) + i).getBytes());</span><br><span class="line">                <span class="comment">//4.直接发送数据，不管结果</span></span><br><span class="line">                defaultMQProducer.sendOneway(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException | RemotingException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                defaultMQProducer.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h2><p>消息消费模式由消费者来决定，可以由消费者设置MessageModel来决定消息模式。</p>
<p><strong>RocketMQ消息模式默认为集群消费模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">consumer.setMessageModel(MessageModel.CLUSTERING);</span><br></pre></td></tr></table></figure>
<h3 id="集群消息（负载均衡模式）"><a href="#集群消息（负载均衡模式）" class="headerlink" title="集群消息（负载均衡模式）"></a>集群消息（负载均衡模式）</h3><p>集群消息是指<strong>集群化部署消费者</strong></p>
<p>当使用集群消费模式时，MQ 认为任意一条消息只需要被集群内的任意一个消费者处理即可。</p>
<p><strong>特点</strong></p>
<ul>
<li>每条消息只需要被处理一次，broker只会把消息发送给消费集群中的一个消费者</li>
<li>在消息重投时，不能保证路由到同一台机器上</li>
<li>消费状态由broker维护（消费者告诉broker现在的消费模式）</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506161751.png" alt="160707_kSpS_1469576"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rocketmqdemo.message.sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.protocol.heartbeat.MessageModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/6 16:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerByMessageModelClustering</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer defaultMQPushConsumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group01&quot;</span>);</span><br><span class="line">        defaultMQPushConsumer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//设置消费者消费模式，默认是负载均衡模式</span></span><br><span class="line">        defaultMQPushConsumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            defaultMQPushConsumer.subscribe(<span class="string">&quot;base&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            defaultMQPushConsumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt messageExt:msgs)&#123;</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(messageExt.getBody());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            defaultMQPushConsumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506162855.png" alt="image-20210506162855650"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506162912.png" alt="image-20210506162912939"></p>
<p>两个相同的客户端，两个消费者都消费了5条数据，但是数据不相同</p>
<h3 id="广播消息"><a href="#广播消息" class="headerlink" title="广播消息"></a>广播消息</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506161835.png" alt=""></p>
<p>当使用广播消费模式时，MQ 会将每条消息推送给集群内所有注册过的客户端，保证消息至少被每台机器消费一次。</p>
<p><strong>特点</strong></p>
<ul>
<li>消费进度由consumer维护</li>
<li>保证每个消费者消费一次消息</li>
<li>消费失败的消息不会重投</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rocketmqdemo.message.sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.protocol.heartbeat.MessageModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/6 16:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：广播模式消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerByMessageModelBroadcasting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer defaultMQPushConsumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group01&quot;</span>);</span><br><span class="line">        defaultMQPushConsumer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//设置消费者消费模式</span></span><br><span class="line">        defaultMQPushConsumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            defaultMQPushConsumer.subscribe(<span class="string">&quot;base&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            defaultMQPushConsumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt messageExt:msgs)&#123;</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(messageExt.getBody()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            defaultMQPushConsumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506163254.png" alt="image-20210506163254533"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506163306.png" alt="image-20210506163306485"></p>
<blockquote>
<p>当一个topic被多个消费者消费，并且多个消费者消费模式不同的时候，广播模式的集群能正常消费全部数据，但是集群消息的消费者可能有部分数据无法消费到（发送到广播集群会被认为已经消费），<font color=red>对于同一个Topic应该使用一种消费模式</font></p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506163926.png" alt="image-20210506163926722"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506163944.png" alt="image-20210506163944431"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506163959.png" alt="image-20210506163959905"></p>
<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。</p>
<p>顺序消费的原理解析：</p>
<ol>
<li><p>在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；</p>
</li>
<li><p>而消费消息的时候从多个queue上拉取消息，<strong>这种情况发送和消费是不能保证顺序</strong>；</p>
</li>
<li><p>如果控制发送的顺序消息只依次发送到<strong>同一个queue中</strong>，消费的时候只从这个queue上依次拉取，则就<strong>保证顺序</strong>；</p>
</li>
<li><p>当<strong>发送和消费参与的queue只有一个，则是全局有序</strong>；如果多个queue参与，则为分区有序，即<strong>相对每个queue，消息都是有序的</strong>。</p>
<blockquote>
<p>假定业务场景：消息中存储的是用户的积分变动，且用户间消息无业务依赖。消息中有userid，此时用userid做hash，拆分成多个桶，每个桶对应一个线程进行处理此时即可保障单用户消息的时序性，利用业务特性提升consumer的并发消费能力。</p>
<p>具体操作：consumer启动x个线程（或进程）每个线程都消费当前queue所有的消息，如果这个消息的 userid%x=自己的序号就处理这条消息，否则就跳过（这里面可以进一步用一致性hash考虑consumer的可靠性）。</p>
</blockquote>
</li>
</ol>
<h3 id="信息生产者"><a href="#信息生产者" class="headerlink" title="信息生产者"></a>信息生产者</h3><p>通过重写<code>MessageQueueSelector</code>的<code>select</code>方法，保证统一id的进入到同一个queue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.MessageQueueSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageQueue;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultMQProducer defaultMQProducer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;order-producer-group&quot;</span>);</span><br><span class="line">        defaultMQProducer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            defaultMQProducer.start();</span><br><span class="line"></span><br><span class="line">            List&lt;OrderStep&gt; orderSteps = <span class="keyword">new</span> OrderStep().buildOrders();</span><br><span class="line">            <span class="keyword">for</span> (OrderStep orderStep : orderSteps)&#123;</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicOrder&quot;</span>,<span class="string">&quot;key&quot;</span>+orderStep.getOrderId(),(orderStep.toString()).getBytes());</span><br><span class="line">                <span class="comment">//msg 消息</span></span><br><span class="line">                <span class="comment">//messageQueueSelector  消息队列选择器</span></span><br><span class="line">                <span class="comment">//arg   要进行筛选的条件</span></span><br><span class="line">                defaultMQProducer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                    <span class="comment">//mq中所有的queue</span></span><br><span class="line">                    <span class="comment">//msg</span></span><br><span class="line">                    <span class="comment">//arg</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">long</span> orderId = (<span class="keyword">long</span>)arg;</span><br><span class="line">                        <span class="comment">//保证存储在同一个queue中了</span></span><br><span class="line">                        <span class="keyword">long</span> l = orderId % mqs.size();</span><br><span class="line">                        MessageQueue messageQueue = mqs.get((<span class="keyword">int</span>) l);</span><br><span class="line">                        System.out.println(messageQueue.getBrokerName()+<span class="string">&quot;......&quot;</span>+messageQueue.getQueueId()+<span class="string">&quot;......&quot;</span>+<span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> messageQueue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,orderStep.getOrderId());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            defaultMQProducer.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506172502.png" alt="image-20210506172502764"></p>
<p>同一个orderID的相关数据进入到broker的统一queue中</p>
<h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>使用<code>MessageListenerOrderly</code>的<code>consumeMessage</code>方法保证当前queue被单线程消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.protocol.heartbeat.MessageModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer defaultMQPushConsumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;order_consumer_groups&quot;</span>);</span><br><span class="line">        defaultMQPushConsumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">        defaultMQPushConsumer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            defaultMQPushConsumer.subscribe(<span class="string">&quot;TopicOrder&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="comment">//使用messageListenerOrderly保证当前queue使用单线程完成消息消费</span></span><br><span class="line">            defaultMQPushConsumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt messageExt :msgs)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;......&quot;</span>+<span class="keyword">new</span> String(messageExt.getBody()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            defaultMQPushConsumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506172607.png" alt="image-20210506172607936"></p>
<p>同一个线程消费了同一个queue中的数据，并且保证了数据的时序性</p>
<h2 id="批量消息发送"><a href="#批量消息发送" class="headerlink" title="批量消息发送"></a>批量消息发送</h2><p>可以多条消息打包一起发送，减少网络传输次数提高效率。</p>
<p><code>producer.send(Collection c)</code>方法可以接受一个集合 实现批量发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Collection&lt;Message&gt; msgs)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.send(batch(msgs));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>批量消息要求必要具有同一topic、相同消息配置</li>
<li>不支持延时消息</li>
<li>建议一个批量消息最好不要超过1MB大小</li>
<li>如果不确定是否超过限制，可以手动计算大小分批发送</li>
</ul>
<h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>设置message属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//private String messageDelayLevel = &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;;</span></span><br><span class="line"><span class="comment">// 这个配置项配置了从1级开始，各级延时的时间，可以修改这个指定级别的延时时间；</span></span><br><span class="line">message.setDelayTimeLevel(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h2 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h2><p>在大多数情况下，TAG是一个简单而有用的设计，其可以来选择您想要的消息。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TOPIC&quot;</span>, <span class="string">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>消费者将接收包含TAGA或TAGB或TAGC的消息。但是<strong>限制是一个消息只能有一个标签</strong>，这对于复杂的场景可能不起作用。在这种情况下，<strong>可以使用SQL表达式筛选消息。SQL特性可以通过发送消息时的属性来进行计算</strong>。在RocketMQ定义的语法下，可以实现一些简单的逻辑。</p>
<h3 id="SQL基本语法"><a href="#SQL基本语法" class="headerlink" title="SQL基本语法"></a>SQL基本语法</h3><ul>
<li>RocketMQ只定义了一些基本语法来支持这个特性<ul>
<li>数值比较，比如：<strong>&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=；</strong></li>
<li>字符比较，比如：<strong>=，&lt;&gt;，IN；</strong></li>
<li><strong>IS NULL</strong> 或者 <strong>IS NOT NULL；</strong></li>
<li>逻辑符号 <strong>AND，OR，NOT；</strong></li>
</ul>
</li>
<li>常量支持类型为：<ul>
<li>数值，比如：<strong>123，3.1415；</strong></li>
<li>字符，比如：<strong>‘abc’，必须用单引号包裹起来；</strong></li>
<li><strong>NULL</strong>，特殊的常量</li>
<li>布尔值，<strong>TRUE</strong> 或 <strong>FALSE</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(finalString topic, <span class="keyword">final</span> MessageSelector messageSelector)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="开启sql支持"><a href="#开启sql支持" class="headerlink" title="开启sql支持"></a>开启sql支持</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">enablePropertyFilter</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rocketmqdemo.filtermessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/6 17:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者Producer，指定生产者的生产组</span></span><br><span class="line">        DefaultMQProducer defaultMQProducer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;group01&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定nameserver的地址</span></span><br><span class="line">        defaultMQProducer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            defaultMQProducer.start();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//3. 创建需要发送的消息</span></span><br><span class="line">                Message message = <span class="keyword">new</span> Message(<span class="string">&quot;filterTopic&quot;</span>, <span class="string">&quot;tag1&quot;</span>, ((<span class="string">&quot;Hello MQ&quot;</span>) + i).getBytes());</span><br><span class="line">                message.putUserProperty(<span class="string">&quot;a&quot;</span>,String.valueOf(i));</span><br><span class="line">                SendResult send = defaultMQProducer.send(message);</span><br><span class="line">                System.out.println(send);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                defaultMQProducer.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a>消息消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rocketmqdemo.filtermessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.MessageSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.protocol.heartbeat.MessageModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/6 17:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer defaultMQPushConsumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group01&quot;</span>);</span><br><span class="line">        defaultMQPushConsumer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//设置消费者消费模式，默认是负载均衡模式</span></span><br><span class="line">        defaultMQPushConsumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            defaultMQPushConsumer.subscribe(<span class="string">&quot;filterTopic&quot;</span>, MessageSelector.bySql(<span class="string">&quot;a&gt;1 and a&lt;5&quot;</span>));</span><br><span class="line">            defaultMQPushConsumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt messageExt:msgs)&#123;</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(messageExt.getBody()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            defaultMQPushConsumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506174748.png" alt="image-20210506174748213"></p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="分布式事务的两种提交方式（2PC和TCC）"><a href="#分布式事务的两种提交方式（2PC和TCC）" class="headerlink" title="分布式事务的两种提交方式（2PC和TCC）"></a>分布式事务的两种提交方式（2PC和TCC）</h3><h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>2PC即两阶段提交协议，<strong>是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase）</strong>，2是指两个阶段，P是指准备阶段，C是指提交阶段。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210507093144.png" alt="2PC成功"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210507093227.png" alt="2PC失败"></p>
<h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p>TCC是Try、Confirm、Cancel三个词语的缩写，<strong>TCC要求每个分支事务实现三个操作：预处理Try、确认Confirm、撤销Cancel。Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的操作即回滚操作</strong>。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所有分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中Confirm/Cancel操作若执行失败，TM会进行重试。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210507093421.png" alt="TCC成功"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210507093509.png" alt="TCC失败"></p>
<p>TCC分为三个阶段：</p>
<ol>
<li><p>Try 阶段是做业务检查(一致性)及资源预留(隔离)，此阶段仅是一个初步操作，它和后续的Confirm 一起才能真正构成一个完整的业务逻辑。</p>
</li>
<li><p>Confirm 阶段是做确认提交，Try阶段所有分支事务执行成功后开始执行 Confirm。通常情况下，采用TCC则认为 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引入重试机制或人工处理。</p>
</li>
<li><p>Cancel 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。</p>
</li>
<li><p>TM事务管理器</p>
<p> TM事务管理器可以实现为独立的服务，也可以让全局事务发起方充当TM的角色，TM独立出来是为了成为公用组件，是为了考虑系统结构和软件复用。</p>
</li>
</ol>
<p><strong>TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条，用来记录事务上下文，追踪和记录状态，由于Confirm 和cancel失败需进行重试，因此需要实现为幂等，幂等性是指同一个操作无论请求多少次，其结果都相同。</strong></p>
<blockquote>
<p>如果拿TCC事务的处理流程与2PC两阶段提交做比较，2PC通常都是在跨库的DB层面，而TCC则在应用层面的处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能。</p>
<p>TCC的不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。</p>
</blockquote>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506175911.png" alt=""></p>
<p>上图说明了事务消息的大致方案，其中分为两个流程：<strong>正常事务消息的发送及提交</strong>、<strong>事务消息的补偿流程</strong>。</p>
<h4 id="事务消息发送及提交"><a href="#事务消息发送及提交" class="headerlink" title="事务消息发送及提交"></a>事务消息发送及提交</h4><ol>
<li>发送消息（<strong>half Message</strong>）；</li>
<li>服务端响应消息写入结果；</li>
<li>根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）；</li>
<li>根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）。</li>
</ol>
<h4 id="事务补偿"><a href="#事务补偿" class="headerlink" title="事务补偿"></a>事务补偿</h4><ol>
<li><p>对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”；</p>
</li>
<li><p>Producer收到回查消息，检查回查消息对应的本地事务的状态；</p>
</li>
<li><p>根据本地事务状态，重新Commit或者Rollback；</p>
 <font color=red> 补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况</font>

</li>
</ol>
<h4 id="事务消息状态"><a href="#事务消息状态" class="headerlink" title="事务消息状态"></a>事务消息状态</h4><p>事务消息共有三种状态，<font color=red><strong>提交状态</strong>、<strong>回滚状态</strong>、<strong>中间状态</strong></font></p>
<ul>
<li><code>TransactionStatus.CommitTransaction</code>: 提交事务，它允许消费者消费此消息。</li>
<li><code>TransactionStatus.RollbackTransaction</code>: 回滚事务，它代表该消息将被删除，不允许被消费。</li>
<li><code>TransactionStatus.Unknown</code>: 中间状态，它代表需要检查消息队列来确定状态。</li>
</ul>
<h4 id="TransactionListener的两个方法"><a href="#TransactionListener的两个方法" class="headerlink" title="TransactionListener的两个方法"></a>TransactionListener的两个方法</h4><h5 id="executeLocalTransaction"><a href="#executeLocalTransaction" class="headerlink" title="executeLocalTransaction"></a>executeLocalTransaction</h5><p>半消息发送成功触发此方法来执行本地事务</p>
<h5 id="checkLocalTransaction"><a href="#checkLocalTransaction" class="headerlink" title="checkLocalTransaction"></a>checkLocalTransaction</h5><p>broker将发送检查消息来检查事务状态，并将调用此方法来获取本地事务状态</p>
<h4 id="事务消息生产者创建"><a href="#事务消息生产者创建" class="headerlink" title="事务消息生产者创建"></a>事务消息生产者创建</h4><p>使用 <code>TransactionMQProducer</code>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rocketmqdemo.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.TransactionMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/7 10:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> MQ事务消息生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TransactionMQProducer transactionProducer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">&quot;transactionProducer&quot;</span>);</span><br><span class="line">        TransactionListenerImpl transactionListener = <span class="keyword">new</span> TransactionListenerImpl();</span><br><span class="line">        transactionProducer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transactionProducer.start();</span><br><span class="line">            ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1000</span>, TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">20</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                    Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                    thread.setName(<span class="string">&quot;client-transaction&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> thread;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            transactionProducer.setExecutorService(threadPoolExecutor);</span><br><span class="line">            <span class="comment">//设置MQ回调的监听方法</span></span><br><span class="line">            transactionProducer.setTransactionListener(transactionListener);</span><br><span class="line">            String[] strings = &#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagB&quot;</span>, <span class="string">&quot;TagC&quot;</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;transactionTopic&quot;</span>, strings[i%strings.length], <span class="string">&quot;key&quot;</span> + i, (<span class="string">&quot;tansaction&quot;</span> + i).getBytes(StandardCharsets.UTF_8)</span><br><span class="line">                );</span><br><span class="line">                SendResult sendResult = transactionProducer.sendMessageInTransaction(msg,<span class="keyword">null</span>);</span><br><span class="line">                System.out.println(sendResult);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            transactionProducer.shutdown();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rocketmqdemo.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.protocol.heartbeat.MessageModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/6 16:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 事务消息消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer defaultMQPushConsumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;transactionConsumer&quot;</span>);</span><br><span class="line">        defaultMQPushConsumer.setNamesrvAddr(<span class="string">&quot;192.168.232.128:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//设置消费者消费模式，默认是负载均衡模式</span></span><br><span class="line">        defaultMQPushConsumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            defaultMQPushConsumer.subscribe(<span class="string">&quot;transactionTopic&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            defaultMQPushConsumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt messageExt:msgs)&#123;</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(messageExt.getBody()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            defaultMQPushConsumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rocketmqdemo.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.util.internal.StringUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.LocalTransactionState;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.TransactionListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/7 10:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 事务的监听实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行本地事务&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TagA&quot;</span>,msg.getTags()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TagA执行成功&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MQ进行消息检测&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><ol>
<li>事务消息<strong>不支持延时消息和批量消息</strong>;</li>
<li><strong>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次</strong>，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N = <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionCheckListener</code> 类来修改这个行为;</li>
<li>事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionMsgTimeout</code> 参数;</li>
<li>事务性消息可能不止一次被检查或消费;</li>
<li><strong>提交给用户的目标主题消息可能会失败</strong>，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果<strong>希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制;</strong></li>
<li><strong>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享</strong>。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</li>
</ol>
]]></content>
      <categories>
        <category>RocketMQ</category>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ相关错误</title>
    <url>/posts/220c8d88/</url>
    <content><![CDATA[<h2 id="查询Topic列表错误"><a href="#查询Topic列表错误" class="headerlink" title="查询Topic列表错误"></a>查询Topic列表错误</h2><h3 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h3><p><strong>unable to calculate a request signature. error=Algorithm HmacSHA1</strong></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210427103411.png" alt="image-20210427103411125"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>到jdk目录下/jre/lib/ext/找到sunjce_provider.jar 复制到rocketmq/lib/(RocketMQ安装路径的bin)中</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210427104309.png" alt="image-20210427104309422"></p>
]]></content>
      <categories>
        <category>RocketMQ</category>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ的角色</title>
    <url>/posts/186db956/</url>
    <content><![CDATA[<h2 id="RocketMQ-角色"><a href="#RocketMQ-角色" class="headerlink" title="RocketMQ 角色"></a>RocketMQ 角色</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210426164754" alt=""></p>
<h3 id="broker-暂存和传输消息"><a href="#broker-暂存和传输消息" class="headerlink" title="broker(暂存和传输消息)"></a>broker(暂存和传输消息)</h3><ul>
<li>Broker面向producer和consumer接受和发送消息</li>
<li>向nameserver提交自己的信息</li>
<li>是消息中间件的消息存储、转发服务器。</li>
<li>每个Broker节点，在启动时，都会遍历NameServer列表，与每个NameServer建立长连接，注册自己的信息，之后定时上报。</li>
</ul>
<h4 id="broker集群"><a href="#broker集群" class="headerlink" title="broker集群"></a>broker集群</h4><ul>
<li>Broker高可用，可以配成Master/Slave结构，Master可写可读，Slave只可以读，Master将写入的数据同步给Slave。<ul>
<li>一个Master可以对应多个Slave，但是<strong>一个Slave只能对应一个Master</strong></li>
<li>Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义<strong>BrokerId为0表示Master，非0表示Slave</strong></li>
</ul>
</li>
<li>Master多机负载，可以部署多个broker<ul>
<li>每个Broker与nameserver集群中的所有节点建立长连接，定时注册Topic信息到所有nameserver。</li>
</ul>
</li>
</ul>
<h3 id="producer-消息的生产者"><a href="#producer-消息的生产者" class="headerlink" title="producer(消息的生产者)"></a>producer(消息的生产者)</h3><ul>
<li>消息的生产者</li>
<li>通过集群中的其中一个节点（随机选择）建立长连接，获得Topic的路由信息，包括Topic下面有哪些Queue，这些Queue分布在哪些Broker上等</li>
<li>接下来向提供Topic服务的Master建立长连接，且定时向Master发送心跳</li>
</ul>
<h3 id="consumer-消息的消费者"><a href="#consumer-消息的消费者" class="headerlink" title="consumer(消息的消费者)"></a>consumer(消息的消费者)</h3><p>消息的消费者，通过NameServer集群获得Topic的路由信息，连接到对应的Broker上消费消息。</p>
<blockquote>
<p>注意，由于Master和Slave都可以读取消息，因此<strong>Consumer会与Master和Slave都建立连接</strong>。</p>
</blockquote>
<h3 id="nameserver-管理Broker"><a href="#nameserver-管理Broker" class="headerlink" title="nameserver(管理Broker)"></a>nameserver(管理Broker)</h3><p>底层由<strong>netty实现</strong>，提供了<strong>路由管理、服务注册、服务发现</strong>的功能，是一个无状态节点</p>
<ul>
<li><p><strong>nameserver是服务发现者</strong>，集群中各个角色（producer、broker、consumer等）都需要定时想nameserver上报自己的状态，以便互相发现彼此，超时不上报的话，nameserver会把它从列表中剔除</p>
</li>
<li><p><strong>nameserver可以部署多个</strong>，当多个nameserver存在的时候，其他角色同时向他们上报信息，以保证高可用，</p>
</li>
<li><p><strong>NameServer集群间互不通信</strong>，没有主备的概念</p>
</li>
<li><p><strong>nameserver内存式存储</strong>，nameserver中的broker、topic等信息默认不会持久化</p>
</li>
</ul>
<p>NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能</p>
<ol>
<li><p><strong>Broker管理</strong>，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；</p>
</li>
<li><p><strong>路由信息管理</strong>，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费<br> <strong>NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯</strong>。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer，Consumer仍然可以动态感知Broker的路由的信息</p>
<blockquote>
<p><strong>NameServer实例间互不通信，这本身也是其设计亮点之一</strong>，即允许不同NameServer之间数据不同步(像Zookeeper那样保证各节点数据强一致性会带来额外的性能消耗)</p>
</blockquote>
</li>
</ol>
<h2 id="对比JMS中的Topic和Queue"><a href="#对比JMS中的Topic和Queue" class="headerlink" title="对比JMS中的Topic和Queue"></a>对比JMS中的Topic和Queue</h2><p>Topic是一个逻辑上的概念，实际上Message是在每个Broker上以Queue的形式记录。对应到JMS（Java Messaging Service）中的<strong>topic实现是由客户端来完成的</strong></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210426165351.jpg" alt=""></p>
<blockquote>
<p>1、消费者发送的Message会在Broker中的Queue队列中记录。 </p>
<p>2、一个Topic的数据可能会存在多个Broker中。</p>
<p> 3、一个Broker存在多个Queue。 </p>
<p>4、单个的Queue也可能存储多个Topic的消息。</p>
<p>也就是说<font color=red>每个Topic在Broker上会划分成几个逻辑队列，每个逻辑队列保存一部分消息数据，但是保存的消息数据实际上不是真正的消息数据，而是指向commit log的消息索引</font>。</p>
<font color=red>`Queue不是真正存储Message的地方，真正存储Message的地方是在CommitLog`</font>

</blockquote>
]]></content>
      <categories>
        <category>RocketMQ</category>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ的安装</title>
    <url>/posts/35db4758/</url>
    <content><![CDATA[<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>安装环境</p>
<ol>
<li><p>CentOS7</p>
</li>
<li><p>JDK 8+（RocketMQ由java编写，运行编译都需要java环境）</p>
</li>
<li><p>Maven 3.2+（构建软件包时需要）</p>
<blockquote>
<p>正常使用直接下载Binary版本即可 ， RocketMQ 已经编译好，可以直接使用的 RocketMQ 软件包。</p>
</blockquote>
</li>
</ol>
<h3 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install java-11-openjdk.x86_64 </span><br></pre></td></tr></table></figure>
<h3 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载相关tar</span></span><br><span class="line">wget http://mirrors.hust.edu.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">解压相关tar</span></span><br><span class="line">tar -zxvf apache-maven-3.3.9-bin.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">移动程序到指定目录</span></span><br><span class="line">sudo mv -f apache-maven-3.3.9 /usr/local/</span><br></pre></td></tr></table></figure>
<p>编辑 <strong>/etc/profile</strong> 文件 <strong>sudo vim /etc/profile</strong>，在文件末尾添加如下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">指定maven安装的路劲</span></span><br><span class="line">export MAVEN_HOME=/usr/soft/maven/apache-maven-3.3.9</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/bin</span><br></pre></td></tr></table></figure>
<p>保存文件，并运行如下命令使环境变量生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<h2 id="RocketMQ安装"><a href="#RocketMQ安装" class="headerlink" title="RocketMQ安装"></a>RocketMQ安装</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载RocketMQ源码</span></span><br><span class="line">wget https://github.com/apache/rocketmq/archive/refs/tags/rocketmq-all-4.8.0.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">解压tar</span></span><br><span class="line">tar -zxvf rocketmq-all-4.8.0.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">进入解压目录</span></span><br><span class="line">cd rocketmq-rocketmq-all-4.8.0</span><br><span class="line"><span class="meta">#</span><span class="bash">Maven编译RocketMQ，跳过测试</span></span><br><span class="line">mvn -Prelease-all -DskipTests clean install -U</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210426150621.png" alt="image-20210426150621637"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 distribution 目录下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> distribution/target/rocketmq-4.7.1/rocketmq-4.7.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前目录为：/root/data/rocketMQ/rocketmq-all-4.7.1-source-release/distribution/target/rocketmq-4.7.1/rocketmq-4.7.1。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">drwxr-xr-x 2 root root  4096 Aug  3 15:59 benchmark # 性能基准测试</span><br><span class="line">drwxrwxr-x 3 root root  4096 Jun 24 14:05 bin # 执行脚本</span><br><span class="line">drwxrwxr-x 6 root root  4096 Jun 24 14:05 conf # 配置文件</span><br><span class="line">drwxr-xr-x 2 root root  4096 Aug  3 15:59 lib # RocketMQ jar 包</span><br><span class="line">-rw-rw-r-- 1 root root 17336 Jun 24 14:05 LICENSE</span><br><span class="line">-rw-rw-r-- 1 root root  1338 Jun 24 14:05 NOTICE</span><br><span class="line">-rw-rw-r-- 1 root root  5069 Jun 24 14:05 README.md</span><br></pre></td></tr></table></figure>
<h2 id="RocketMQ启动"><a href="#RocketMQ启动" class="headerlink" title="RocketMQ启动"></a>RocketMQ启动</h2><h3 id="单机环境"><a href="#单机环境" class="headerlink" title="单机环境"></a>单机环境</h3><h4 id="启动-Namesrv"><a href="#启动-Namesrv" class="headerlink" title="启动 Namesrv"></a>启动 Namesrv</h4><p>启动一个 RocketMQ Namesrv 服务。命令行操作如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210426152740.png" alt="image-20210426152740518"></p>
<blockquote>
<p>默认情况下，Namesrv 日志文件所在地址为<code>~/logs/rocketmqlogs/namesrv.log</code>。如果想要自定义，可以通过<code>conf/logback_namesrv.xml</code>配置文件来进行修改</p>
</blockquote>
<h4 id="启动-Broker"><a href="#启动-Broker" class="headerlink" title="启动 Broker"></a>启动 Broker</h4><p>在 <code>conf</code> 目录下，RocketMQ 提供了多种 Broker 的配置文件：</p>
<ul>
<li><code>broker.conf</code> ：单主，异步刷盘。</li>
<li><code>2m/</code> ：双主，异步刷盘。</li>
<li><code>2m-2s-async/</code> ：两主两从，异步复制，异步刷盘。</li>
<li><code>2m-2s-sync/</code> ：两主两从，同步复制，异步刷盘。</li>
<li><code>dledger/</code> ：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fapache%2Frocketmq%2Fblob%2Fmaster%2Fdocs%2Fcn%2Fdledger%2Fdeploy_guide.md">Dledger 集群</a>，至少三节点。</li>
</ul>
<p>只启动一个 RocketMQ Broker 服务，所以使用 <code>broker.conf</code> 配置文件。命令行操作如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 -c 参数，配置读取的主 Broker 配置。 通过 -n 参数，设置 RocketMQ Namesrv 地址。</span></span><br><span class="line">nohup sh bin/mqbroker -c conf/broker.conf  -n 127.0.0.1:9876 &amp;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210426154314.png" alt="image-20210426154314609"></p>
<p>内存不够，RocketMQ默认用8g内存，如果你服务器的内存比较小，可以修改下<code>bin/runbroker.sh</code>脚本，将 Broker JVM 内存调小。如：<code>JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms2g -Xmx2g -Xmn1g&quot;</code>。</p>
<ol>
<li><p>修改 runbroker.sh 文件</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210426154724.png" alt="image-20210426154724037"></p>
</li>
<li><p>修改runserver.sh文件</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210426154842.png" alt="image-20210426154842728"></p>
</li>
</ol>
<h3 id="Rocket高可用集群部署"><a href="#Rocket高可用集群部署" class="headerlink" title="Rocket高可用集群部署"></a>Rocket高可用集群部署</h3><p><a href="https://zhuanlan.zhihu.com/p/226173170">高可用RocketMQ集群搭建</a></p>
<p><a href="https://www.yuque.com/beatshadow/fia41l/nqs1tm">RocketMQ集群搭建</a></p>
<h2 id="Rocket常用命令"><a href="#Rocket常用命令" class="headerlink" title="Rocket常用命令"></a>Rocket常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动broker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 -c 参数，配置读取的主 Broker 配置。 通过 -n 参数，设置 RocketMQ Namesrv 地址。</span></span><br><span class="line">nohup sh bin/mqbroker -c conf/broker.conf  -n 127.0.0.1:9876 &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash">停止 broker</span></span><br><span class="line">sh bin/mqshutdown broker </span><br><span class="line"><span class="meta">#</span><span class="bash">启动mqnamesrv</span></span><br><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭mqnamesrv</span></span><br><span class="line">sh bin/mqshutdown namesrv</span><br><span class="line"><span class="meta">#</span><span class="bash">查看集群情况</span></span><br><span class="line">. bin/mqadmin clusterList -n 127.0.0.1:9876</span><br><span class="line"><span class="meta">#</span><span class="bash">查看 broker 状态</span></span><br><span class="line">. bin/mqadmin brokerStatus -n 127.0.0.1:9876 -b localhost:10911(注意换成 broker 地址)</span><br><span class="line"><span class="meta">#</span><span class="bash">Broker配置信息 brokerStatus</span></span><br><span class="line">. bin/mqadmin getBrokerConfig -n localhost:9876 -b localhost:10911</span><br><span class="line"><span class="meta">#</span><span class="bash">查看 topic 列表</span></span><br><span class="line">. bin/mqadmin topicList -n 127.0.0.1:9876</span><br><span class="line"><span class="meta">#</span><span class="bash">查看 topic 状态</span></span><br><span class="line">. bin/mqadmin topicStatus -n 127.0.0.1:9876 -t MyTopic(换成查询的 topic)</span><br><span class="line"><span class="meta">#</span><span class="bash">查看 topic 路由</span></span><br><span class="line">. bin/mqadmin topicRoute -n 127.0.0.1:9876 -t MyTopic</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建Topic updateTopic</span></span><br><span class="line">. bin/mqadmin updateTopic -b localhost:10911 -t MyTopic</span><br><span class="line"><span class="meta">#</span><span class="bash">删除Topic deleteTopic</span></span><br><span class="line">. bin/mqadmin deleteTopic -n localhost:9876 -c localhost:10911 -t TopicCmd</span><br><span class="line"><span class="meta">#</span><span class="bash"> Topic列表 topicList</span></span><br><span class="line">. bin/mqadmin topicList -n localhost:9876</span><br><span class="line"><span class="meta">#</span><span class="bash">性能测试</span></span><br><span class="line">. bin/mqadmin sendMsgStatus -n localhost:9876 -b broker-a -c 10</span><br></pre></td></tr></table></figure>
<h2 id="Web-Console-控制台-可视化部署"><a href="#Web-Console-控制台-可视化部署" class="headerlink" title="Web Console 控制台(可视化部署)"></a>Web Console 控制台(可视化部署)</h2><h3 id="控制台rocketmq-console编译安装"><a href="#控制台rocketmq-console编译安装" class="headerlink" title="控制台rocketmq-console编译安装"></a>控制台rocketmq-console编译安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载相关文件</span></span><br><span class="line">wget https://github.com/apache/rocketmq-externals/archive/refs/tags/rocketmq-console-1.0.0.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">tar -zxvf rocketmq-console-1.0.0.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">修改相关配置src/main/resources/application.properties，新增（也可不配置，在网页端配置）</span></span><br><span class="line">rocketmq.config.namesrvAddr=127.0.0.1:9876</span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line"> mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>
<p>编译成功后在<code>rocketmq-console/target</code>目录下执行<code>rocketmq-console-ng-1.0.1.jar</code></p>
<p>启动时，直接动态添加<code>nameserver</code>地址或编辑<code>application.properties</code>添加属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar rocketmq-console-ng-1.0.0.jar --rocketmq.config.namesrvAddr=127.0.0.1:9876 &gt; rocketmq-console.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>访问 <code>ip:端口</code> 即可</p>
]]></content>
      <categories>
        <category>RocketMQ</category>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ的介绍</title>
    <url>/posts/54cc9de8/</url>
    <content><![CDATA[<h2 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h2><p>MQ（Message Queue）:消息队列是一种<font color=red>先进先出</font>的数据结构(类似于排队买东西)</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506102847.png" alt="image-20210506102834628"></p>
<p>主要应用以下场景</p>
<ol>
<li>应用解耦</li>
<li>流量削峰</li>
<li>数据分发</li>
<li><strong>异构系统</strong>：跨语言</li>
</ol>
<h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><ul>
<li><strong>系统的耦合性越高，容错性就越低</strong>。以电商应用为例，用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个系统出现了故障或者因为升级等原因暂时不可用，都会造成下单操作异常，影响用户使用体验。</li>
<li><strong>使用消息队列解耦合，系统的耦合性就会降低</strong>。比如物流系统发生故障，需要几分钟才能来修复，在这段时间，物流系统要处理的数据被缓存到消息队列中，用户的下单操作正常完成。当物流系统恢复后，补充处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障。</li>
</ul>
<h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506104041.png" alt="image-20210506104039661"></p>
<ul>
<li><p><strong>应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮</strong>。有了消息队列可以将大量的请求缓存起来，分散到很长一段时间处理，这样可以大大提高系统的稳定行和用户体验。</p>
</li>
<li><p><strong>一般情况下，为了保证系统的稳定性，如果系统负载超过阀值，就会阻止用户请求，这样影响用户体验</strong>，而如果使用消息队列将请求缓存起来，等待系统处理完毕后通知用户请求处理完毕。</p>
</li>
<li><p><strong>经济考量目的</strong>：业务系统正常时段的QPS如果是1000,流量最高峰是10000,为了应对流量高峰配置高性能</p>
<p>  服务器显然不划算,这是可以使用消息队列对峰值流量削峰</p>
</li>
</ul>
<h3 id="数据分发"><a href="#数据分发" class="headerlink" title="数据分发"></a>数据分发</h3><p>通过消息队列可以让数据在多个系统之间进行流通。数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210506104956.png" alt="image-20210506104953686"></p>
<h3 id="异构系统"><a href="#异构系统" class="headerlink" title="异构系统"></a><strong>异构系统</strong></h3><p>MQ只需要提供相关消息数据，无需关心生产者消费者的消息的产生和消费，使系统可以<strong>跨语言</strong></p>
<h2 id="MQ的优缺点"><a href="#MQ的优缺点" class="headerlink" title="MQ的优缺点"></a>MQ的优缺点</h2><h3 id="MQ的优点"><a href="#MQ的优点" class="headerlink" title="MQ的优点"></a>MQ的优点</h3><ul>
<li>解耦、削峰、数据分发、异构系统（跨语言）</li>
</ul>
<h3 id="MQ的缺点"><a href="#MQ的缺点" class="headerlink" title="MQ的缺点"></a>MQ的缺点</h3><ul>
<li>系统可用性降低<ul>
<li>系统引入的外部依赖越多，系统的稳定性越差。一旦MQ宕机，就会对业务造成影响。</li>
<li>产生问题：<font color=red><strong>如何保证消息高可用</strong></font></li>
</ul>
</li>
<li>系统复杂度提高<ul>
<li>MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。</li>
<li>产生问题：<ul>
<li><font color=red>**如何保证消息没有被重复消费**</font></li>
<li><font color=red>**怎么处理消息丢失情况**</font></li>
<li><font color=red>**怎么保证消息传递的顺序性**</font></li>
</ul>
</li>
</ul>
</li>
<li>一致性问题<ul>
<li>A系统处理完业务，通过MQ给B、C、D三个系统发送消息数据，如果B系统、C系统处理成功，D系统处理失败。<font color=red><strong>如何保证消息数据处理的一致性</strong></font></li>
</ul>
</li>
</ul>
<h3 id="各种MQ产品的比较"><a href="#各种MQ产品的比较" class="headerlink" title="各种MQ产品的比较"></a>各种MQ产品的比较</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th style="text-align:center"><strong>ActiveMQ</strong></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>kafka</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>开发语言</td>
<td style="text-align:center">Java</td>
<td>erlang</td>
<td>Java</td>
<td>Scala</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td style="text-align:center">万级</td>
<td>万级</td>
<td>十万级</td>
<td>十万级</td>
</tr>
<tr>
<td>时效性</td>
<td style="text-align:center">ms级</td>
<td>us级</td>
<td>ms级</td>
<td>ms级以内</td>
</tr>
<tr>
<td>可用性</td>
<td style="text-align:center">高（主从结构）</td>
<td>高（主从架构）</td>
<td>非常高（分布式架构）</td>
<td>非常高（分布式架构）</td>
</tr>
<tr>
<td>功能特性</td>
<td style="text-align:center">成熟的产品，在很多公司得到了应用；有较多的文档；各种协议支持比较好</td>
<td>基于erlang，所以并发能力很强，性能极其好，延时很低；管理界面较丰富</td>
<td>MQ功能比较完备，扩展性佳</td>
<td>只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广泛</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>RocketMQ</category>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis分布式锁实现</title>
    <url>/posts/bfb49b3b/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>系统中修改已有数据时，需要先读取，然后进行修改保存，此时很容易遇到并发问题。由于修改和保存不是原子操作，在并发场景下，部分对数据的操作可能会丢失。<font color=red> 在单服务器系统我们常用本地锁来避免并发带来的问题，然而，当服务采用集群方式部署时，本地锁无法在多个服务器之间生效，这时候保证数据的一致性就需要分布式锁来实现。</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210319153632.png" alt="image-20210319153632272"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Redis 锁主要利用 Redis 的 setnx 命令。</p>
<ul>
<li><p><strong>加锁命令</strong>：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。<strong>KEY 是锁的唯一标识，一般按业务来决定命名</strong>。</p>
</li>
<li><p><strong>解锁命令</strong>：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。</p>
</li>
<li><p><strong>锁超时</strong>：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。</p>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210320105659.png" alt="加锁流程"></p>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210320105725.png" alt="解锁流程"></p>
</li>
</ul>
<h3 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockServiceRedisImpl</span> <span class="keyword">implements</span> <span class="title">LockService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Log log = LogFactory.getLog(LockServiceRedisImpl.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String SET_SUCCESS = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String KEY_PRE = <span class="string">&quot;REDIS_LOCK_&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyyMMddHHmmssSSS&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RedisConnection redisConnection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer dbIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer lockExpirseTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer tryExpirseTime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedisConnection</span><span class="params">(RedisConnection redisConnection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.redisConnection = redisConnection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDbIndex</span><span class="params">(Integer dbIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dbIndex = dbIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLockExpirseTime</span><span class="params">(Integer lockExpirseTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lockExpirseTime = lockExpirseTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTryExpirseTime</span><span class="params">(Integer tryExpirseTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tryExpirseTime = tryExpirseTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = redisConnection.getJedis();</span><br><span class="line">        jedis.select(dbIndex);</span><br><span class="line">        key = KEY_PRE + key;</span><br><span class="line">        String value = fetchLockValue();</span><br><span class="line">        <span class="keyword">if</span> (SET_SUCCESS.equals(jedis.set(key, value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, lockExpirseTime))) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Reids Lock key : &quot;</span> + key + <span class="string">&quot;,value : &quot;</span> + value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">tryLock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = redisConnection.getJedis();</span><br><span class="line">        jedis.select(dbIndex);</span><br><span class="line">        key = KEY_PRE + key;</span><br><span class="line">        String value = fetchLockValue();</span><br><span class="line">        Long firstTryTime = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SET_SUCCESS.equals(jedis.set(key, value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, lockExpirseTime))) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Reids Lock key : &quot;</span> + key + <span class="string">&quot;,value : &quot;</span> + value);</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;Redis lock failure,waiting try next&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((<span class="keyword">new</span> Date().getTime() - tryExpirseTime * <span class="number">1000</span>) &lt; firstTryTime);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unLock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = redisConnection.getJedis();</span><br><span class="line">        jedis.select(dbIndex);</span><br><span class="line">        key = KEY_PRE + key;</span><br><span class="line">        String command = <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1])==ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(jedis.eval(command, Collections.singletonList(key), Collections.singletonList(value)))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成加锁的唯一字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 唯一字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">fetchLockValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UUID.randomUUID().toString() + <span class="string">&quot;_&quot;</span> + df.format(<span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="redisson实现"><a href="#redisson实现" class="headerlink" title="redisson实现"></a>redisson实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useClusterServers()</span><br><span class="line">.addNodeAddress(<span class="string">&quot;redis://192.168.31.101:7001&quot;</span>)</span><br><span class="line">.addNodeAddress(<span class="string">&quot;redis://192.168.31.101:7002&quot;</span>)</span><br><span class="line">.addNodeAddress(<span class="string">&quot;redis://192.168.31.101:7003&quot;</span>)</span><br><span class="line">.addNodeAddress(<span class="string">&quot;redis://192.168.31.102:7001&quot;</span>)</span><br><span class="line">.addNodeAddress(<span class="string">&quot;redis://192.168.31.102:7002&quot;</span>)</span><br><span class="line">.addNodeAddress(<span class="string">&quot;redis://192.168.31.102:7003&quot;</span>);</span><br><span class="line"></span><br><span class="line">RedissonClient redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RLock lock = redisson.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">redlock算法redisson使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">RedissonClient redisson = Redisson.create(config);</span><br><span class="line">RLock lock1 = redisson.getFairLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line">RLock lock2 = redisson.getFairLock(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line">RLock lock3 = redisson.getFairLock(<span class="string">&quot;lock3&quot;</span>);</span><br><span class="line">RedissonRedLock multiLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line">multiLock.lock();</span><br><span class="line">multiLock.unlock();</span><br></pre></td></tr></table></figure>
<p>只需要通过它的api中的lock和unlock即可完成分布式锁，redisson帮我们考虑了很多细节：</p>
<ul>
<li>redisson所有指令都通过lua脚本执行，redis支持lua脚本原子性执行</li>
<li>redisson设置一个key的默认过期时间为30s,如果某个客户端持有一个锁超过了30s怎么办？<br>  redisson中有一个<code>watchdog</code>的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔10秒帮你把key的超时时间设为30s<br>  这样的话，就算一直持有锁也不会出现key过期了，其他线程获取到锁的问题了。</li>
<li>redisson的“看门狗”逻辑保证了没有死锁发生。<br>  (如果机器宕机了，看门狗也就没了。此时就不会延长key的过期时间，到了30s之后就会自动过期了，其他线程可以获取到锁)</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210320104911.png" alt="image-20210320104911157"></p>
<p>其实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁逻辑</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用一段lua脚本，设置一些key、过期时间</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    ttlRemainingFuture.addListener(<span class="keyword">new</span> FutureListener&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Long&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Long ttlRemaining = future.getNow();</span><br><span class="line">            <span class="comment">// lock acquired</span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 看门狗逻辑</span></span><br><span class="line">                scheduleExpirationRenewal(threadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看门狗最终会调用了这里</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.containsKey(getEntryName())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个任务会延迟10s执行</span></span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个操作会将key的过期时间重新设置为30s</span></span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line"></span><br><span class="line">            future.addListener(<span class="keyword">new</span> FutureListener&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Boolean&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    expirationRenewalMap.remove(getEntryName());</span><br><span class="line">                    <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, future.cause());</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (future.getNow()) &#123;</span><br><span class="line">                        <span class="comment">// reschedule itself</span></span><br><span class="line">                        <span class="comment">// 通过递归调用本方法，无限循环延长过期时间</span></span><br><span class="line">                        scheduleExpirationRenewal(threadId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.putIfAbsent(getEntryName(), <span class="keyword">new</span> ExpirationEntry(threadId, task)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        task.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper实现分布式锁</title>
    <url>/posts/60085ed9/</url>
    <content><![CDATA[<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁的思路是每个客户端都在某个目录下注册一个临时有序节点，每次最小的节点会获取锁，当前节点会去监听上一个较小节点，如果较小节点失效之后，就会去获取锁。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210320111311.png" alt="image-20210320111311093"></p>
<h3 id="java原生zookeeper客户端"><a href="#java原生zookeeper客户端" class="headerlink" title="java原生zookeeper客户端"></a>java原生zookeeper客户端</h3><ol>
<li><p>引入jar包</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>创建ZK客户端连接单例</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">//zk集群地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZOOKEEPER_CONNECT=<span class="string">&quot;192.168.232.128:12181,192.168.232.128:12182,192.168.232.128:12183,192.168.232.128:12184&quot;</span>;</span><br><span class="line">    <span class="comment">//计数器，用于等待连接成功</span></span><br><span class="line">    <span class="comment">//CountDownLatch是因为连接时会耗时较长，所以需要添加一个计数器进行阻塞，否则会在connecting阶段就被释放了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//连接超时时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//用volatile修饰单例，防止赋值时发生指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> ZooKeeper instance;</span><br><span class="line">    <span class="comment">//用Double check获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeper <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ZookeeperClient.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//连接时注册一个监听，监听连接状态变化</span></span><br><span class="line">                    instance = <span class="keyword">new</span> ZooKeeper(ZOOKEEPER_CONNECT, SESSION_TIMEOUT, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                        <span class="comment">//监听回调方法</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">//当连接状态变成connected，就说明连接成功</span></span><br><span class="line">                            <span class="keyword">if</span> (watchedEvent.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                                countDownLatch.countDown();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">//等待连接成功</span></span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSessionTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SESSION_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建分布式锁客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.SortedSet;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistibutedLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根目录，客户端都会去此目录下创建临时有序子节点</span></span><br><span class="line">    <span class="comment">//需要在zookeeper集群中有此目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ROOT_PATH = <span class="string">&quot;/apilock&quot;</span>;</span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zookeeper;</span><br><span class="line">    <span class="comment">//session超时时间</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> SESSION_TIMEOUT;</span><br><span class="line">    <span class="comment">//当前客户端创建有序节点的名称</span></span><br><span class="line">    <span class="keyword">private</span> String lockId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistibutedLock</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zookeeper =ZookeeperClient.getInstance();</span><br><span class="line">        <span class="keyword">this</span>.SESSION_TIMEOUT = ZookeeperClient.getSessionTimeout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建临时有序子节点</span></span><br><span class="line">            lockId = zookeeper.create(ROOT_PATH+<span class="string">&quot;/&quot;</span>,<span class="string">&quot;123&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;创建节点&quot;</span>+lockId+<span class="string">&quot;,开始竞争锁&quot;</span>);</span><br><span class="line">            <span class="comment">//获取/lock目录下所有子节点</span></span><br><span class="line">            List&lt;String&gt; children = zookeeper.getChildren(ROOT_PATH, <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//用SortedSet对子节点从小到大进行排序</span></span><br><span class="line">            SortedSet&lt;String&gt; sortedSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">                sortedSet.add(ROOT_PATH+<span class="string">&quot;/&quot;</span>+child);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取最小节点名称</span></span><br><span class="line">            String first = sortedSet.first();</span><br><span class="line">            <span class="comment">//如果当前创建节点就是最小节点，则获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (first.equals(lockId)) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取锁&quot;</span>+lockId);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取比当前id小的节点集合</span></span><br><span class="line">            SortedSet&lt;String&gt; frontSet = sortedSet.headSet(lockId);</span><br><span class="line">            <span class="keyword">if</span> (!frontSet.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//取集合中最后一个元素,也就是临近最小节点</span></span><br><span class="line">                String last = frontSet.last();</span><br><span class="line">                System.out.println(lockId+<span class="string">&quot;监听&quot;</span>+last);</span><br><span class="line">                <span class="comment">//当前节点去监听上一个节点，当上一个节点被删除的时候</span></span><br><span class="line">                <span class="comment">//当前节点就可以获取锁</span></span><br><span class="line">                zookeeper.exists(last, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (watchedEvent.getType() == Event.EventType.NodeDeleted) &#123;</span><br><span class="line">                            countDownLatch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                countDownLatch.await(SESSION_TIMEOUT, TimeUnit.MILLISECONDS);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁&quot;</span> + lockId);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始删除锁&quot;</span> + lockId);</span><br><span class="line">            <span class="comment">//删除当前节点</span></span><br><span class="line">            zookeeper.delete(lockId, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码    </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJavaApi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//等待器，当所有线程都执行到某个步骤才停止阻塞</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//模拟十个线程去获取锁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">                DistibutedLock lock = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock = <span class="keyword">new</span> DistibutedLock();</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">500</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(lock!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        lock.unLock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210320113632.png" alt=""></p>
</li>
</ol>
<h3 id="ZKClient实现分布式锁"><a href="#ZKClient实现分布式锁" class="headerlink" title="ZKClient实现分布式锁"></a>ZKClient实现分布式锁</h3><ol>
<li><p>导入jar</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>创建ZK客户端连接单例</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKClientInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZOOKEEPER_CONNECT=<span class="string">&quot;192.168.232.128:12181,192.168.232.128:12182,192.168.232.128:12183,192.168.232.128:12184&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> ZkClient instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZkClient <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ZKClientInstance.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> ZkClient(ZOOKEEPER_CONNECT,<span class="number">5000</span>,</span><br><span class="line">                            <span class="number">5000</span>,<span class="keyword">new</span> SerializableSerializer());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>创建分布式锁客户端</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.IZkDataListener;</span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.ZkClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.SortedSet;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKClientDisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT_PATH = <span class="string">&quot;/apilock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKClientDisLock</span><span class="params">(ZkClient zkClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zkClient = zkClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        lockId = zkClient.createEphemeralSequential(ROOT_PATH + <span class="string">&quot;/&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; children = zkClient.getChildren(ROOT_PATH);</span><br><span class="line">        SortedSet&lt;String&gt; sortedSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">            sortedSet.add(ROOT_PATH+<span class="string">&quot;/&quot;</span>+child);</span><br><span class="line">        &#125;</span><br><span class="line">        String first = sortedSet.first();</span><br><span class="line">        <span class="keyword">if</span> (first.equals(lockId)) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁&quot;</span> + lockId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SortedSet&lt;String&gt; frontSet = sortedSet.headSet(lockId);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != frontSet &amp;&amp; frontSet.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String last = frontSet.last();</span><br><span class="line">            IZkDataListener iZkDataListener = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(lockId + <span class="string">&quot;监听&quot;</span> + last + <span class="string">&quot;节点变化&quot;</span>);</span><br><span class="line">                iZkDataListener = <span class="keyword">new</span> IZkDataListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String s, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                zkClient.subscribeDataChanges(last, iZkDataListener);</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁&quot;</span> + lockId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                zkClient.unsubscribeDataChanges(last,iZkDataListener);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;释放锁&quot;</span>+ lockId + <span class="string">&quot;-----&quot;</span>);</span><br><span class="line">        zkClient.delete(lockId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>测试</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.king.zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestZkClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">                ZKClientDisLock lock = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock = <span class="keyword">new</span> ZKClientDisLock(ZKClientInstance.getInstance());</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">500</span>));</span><br><span class="line">                &#125;  <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(lock!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        lock.unLock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的分库分表</title>
    <url>/posts/85c1a08/</url>
    <content><![CDATA[<h2 id="分库分表前的问题"><a href="#分库分表前的问题" class="headerlink" title="分库分表前的问题"></a>分库分表前的问题</h2><p>任何问题都是太大或者太小的问题，我们这里面对的数据量太大的问题。</p>
<h3 id="用户请求量太大"><a href="#用户请求量太大" class="headerlink" title="用户请求量太大"></a>用户请求量太大</h3><p>因为单服务器TPS，内存，IO都是有限的。 </p>
<p><strong>解决方法</strong>：分散请求到多个服务器上； 其实用户请求和执行一个sql查询是本质是一样的，都是请求一个资源，只是用户请求还会经过网关，路由，http服务器等。</p>
<h3 id="单库太大"><a href="#单库太大" class="headerlink" title="单库太大"></a>单库太大</h3><p>单个数据库处理能力有限；单库所在服务器上磁盘空间不足；单库上操作的IO瓶颈 </p>
<p><strong>解决方法</strong>：切分成更多更小的库</p>
<h3 id="单表太大"><a href="#单表太大" class="headerlink" title="单表太大"></a>单表太大</h3><p>CRUD都成问题；索引膨胀，查询超时</p>
<p> <strong>解决方法</strong>：切分成多个数据集更小的表。将表中大字段单独存放在一张表中，不常用字段放在一张表中</p>
<h2 id="分库分表的方式方法"><a href="#分库分表的方式方法" class="headerlink" title="分库分表的方式方法"></a>分库分表的方式方法</h2><p>一般就是垂直切分和水平切分，这是一种结果集描述的切分方式，是物理空间上的切分。 我们从面临的问题，开始解决，阐述： 首先是用户请求量太大，我们就堆机器搞定（这不是本文重点）。然后是单个库太大，这时我们要看是因为表多而导致数据多，还是因为<strong>单张表里面的数据多</strong>。 如果是因为表多而数据多，使用<strong>垂直切分</strong>，根据业务切分成不同的库。如果是<strong>因为单张表的数据量太大</strong>，这时要用<strong>水平切分</strong>，即把表的数据按某种规则切分成多张表，甚至多个库上的多张表。 </p>
<p><strong>分库分表的顺序应该是先垂直分，后水平分。</strong> 因为垂直分更简单，更符合我们处理现实世界问题的方式。</p>
<h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><ol>
<li><p>垂直分表</p>
<p> 就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题</p>
</li>
<li><p>垂直分库</p>
<p> 垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。 切分后，要放在多个服务器上。在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。</p>
</li>
</ol>
<h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><ol>
<li><p>水平分表</p>
<p> 针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。</p>
</li>
<li><p>水平分库分表</p>
<p> 将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p>
</li>
<li><p>水平分库分表切分规则</p>
<ul>
<li>RANGE：从0到10000一个表，10001到20000一个表；</li>
<li>HASH取模：一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。</li>
<li>地理区域：比如按照华东，华南，华北这样来区分业务</li>
<li>时间：按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</li>
</ul>
</li>
</ol>
<h2 id="分库分表后面临的问题"><a href="#分库分表后面临的问题" class="headerlink" title="分库分表后面临的问题"></a>分库分表后面临的问题</h2><h3 id="跨节点-JOIN"><a href="#跨节点-JOIN" class="headerlink" title="跨节点 JOIN"></a>跨节点 JOIN</h3><p>在数据切分之前，关联查询可以直接通过 SQL JOIN 来完成，但是切分之后，数据可能分布在不同的节点上，此时进行关联查询就比较复杂了，一般应该尽量避免关联查询。</p>
<blockquote>
<p>在互联网业务系统中，本来在一开始就应该避免关联查询，如果存在关联查询，有很大的可能是因为设计的不够合理或者技术选型有误。报表类的系统在 BI 时代都是通过 OLAP、数据仓库等来实现的（现在更多的借助于离线分析、流式计算等），而不应该在数据库中直接执行大量的 JOIN 查询来进行统计和分析。</p>
</blockquote>
<p><strong>在无法避免跨节点 JOIN 操作时，一般普遍的做法是将查询分为两次，在第一次查询时找出关联数据的 ID，然后根据这些 ID 发起第二次查询得到关联数据。</strong></p>
<h3 id="跨节点分页排序"><a href="#跨节点分页排序" class="headerlink" title="跨节点分页排序"></a>跨节点分页排序</h3><p>一般情况下，分页都需要对数据进行排序。当排序字段就是分片字段时，通过分片规则我们可以比较容易地定位到具体的分片上，而当排序字段不是分片字段的时候，就需要在不同的分片中分别将数据进行排序，然后把结果集进行汇总并再次进行排序。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317150038.png" alt="image-20210317150038859"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317150050.png" alt="image-20210317150050514"></p>
<h3 id="跨节点排序、分组和聚合操作"><a href="#跨节点排序、分组和聚合操作" class="headerlink" title="跨节点排序、分组和聚合操作"></a>跨节点排序、分组和聚合操作</h3><p>与跨节点分页排序类似，多数的 sharding 组件都不会对这些操作（order by、group by、count、avg 等）自动进行合并，需要手工在各个节点上得到结果集，然后在应用中进行合并，内存消耗严重。</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>进行了分库分表以后，原先一次业务中的事务可能会涉及到多个数据库节点。举例来说，假如有一项消费业务，在用户选购完商品进行结算时，需要扣减用户余额，用户的积分和优惠券，而用户的积分和优惠券信息可能位于其他节点的数据库中，此时我们需要保证在结算时同时扣除余额、积分和优惠券，这一系列动作需要作为一个整体，也就是一个事务进行，这个事务就是分布式事务。</p>
<p>分布式事务常见的解决方案有：基于 XA 的 2PC（两阶段提交），以及 2PC 的改进版本 3PC、TCC（Try-Confirm-Cancel，事务补偿），性能出色的 Best Efforts 1PC 和基于消息队列的最终一致性方案等。</p>
<p>由于基于 XA 的标准分布式事务过于严格，在提交事务时需要多个节点之间进行协调，很大程度上延长了事务的执行时间，这会导致访问共享资源时发生冲突和死锁的概率增大，并且这种趋势会随着节点的增多而越发明显，从而成为系统在数据库层面上进行水平伸缩的枷锁，这也是很多 sharding 系统不使用标准分布式事务的原因。与之相对的，Best Efforts 1PC 具有出色的性能优势，同时实现的方式也比较简单，因此被大多数 sharding 系统所采用。</p>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>当数据库被切分到多个节点上时，我们就不能再以来数据库自身的主键生成机制了，因为我们无法保证某个分片上的数据库生成的 ID 在全局上是唯一的，同时我们的应用在插入数据前需要先获取 ID，以便进行 SQL 的路由</p>
<h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>常见的全局唯一主键生成方案中，UUID 是最简单的一个。标准的 UUID 包含 32 个 16 进制数字，以 <code>8-4-4-4-12</code> 的形式分为五段，比如：<code>550e8400-e29b-41d4-a716-446655440000</code>，目前业界共有五种生成 UUID 的方式，详情请见 IETF 发布的 UUID 规范：<a href="https://www.ietf.org/rfc/rfc4122.txt">A Universally Unique IDentifier (UUID) URN Namespace</a>。UUID 的优点是通过本地生成，没有网络消耗，性能非常高，缺点是长度过长不容易存储，且可能存在信息安全问题（基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露）。MySQL 官方对于主键的建议是越短越好，UUID 不符合要求，同时在 InnoDB 引擎中，UUID 的无序性可能会引起数据位置的频繁变动，严重影响性能。</p>
<h4 id="sequence-表"><a href="#sequence-表" class="headerlink" title="sequence 表"></a>sequence 表</h4><p>通过数据库维护一个 sequence 表，表结构类似于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `SEQUENCE` (</span><br><span class="line">    `table_name` <span class="type">varchar</span>(<span class="number">18</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `next_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`table_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当需要为某个表生成 ID 时，就从 sequence 表中取出对应表的 next_id，并将 next_id 的值增加 1 后更新到数据库中以备下次使用。这个方案实现简单，但是<strong>缺点也很明显，因为所有的插入操作都需要访问这张表，因此该表很容易成为性能瓶颈，同时它也存在单点问题。</strong></p>
<h4 id="snowflake"><a href="#snowflake" class="headerlink" title="snowflake"></a>snowflake</h4><p>snowflake 是 twitter 的分布式自增 ID 算法，又称雪花算法。这种算法的好处是整个 ID 是趋势递增的，性能很高也很灵活，但是由于强依赖机器的时钟，<strong>如果机器上的时钟回拨，会导致重复发号的问题</strong>。</p>
<p>还有一些是在雪花算法的基础上做了优化，比如百度的 <a href="https://github.com/baidu/uid-generator">uid-generator</a> 和美团的 <a href="https://github.com/Meituan-Dianping/Leaf">Leaf</a>。</p>
<h3 id="数据迁移、扩容等问题"><a href="#数据迁移、扩容等问题" class="headerlink" title="数据迁移、扩容等问题"></a>数据迁移、扩容等问题</h3><p>由于扩容后路由规则发生变化，扩容前的数据行很有可能需要进行数据迁移。在进行数据迁移时，一般是不允许停机的，因此理想的扩容方式就是避免数据迁移。</p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>目前分库分表的中间件主要分为两大类，一类是客户端架构，一类是代理架构。</p>
<p>客户端架构的中间件需要在应用中进行整合，中间件一般会以 jar 包的形式提供。通过修改应用的数据访问层（JDBC 或者以 JDBC 为基础的 ORM 框架）的方式对应用内产生的 SQL 进行解析、重写、路由、执行，并对结果集进行归并。这种架构的优点是无需对业务进行改造，简单且成本较低，但是缺点是中间件与应用绑定，对应用有一定的侵入性，不支持复杂的需求，并且对应用数据访问层的实现有限制。比较有代表性的产品为 <a href="https://github.com/apache/incubator-shardingsphere">ShardingSphere</a> 。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317150513.png" alt="image-20210317150513519"></p>
<p>代理架构的中间件一般是一个独立的服务，相当于实现了一个支持对应数据库协议的代理服务器。以 MySQL 为例，用户可以使用 MySQL 客户端工具或者命令行访问该中间件，中间件会使用 MySQL 协议与多个 MySQL 数据库服务器进行通信。这种架构的优点是能够处理非常复杂的需求，对应用数据访问层的实现没有限制，对于应用服务透明不会增加任何额外的负载，但是缺点是由于需要独立部署，增加了运维成本，同时应用需要经过一层代理才可以访问数据库，在网络上多了一跳，影响性能并可能会有额外的风险。比较有代表性的产品有 <a href="https://github.com/MyCATApache/Mycat-Server">MyCat</a> 和 <a href="https://github.com/alibaba/cobar">Cobar</a>。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的主从复制</title>
    <url>/posts/9ee789ff/</url>
    <content><![CDATA[<h2 id="为什么需要主从复制？"><a href="#为什么需要主从复制？" class="headerlink" title="为什么需要主从复制？"></a>为什么需要主从复制？</h2><ol>
<li>在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</li>
<li>做数据的热备</li>
<li>架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</li>
</ol>
<h2 id="MySQL-主从复制概念"><a href="#MySQL-主从复制概念" class="headerlink" title="MySQL 主从复制概念"></a>MySQL 主从复制概念</h2><p>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p>
<h2 id="MySQL-主从复制主要用途"><a href="#MySQL-主从复制主要用途" class="headerlink" title="MySQL 主从复制主要用途"></a>MySQL 主从复制主要用途</h2><ul>
<li><p><strong>读写分离</strong></p>
<p>  在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让主库负责写，从库负责读，这样，<strong>即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</strong></p>
</li>
<li><p><strong>数据实时备份，当系统中某个节点出现故障的时候，方便切换</strong></p>
</li>
<li><p><strong>高可用HA</strong></p>
</li>
<li><p><strong>架构扩展</strong></p>
<p>  随着系统中业务访问量的增大，如果是单机部署数据库，就会导致I/O访问频率过高。有了主从复制，增加多个数据存储节点，将负载分布在多个从节点上，降低单机磁盘I/O访问的频率，提高单个机器的I/O性能。</p>
</li>
</ul>
<h2 id="MySQL主从形式"><a href="#MySQL主从形式" class="headerlink" title="MySQL主从形式"></a>MySQL主从形式</h2><h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317105532.png" alt="image-20210317105532537"></p>
<h3 id="一主多从，提高系统的读性能"><a href="#一主多从，提高系统的读性能" class="headerlink" title="一主多从，提高系统的读性能"></a>一主多从，提高系统的读性能</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317105558.png" alt="image-20210317105558859"></p>
<p>一主一从和一主多从是最常见的主从架构，<strong>实施起来简单并且有效，不仅可以实现HA，而且还能读写分离，进而提升集群的并发能力。</strong></p>
<h3 id="多主一从-（从5-7开始支持）"><a href="#多主一从-（从5-7开始支持）" class="headerlink" title="多主一从 （从5.7开始支持）"></a>多主一从 （从5.7开始支持）</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317105629.png" alt="image-20210317105629817"></p>
<p>多主一从可以将多个mysql数据库备份到一台存储性能比较好的服务器上。</p>
<h3 id="双主复制"><a href="#双主复制" class="headerlink" title="双主复制"></a>双主复制</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317105653.png" alt="image-20210317105653639"></p>
<p>双主复制，也就是互做主从复制，每个master既是master，又是另外一台服务器的slave。这样任何一方所做的变更，都会通过复制应用到另外一方的数据库中。</p>
<h3 id="级联复制"><a href="#级联复制" class="headerlink" title="级联复制"></a>级联复制</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317105716.png" alt="image-20210317105716117"></p>
<p>级联复制模式下，部分slave的数据同步不连接主节点，而是连接从节点。因为如果主节点有太多的从节点，就会损耗一部分性能用于replication，那么我们可以让3~5个从节点连接主节点，其它从节点作为二级或者三级与从节点连接，这样不仅可以缓解主节点的压力，并且对数据一致性没有负面影响。</p>
<h2 id="MySQL-主从复制原理"><a href="#MySQL-主从复制原理" class="headerlink" title="MySQL 主从复制原理"></a>MySQL 主从复制原理</h2><p>MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点，如下图所示:</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317105757.png" alt="image-20210317105757055"></p>
<ul>
<li><strong>主节点 binary log dump 线程作用</strong></li>
</ul>
<p>当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。</p>
<ul>
<li><strong>从节点I/O线程作用</strong></li>
</ul>
<p>当从节点上执行<code>start slave</code>命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 进程发来的更新之后，保存在本地relay-log中。</p>
<ul>
<li><strong>从节点SQL线程作用</strong></li>
</ul>
<p>SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</p>
<p>对于每一个主从连接，都需要三个进程来完成。当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个binary log dump 进程，而每个从节点都有自己的I/O进程，SQL进程。从节点用两个线程将从主库拉取更新和执行分成独立的任务，这样在执行同步数据任务的时候，不会降低读操作的性能。比如，如果从节点没有运行，此时I/O进程可以很快从主节点获取更新，尽管SQL进程还没有执行。如果在SQL进程执行之前从节点服务停止，至少I/O进程已经从主节点拉取到了最新的变更并且保存在本地relay日志中，当服务再次起来之后，就可以完成数据的同步。</p>
<h2 id="MySQL主从复制的过程"><a href="#MySQL主从复制的过程" class="headerlink" title="MySQL主从复制的过程"></a>MySQL主从复制的过程</h2><p>要实施复制，首先必须打开Master 端的binary log（bin-log）功能，否则无法实现。因为整个复制过程实际上就是Slave 从Master 端获取该日志然后再在自己身上完全顺序的执行日志中所记录的各种操作</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317111427.png" alt="image-20210317111427620"></p>
<ol>
<li>从库通过手工执行change  master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），<strong>从库并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</strong></li>
<li>从库的IO线程和主库的dump线程建立连接。</li>
<li>从库根据change  master  to 语句提供的file名和position号，IO线程向主库发起binlog的请求。</li>
<li>主库dump线程根据从库的请求，将本地binlog以events的方式发给从库IO线程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position；</li>
<li>从库IO线程接收binlog  events，并存放到本地relay-log中，传送过来的信息，会记录到master.info中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；</li>
<li>从库SQL线程应用relay-log，并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay 会自动被清理purge</li>
</ol>
<h2 id="MySQL-主从复制模式"><a href="#MySQL-主从复制模式" class="headerlink" title="MySQL 主从复制模式"></a>MySQL 主从复制模式</h2><p>MySQL 主从复制<strong>默认是异步的模式</strong>。MySQL增删改操作会全部记录在binary log中，当slave节点连接master时，会主动从master处获取最新的bin log文件。并把bin log中的sql relay。</p>
<h3 id="异步模式（mysql-async-mode）"><a href="#异步模式（mysql-async-mode）" class="headerlink" title="异步模式（mysql async-mode）"></a>异步模式（mysql async-mode）</h3><p>异步模式如下图所示，这种模式下，主节点不会主动push bin log到从节点，这样有可能导致failover的情况下，也许从节点没有即时地将最新的bin log同步到本地。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317114402.png" alt="image-20210317114402919"></p>
<h3 id="半同步模式-mysql-semi-sync"><a href="#半同步模式-mysql-semi-sync" class="headerlink" title="半同步模式(mysql semi-sync)"></a>半同步模式(mysql semi-sync)</h3><p>这种模式下<strong>主节点只需要接收到其中一台从节点的返回信息，就会commit；否则需要等待直到超时时间然后切换成异步模式再提交</strong>；这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性，确保了事务提交后，<strong>binlog至少传输到了一个从节点上，不能保证从节点将此事务更新到db中</strong>。性能上会有一定的降低，响应时间会变长。如下图所示：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317114614.png" alt="image-20210317114614139"></p>
<h3 id="全同步模式"><a href="#全同步模式" class="headerlink" title="全同步模式"></a>全同步模式</h3><p>全同步模式是指主节点和<strong>从节点全部执行了commit并确认</strong>才会向客户端返回成功。</p>
<h2 id="MySQL的复制机制"><a href="#MySQL的复制机制" class="headerlink" title="MySQL的复制机制"></a>MySQL的复制机制</h2><h3 id="binlog记录模式"><a href="#binlog记录模式" class="headerlink" title="binlog记录模式"></a>binlog记录模式</h3><p>MySQL 主从复制有三种方式：基于SQL语句的复制（statement-based replication，SBR），基于行的复制（row-based replication，RBR)，混合模式复制（mixed-based replication,MBR)。对应的binlog文件的格式也有三种：STATEMENT,ROW,MIXED。</p>
<ol>
<li>Statement-base Replication (SBR)就是记录sql语句在bin log中，Mysql 5.1.4 及之前的版本都是使用的这种复制格式。优点是只需要记录会修改数据的sql语句到binlog中，减少了binlog日质量，节约I/O，提高性能。缺点是在某些情况下，会导致主从节点中数据不一致（比如sleep(),now()等）。</li>
<li>Row-based Relication(RBR)是mysql master将SQL语句分解为基于Row更改的语句并记录在bin log中，也就是只记录哪条数据被修改了，修改成什么样。优点是不会出现某些特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是修改table的时候会让日志暴增,同时增加bin log同步时间。也不能通过bin log解析获取执行过的sql语句，只能看到发生的data变更。</li>
<li>Mixed-format Replication(MBR)，MySQL NDB cluster 7.3 和7.4 使用的MBR。是以上两种模式的混合，对于一般的复制使用STATEMENT模式保存到binlog，对于STATEMENT模式无法复制的操作则使用ROW模式来保存，MySQL会根据执行的SQL语句选择日志保存方式。</li>
</ol>
<h3 id="GTID复制模式"><a href="#GTID复制模式" class="headerlink" title="GTID复制模式"></a>GTID复制模式</h3><p>在MySQL 5.6里面，不用再找binlog和pos点，我们只需要知道主节点的ip，端口，以及账号密码就行，因为复制是自动的，<strong>MySQL会通过内部机制GTID自动找点同步。</strong></p>
<h4 id="基于GTID复制实现的工作原理"><a href="#基于GTID复制实现的工作原理" class="headerlink" title="基于GTID复制实现的工作原理"></a>基于GTID复制实现的工作原理</h4><ol>
<li>主节点更新数据时，会在事务前产生GTID，一起记录到binlog日志中。</li>
<li>从节点的I/O线程将变更的bin log，写入到本地的relay log中。</li>
<li>SQL线程从relay log中获取GTID，然后对比本地binlog是否有记录（<strong>所以MySQL从节点必须要开启binary log</strong>）。</li>
<li>如果有记录，说明该GTID的事务已经执行，从节点会忽略。</li>
<li>如果没有记录，从节点就会从relay log中执行该GTID的事务，并记录到bin log。</li>
<li>在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描。</li>
</ol>
<h2 id="mysql主从同步延时分析"><a href="#mysql主从同步延时分析" class="headerlink" title="mysql主从同步延时分析"></a>mysql主从同步延时分析</h2><p>mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高，slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多，另一方面，由于sql thread也是单线程的，<strong>当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。</strong></p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。</li>
<li>单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库</li>
<li>服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。</li>
<li>不同业务的mysql物理上放在不同机器，分散压力。</li>
<li>使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。</li>
<li>使用更加强劲的硬件设备</li>
</ol>
<p><strong>mysql5.7之后使用MTS并行复制技术</strong></p>
<h3 id="多线程复制MTS"><a href="#多线程复制MTS" class="headerlink" title="多线程复制MTS"></a>多线程复制MTS</h3><p>在MYSQL5.6版本中，多线程复制基于schema来实现，将多个数据库下的事务按照数据库拆分到多个线程上执行，保证数据库级别的事务一致性。</p>
<p>在MYSQL5.7版本后，多线程复制基于主库上并发信息来实现，主库上并发提交的事务不存在事务冲突，在从库上拆分到多个线程执行，保证实例级别的事务一致性。</p>
<h4 id="MySQL5-6-基于schema的并行复制"><a href="#MySQL5-6-基于schema的并行复制" class="headerlink" title="MySQL5.6 基于schema的并行复制"></a>MySQL5.6 基于schema的并行复制</h4><p>slave-parallel-type=DATABASE(不同库的事务，没有锁冲突),并行复制的目的就是要让slave尽可能的多线程跑起来，当然基于库级别的多线程也是一种方式(不同库的事务，没有锁冲突)。</p>
<p><strong>优点：</strong>实现相对来说简单，对用户来说使用起来也简单</p>
<p><strong>缺点：</strong> 由于是基于库的，那么并行的粒度非常粗，现在很多公司的架构是一库一实例，针对这样的架构，5.6的并行复制无能为力。当然还有就是主从事务的先后顺序，对于5.6也是个大问题</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317143020.png" alt="image-20210317143020298"></p>
<p>MySQL 5.6版本开启并行复制功能，那么SQL线程就变为了coordinator线程，coordinator线程主要负责以前两部分的内容：</p>
<ul>
<li>若判断可以并行执行，那么选择worker线程执行事务的二进制日志</li>
<li>若判断不可以并行执行，如该操作是DDL，亦或者是事务跨schema操作，则等待所有的worker线程执行完成之后，再执行当前的日志</li>
</ul>
<p>这意味着coordinator线程并不是仅将日志发送给worker线程，自己也可以回放日志，但是所有可以并行的操作交付由worker线程完成。coordinator线程与worker是典型的生产者与消费者模型。</p>
<p>上述机制实现了基于schema的并行复制存在两个问题，首先是crash safe功能不好做，因为可能之后执行的事务由于并行复制的关系先完成执行，那么当发生crash的时候，这部分的处理逻辑是比较复杂的。从代码上看，5.6这里引入了Low-Water-Mark标记来解决该问题，从设计上看（WL#5569），其是希望借助于日志的幂等性来解决该问题，不过5.6的二进制日志回放还不能实现幂等性。另一个最为关键的问题是这样设计的并行复制效果并不高，如果用户实例仅有一个库，那么就无法实现并行回放，甚至性能会比原来的单线程更差。而单库多表是比多库多表更为常见的一种情形。</p>
<h4 id="MySQL-5-7基于组提交的并行复制"><a href="#MySQL-5-7基于组提交的并行复制" class="headerlink" title="MySQL 5.7基于组提交的并行复制"></a>MySQL 5.7基于组提交的并行复制</h4><p>MySQL 5.7才可称为真正的并行复制，这其中最为主要的原因就是slave服务器的回放与主机是一致的即master服务器上是怎么并行执行的slave上就怎样进行并行回放。不再有库的并行复制限制，对于二进制日志格式也无特殊的要求（基于库的并行复制也没有要求）。从MySQL官方来看，其并行复制的原本计划是支持表级的并行复制和行级的并行复制，行级的并行复制通过解析ROW格式的二进制日志的方式来完成，WL#4648。但是最终出现给小伙伴的确是在开发计划中称为：MTS: Prepared transactions slave parallel applier，可见：WL#6314。该并行复制的思想最早是由MariaDB的Kristain提出，并已在MariaDB 10中出现，相信很多选择MariaDB的小伙伴最为看重的功能之一就是并行复制。</p>
<blockquote>
<p>MySQL 5.7并行复制的思想简单易懂，一言以蔽之：<font color=red>一个组提交的事务都是可以并行回放，因为这些事务都已进入到事务的prepare阶段，则说明事务之间没有任何冲突（否则就不可能提交）。</font></p>
</blockquote>
<p>为了兼容MySQL 5.6基于库的并行复制，5.7引入了新的变量slave-parallel-type，其可以配置的值有：</p>
<ul>
<li>DATABASE：默认值，基于库的并行复制方式</li>
<li>LOGICAL_CLOCK：基于组提交的并行复制方式</li>
</ul>
<h5 id="支持并行复制的GTID（5-7之后支持）"><a href="#支持并行复制的GTID（5-7之后支持）" class="headerlink" title="支持并行复制的GTID（5.7之后支持）"></a>支持并行复制的GTID（5.7之后支持）</h5><p>在MySQL 5.7版本中，其设计方式是将组提交的信息存放在GTID中。那么如果用户没有开启GTID功能，即将参数gtid_mode设置为OFF，MySQL 5.7又引入了称之为Anonymous_Gtid的二进制日志event类型，意味着在<strong>MySQL 5.7版本中即使不开启GTID，每个事务开始前也是会存在一个Anonymous_Gtid，而这GTID中就存在着组提交的信息。</strong></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317143937.png" alt="image-20210317143937183"></p>
<p>然而，通过上述的SHOW BINLOG EVENTS，我们并没有发现有关组提交的任何信息。但是通过mysqlbinlog工具，用户就能发现组提交的内部信息：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210317144000.png" alt="image-20210317143959999"></p>
<p>可以发现较之原来的二进制日志内容多了last_committed和sequence_number，last_committed表示事务提交的时候，上次事务提交的编号，如果<strong>事务具有相同的last_committed，表示这些事务都在一组内，可以进行并行的回放。例如上述last_committed为0的事务有6个，表示组提交时提交了6个事务，而这6个事务在从机是可以进行并行回放的。</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/posts/c3176455/</url>
    <content><![CDATA[<h2 id="备忘录模式的定义与特点"><a href="#备忘录模式的定义与特点" class="headerlink" title="备忘录模式的定义与特点"></a>备忘录模式的定义与特点</h2><p>备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p>
<h2 id="备忘录模式的优缺点"><a href="#备忘录模式的优缺点" class="headerlink" title="备忘录模式的优缺点"></a>备忘录模式的优缺点</h2><ol>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>
</ol>
<h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><p>备忘录模式使用三个类 <em>Memento</em>、<em>Originator</em> 和 <em>CareTaker</em>。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316174209.png" alt="image-20210316174209023"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String state;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String state;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Memento <span class="title">saveStateToMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento Memento)</span></span>&#123;</span><br><span class="line">      state = Memento.getState();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;Memento&gt;();</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento state)</span></span>&#123;</span><br><span class="line">      mementoList.add(state);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MementoPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">      CareTaker careTaker = <span class="keyword">new</span> CareTaker();</span><br><span class="line">      originator.setState(<span class="string">&quot;State #1&quot;</span>);</span><br><span class="line">      originator.setState(<span class="string">&quot;State #2&quot;</span>);</span><br><span class="line">      careTaker.add(originator.saveStateToMemento());</span><br><span class="line">      originator.setState(<span class="string">&quot;State #3&quot;</span>);</span><br><span class="line">      careTaker.add(originator.saveStateToMemento());</span><br><span class="line">      originator.setState(<span class="string">&quot;State #4&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;Current State: &quot;</span> + originator.getState());    </span><br><span class="line">      originator.getStateFromMemento(careTaker.get(<span class="number">0</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;First saved State: &quot;</span> + originator.getState());</span><br><span class="line">      originator.getStateFromMemento(careTaker.get(<span class="number">1</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Second saved State: &quot;</span> + originator.getState());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316174409.png" alt="image-20210316174409229"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/posts/30cf0cd2/</url>
    <content><![CDATA[<h2 id="解释器模式的定义与特点"><a href="#解释器模式的定义与特点" class="headerlink" title="解释器模式的定义与特点"></a>解释器模式的定义与特点</h2><p>解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p>
<h2 id="解释器模式的优缺点"><a href="#解释器模式的优缺点" class="headerlink" title="解释器模式的优缺点"></a>解释器模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li>
<li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li>
<li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li>
<li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li>
</ol>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol>
<li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li>
<li>终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li>
<li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li>
<li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li>
<li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li>
</ol>
<h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><p>创建一个接口 <em>Expression</em> 和实现了 <em>Expression</em> 接口的实体类。定义作为上下文中主要解释器的 <em>TerminalExpression</em> 类。其他的类 <em>OrExpression</em>、<em>AndExpression</em> 用于创建组合式表达式。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316173630.png" alt="image-20210316173630671"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String data;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data; </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(context.contains(data))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> Expression expr1 = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">private</span> Expression expr2 = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">OrExpression</span><span class="params">(Expression expr1, Expression expr2)</span> </span>&#123; </span><br><span class="line">      <span class="keyword">this</span>.expr1 = expr1;</span><br><span class="line">      <span class="keyword">this</span>.expr2 = expr2;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;      </span><br><span class="line">      <span class="keyword">return</span> expr1.interpret(context) || expr2.interpret(context);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> Expression expr1 = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">private</span> Expression expr2 = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression expr1, Expression expr2)</span> </span>&#123; </span><br><span class="line">      <span class="keyword">this</span>.expr1 = expr1;</span><br><span class="line">      <span class="keyword">this</span>.expr2 = expr2;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;      </span><br><span class="line">      <span class="keyword">return</span> expr1.interpret(context) &amp;&amp; expr2.interpret(context);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpreterPatternDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//规则：Robert 和 John 是男性</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMaleExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Expression robert = <span class="keyword">new</span> TerminalExpression(<span class="string">&quot;Robert&quot;</span>);</span><br><span class="line">      Expression john = <span class="keyword">new</span> TerminalExpression(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> OrExpression(robert, john);    </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//规则：Julie 是一个已婚的女性</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMarriedWomanExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Expression julie = <span class="keyword">new</span> TerminalExpression(<span class="string">&quot;Julie&quot;</span>);</span><br><span class="line">      Expression married = <span class="keyword">new</span> TerminalExpression(<span class="string">&quot;Married&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> AndExpression(julie, married);    </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Expression isMale = getMaleExpression();</span><br><span class="line">      Expression isMarriedWoman = getMarriedWomanExpression();</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;John is male? &quot;</span> + isMale.interpret(<span class="string">&quot;John&quot;</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Julie is a married women? &quot;</span> </span><br><span class="line">      + isMarriedWoman.interpret(<span class="string">&quot;Married Julie&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316173942.png" alt="image-20210316173942497"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/posts/f5c535ea/</url>
    <content><![CDATA[<h2 id="适配器模式的定义与特点"><a href="#适配器模式的定义与特点" class="headerlink" title="适配器模式的定义与特点"></a>适配器模式的定义与特点</h2><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<h2 id="适配器模式的优缺点"><a href="#适配器模式的优缺点" class="headerlink" title="适配器模式的优缺点"></a>适配器模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
<li>在很多业务场景中符合开闭原则</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。</li>
<li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li>
</ol>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>类适配器模式可采用多重继承方式实现</p>
<p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。</p>
<h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ol>
<h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><p>一个 <em>MediaPlayer</em> 接口和一个实现了 <em>MediaPlayer</em> 接口的实体类 <em>AudioPlayer</em>。默认情况下，<em>AudioPlayer</em> 可以播放 mp3 格式的音频文件。</p>
<p>我们还有另一个接口 <em>AdvancedMediaPlayer</em> 和实现了 <em>AdvancedMediaPlayer</em> 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。</p>
<p>我们想要让 <em>AudioPlayer</em> 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 <em>MediaPlayer</em> 接口的适配器类 <em>MediaAdapter</em>，并使用 <em>AdvancedMediaPlayer</em> 对象来播放所需的格式。</p>
<p><em>AudioPlayer</em> 使用适配器类 <em>MediaAdapter</em> 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。<em>AdapterPatternDemo</em> 类使用 <em>AudioPlayer</em> 类来播放各种格式。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316171754.png" alt="image-20210316171754786"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VlcPlayer</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Playing vlc file. Name: &quot;</span>+ fileName);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//什么也不做</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp4Player</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//什么也不做</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Playing mp4 file. Name: &quot;</span>+ fileName);      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaAdapter</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   AdvancedMediaPlayer advancedMusicPlayer;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MediaAdapter</span><span class="params">(String audioType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">&quot;vlc&quot;</span>) )&#123;</span><br><span class="line">         advancedMusicPlayer = <span class="keyword">new</span> VlcPlayer();       </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>))&#123;</span><br><span class="line">         advancedMusicPlayer = <span class="keyword">new</span> Mp4Player();</span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">&quot;vlc&quot;</span>))&#123;</span><br><span class="line">         advancedMusicPlayer.playVlc(fileName);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>))&#123;</span><br><span class="line">         advancedMusicPlayer.playMp4(fileName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">   MediaAdapter mediaAdapter; </span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;    </span><br><span class="line"> </span><br><span class="line">      <span class="comment">//播放 mp3 音乐文件的内置支持</span></span><br><span class="line">      <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">&quot;mp3&quot;</span>))&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Playing mp3 file. Name: &quot;</span>+ fileName);         </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">//mediaAdapter 提供了播放其他文件格式的支持</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">&quot;vlc&quot;</span>) </span><br><span class="line">         || audioType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>))&#123;</span><br><span class="line">         mediaAdapter = <span class="keyword">new</span> MediaAdapter(audioType);</span><br><span class="line">         mediaAdapter.play(audioType, fileName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Invalid media. &quot;</span>+</span><br><span class="line">            audioType + <span class="string">&quot; format not supported&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      AudioPlayer audioPlayer = <span class="keyword">new</span> AudioPlayer();</span><br><span class="line"> </span><br><span class="line">      audioPlayer.play(<span class="string">&quot;mp3&quot;</span>, <span class="string">&quot;beyond the horizon.mp3&quot;</span>);</span><br><span class="line">      audioPlayer.play(<span class="string">&quot;mp4&quot;</span>, <span class="string">&quot;alone.mp4&quot;</span>);</span><br><span class="line">      audioPlayer.play(<span class="string">&quot;vlc&quot;</span>, <span class="string">&quot;far far away.vlc&quot;</span>);</span><br><span class="line">      audioPlayer.play(<span class="string">&quot;avi&quot;</span>, <span class="string">&quot;mind me.avi&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316172211.png" alt="image-20210316172211689"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/posts/64b51ed9/</url>
    <content><![CDATA[<h2 id="访问者模式的定义与特点"><a href="#访问者模式的定义与特点" class="headerlink" title="访问者模式的定义与特点"></a>访问者模式的定义与特点</h2><p>访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p>
<h2 id="访问者模式的优缺点"><a href="#访问者模式的优缺点" class="headerlink" title="访问者模式的优缺点"></a>访问者模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>
<li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>
<li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li>
<li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li>
<li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li>
</ol>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol>
<li>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</li>
<li>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</li>
<li>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</li>
<li>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</li>
<li>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现</li>
</ol>
<h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><p>建一个定义接受操作的 <em>ComputerPart</em> 接口。<em>Keyboard</em>、<em>Mouse</em>、<em>Monitor</em> 和 <em>Computer</em> 是实现了 <em>ComputerPart</em> 接口的实体类。我们将定义另一个接口 <em>ComputerPartVisitor</em>，它定义了访问者类的操作。<em>Computer</em> 使用实体访问者来执行相应的动作。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316170048.png" alt="image-20210316170048207"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span>  <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">      computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monitor</span>  <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">      computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span>  <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">      computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   ComputerPart[] parts;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">()</span></span>&#123;</span><br><span class="line">      parts = <span class="keyword">new</span> ComputerPart[] &#123;<span class="keyword">new</span> Mouse(), <span class="keyword">new</span> Keyboard(), <span class="keyword">new</span> Monitor()&#125;;      </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parts.length; i++) &#123;</span><br><span class="line">         parts[i].accept(computerPartVisitor);</span><br><span class="line">      &#125;</span><br><span class="line">      computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerPartVisitor</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Computer computer)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Mouse mouse)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Keyboard keyboard)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Monitor monitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerPartDisplayVisitor</span> <span class="keyword">implements</span> <span class="title">ComputerPartVisitor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Computer.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Mouse mouse)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Mouse.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Keyboard keyboard)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Keyboard.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Monitor monitor)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Monitor.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      ComputerPart computer = <span class="keyword">new</span> Computer();</span><br><span class="line">      computer.accept(<span class="keyword">new</span> ComputerPartDisplayVisitor());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/posts/d036071c/</url>
    <content><![CDATA[<h2 id="中介者模式的定义与特点"><a href="#中介者模式的定义与特点" class="headerlink" title="中介者模式的定义与特点"></a>中介者模式的定义与特点</h2><p>中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p>
<h2 id="中介者模式的优缺点"><a href="#中介者模式的优缺点" class="headerlink" title="中介者模式的优缺点"></a>中介者模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>类之间各司其职，符合迪米特法则。</li>
<li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li>
<li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。</p>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol>
<li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li>
<li>具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li>
<li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li>
<li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li>
</ol>
<h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><p>聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 <em>ChatRoom</em> 和 <em>User</em>。<em>User</em> 对象使用 <em>ChatRoom</em> 方法来分享他们的消息。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316164827.png" alt="image-20210316164827842"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> <span class="comment">//中介者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(User user, String message)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="keyword">new</span> Date().toString()</span><br><span class="line">         + <span class="string">&quot; [&quot;</span> + user.getName() +<span class="string">&quot;] : &quot;</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name  = name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">      ChatRoom.showMessage(<span class="keyword">this</span>,message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      User robert = <span class="keyword">new</span> User(<span class="string">&quot;Robert&quot;</span>);</span><br><span class="line">      User john = <span class="keyword">new</span> User(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      robert.sendMessage(<span class="string">&quot;Hi! John!&quot;</span>);</span><br><span class="line">      john.sendMessage(<span class="string">&quot;Hello! Robert!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316165112.png" alt="image-20210316165112042"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/posts/9a246216/</url>
    <content><![CDATA[<h2 id="观察者模式的定义与特点"><a href="#观察者模式的定义与特点" class="headerlink" title="观察者模式的定义与特点"></a>观察者模式的定义与特点</h2><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，<strong>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</strong>。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p>
<h2 id="观察者模式的优缺点"><a href="#观察者模式的优缺点" class="headerlink" title="观察者模式的优缺点"></a>观察者模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。</li>
<li>目标与观察者之间建立了一套触发机制。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li>
</ol>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol>
<li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li>
<li>具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li>
<li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li>
</ol>
<h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><p>使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 <em>Subject</em> 类、<em>Observer</em> 抽象类和扩展了抽象类 <em>Observer</em> 的实体类。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316161241.png" alt="image-20210316161241381"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> List&lt;Observer&gt; observers </span><br><span class="line">      = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">      observers.add(observer);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">         observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> Subject subject;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">&quot;Binary String: &quot;</span> </span><br><span class="line">      + Integer.toBinaryString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">OctalObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println( <span class="string">&quot;Octal String: &quot;</span> </span><br><span class="line">     + Integer.toOctalString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HexaObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">&quot;Hex String: &quot;</span> </span><br><span class="line">      + Integer.toHexString( subject.getState() ).toUpperCase() ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">new</span> HexaObserver(subject);</span><br><span class="line">      <span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line">      <span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;First state change: 15&quot;</span>);   </span><br><span class="line">      subject.setState(<span class="number">15</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Second state change: 10&quot;</span>);  </span><br><span class="line">      subject.setState(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316162206.png" alt="image-20210316162206246"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/posts/6208627e/</url>
    <content><![CDATA[<h2 id="责任链模式的定义与特点"><a href="#责任链模式的定义与特点" class="headerlink" title="责任链模式的定义与特点"></a>责任链模式的定义与特点</h2><p>责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<font color=red>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。</font>

<p>责任链模式的本质是<strong>解耦请求与处理</strong>，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。</p>
<h2 id="责任链模式的优缺点"><a href="#责任链模式的优缺点" class="headerlink" title="责任链模式的优缺点"></a>责任链模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li>
<li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li>
<li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li>
<li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li>
<li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li>
</ol>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><p>职责链模式主要包含以下角色。</p>
<ol>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ol>
<p>建抽象类 <em>AbstractLogger</em>，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 <em>AbstractLogger</em>。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。</p>
<h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316155839.png" alt="image-20210316155839797"></p>
<h4 id="抽象处理者（Handler）"><a href="#抽象处理者（Handler）" class="headerlink" title="抽象处理者（Handler）"></a>抽象处理者（Handler）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//责任链中的下一个元素</span></span><br><span class="line">   <span class="keyword">protected</span> AbstractLogger nextLogger;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.nextLogger = nextLogger;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.level &lt;= level)&#123;</span><br><span class="line">         write(message);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(nextLogger !=<span class="keyword">null</span>)&#123;</span><br><span class="line">         nextLogger.logMessage(level, message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体处理者（Concrete-Handler）"><a href="#具体处理者（Concrete-Handler）" class="headerlink" title="具体处理者（Concrete Handler）"></a>具体处理者（Concrete Handler）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConsoleLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span><br><span class="line">      System.out.println(<span class="string">&quot;Standard Console::Logger: &quot;</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span><br><span class="line">      System.out.println(<span class="string">&quot;Error Console::Logger: &quot;</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span><br><span class="line">      System.out.println(<span class="string">&quot;File::Logger: &quot;</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户类（Client）"><a href="#客户类（Client）" class="headerlink" title="客户类（Client）"></a>客户类（Client）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractLogger <span class="title">getChainOfLoggers</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        AbstractLogger errorLogger = <span class="keyword">new</span> ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">        AbstractLogger fileLogger = <span class="keyword">new</span> FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">        AbstractLogger consoleLogger = <span class="keyword">new</span> ConsoleLogger(AbstractLogger.INFO);</span><br><span class="line"></span><br><span class="line">        errorLogger.setNextLogger(fileLogger);</span><br><span class="line">        fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> errorLogger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractLogger loggerChain = Client.getChainOfLoggers();</span><br><span class="line"></span><br><span class="line">        loggerChain.logMessage(AbstractLogger.INFO, <span class="string">&quot;This is an information.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        loggerChain.logMessage(AbstractLogger.DEBUG,</span><br><span class="line">                <span class="string">&quot;This is a debug level information.&quot;</span>);</span><br><span class="line">   			System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.ERROR,</span><br><span class="line">                <span class="string">&quot;This is an error information.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316160844.png" alt="image-20210316160844800"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/posts/78134e07/</url>
    <content><![CDATA[<h2 id="命令模式的定义与特点"><a href="#命令模式的定义与特点" class="headerlink" title="命令模式的定义与特点"></a>命令模式的定义与特点</h2><p>命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p>
<h2 id="命令模式的优缺点"><a href="#命令模式的优缺点" class="headerlink" title="命令模式的优缺点"></a>命令模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>通过引入中间件（抽象接口）降低系统的耦合度。</li>
<li>扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>
<li>可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。</li>
<li>命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难</li>
</ol>
<h2 id="命令模式的结构与实现"><a href="#命令模式的结构与实现" class="headerlink" title="命令模式的结构与实现"></a>命令模式的结构与实现</h2><p>可以将系统中的相关操作抽象成命令，使调用者与实现者相关分离，其结构如下。</p>
<h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol>
<li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li>
<li>具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ol>
<h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><p>建作为命令的接口 <em>Order</em>，然后创建作为请求的 <em>Stock</em> 类。实体命令类 <em>BuyStock</em> 和 <em>SellStock</em>，实现了 <em>Order</em> 接口，将执行实际的命令处理。创建作为调用对象的类 <em>Broker</em>，它接受订单并能下订单。<em>Broker</em> 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316154017.png" alt="image-20210316154017050"></p>
<h4 id="抽象命令类（Command）"><a href="#抽象命令类（Command）" class="headerlink" title="抽象命令类（Command）"></a>抽象命令类（Command）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体命令类（Concrete-Command）"><a href="#具体命令类（Concrete-Command）" class="headerlink" title="具体命令类（Concrete Command）"></a>具体命令类（Concrete Command）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String name = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> quantity = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Stock [ Name: &quot;</span>+name+<span class="string">&quot;, </span></span><br><span class="line"><span class="string">         Quantity: &quot;</span> + quantity +<span class="string">&quot; ] bought&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Stock [ Name: &quot;</span>+name+<span class="string">&quot;, </span></span><br><span class="line"><span class="string">         Quantity: &quot;</span> + quantity +<span class="string">&quot; ] sold&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现者-接收者（Receiver）"><a href="#实现者-接收者（Receiver）" class="headerlink" title="实现者/接收者（Receiver）"></a>实现者/接收者（Receiver）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyStock</span> <span class="keyword">implements</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BuyStock</span><span class="params">(Stock abcStock)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      abcStock.buy();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStock</span> <span class="keyword">implements</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SellStock</span><span class="params">(Stock abcStock)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      abcStock.sell();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用者-请求者（Invoker）"><a href="#调用者-请求者（Invoker）" class="headerlink" title="调用者/请求者（Invoker）"></a>调用者/请求者（Invoker）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Broker</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Order&gt; orderList = <span class="keyword">new</span> ArrayList&lt;Order&gt;(); </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeOrder</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">      orderList.add(order);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrders</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">         order.execute();</span><br><span class="line">      &#125;</span><br><span class="line">      orderList.clear();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Stock abcStock = <span class="keyword">new</span> Stock();</span><br><span class="line"> </span><br><span class="line">      BuyStock buyStockOrder = <span class="keyword">new</span> BuyStock(abcStock);</span><br><span class="line">      SellStock sellStockOrder = <span class="keyword">new</span> SellStock(abcStock);</span><br><span class="line"> </span><br><span class="line">      Broker broker = <span class="keyword">new</span> Broker();</span><br><span class="line">      broker.takeOrder(buyStockOrder);</span><br><span class="line">      broker.takeOrder(sellStockOrder);</span><br><span class="line"> </span><br><span class="line">      broker.placeOrders();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316154944.png" alt="image-20210316154944139"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/posts/72e3b671/</url>
    <content><![CDATA[<h2 id="策略模式的定义与特点"><a href="#策略模式的定义与特点" class="headerlink" title="策略模式的定义与特点"></a>策略模式的定义与特点</h2><p>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<h2 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句，如 if…else 语句、switch…case 语句。</li>
<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li>
<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li>
<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li>
<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</li>
<li>策略模式造成很多的策略类，增加维护难度。</li>
</ol>
<h2 id="策略模式的结构与实现"><a href="#策略模式的结构与实现" class="headerlink" title="策略模式的结构与实现"></a>策略模式的结构与实现</h2><p>策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性</p>
<h4 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>策略模式的主要角色如下。</p>
<ol>
<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ol>
<h4 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h4><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316152609.png" alt="image-20210316152609333"></p>
<p>创建一个定义活动的 <em>Strategy</em> 接口和实现了 <em>Strategy</em> 接口的实体策略类。<em>Context</em> 是一个使用了某种策略的类。<em>StrategyPatternDemo</em>使用 <em>Context</em> 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。</p>
<h5 id="抽象策略（Strategy）类"><a href="#抽象策略（Strategy）类" class="headerlink" title="抽象策略（Strategy）类"></a>抽象策略（Strategy）类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体策略（Concrete-Strategy）类"><a href="#具体策略（Concrete-Strategy）类" class="headerlink" title="具体策略（Concrete Strategy）类"></a>具体策略（Concrete Strategy）类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubtract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 * num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Context-类"><a href="#Context-类" class="headerlink" title="Context 类"></a><em>Context</em> 类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());    </span><br><span class="line">      System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubtract());      </span><br><span class="line">      System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());    </span><br><span class="line">      System.out.println(<span class="string">&quot;10 * 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316153313.png" alt="image-20210316153313630"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模版方法模式</title>
    <url>/posts/5029c2a3/</url>
    <content><![CDATA[<h2 id="模版方法模式的定义与特点"><a href="#模版方法模式的定义与特点" class="headerlink" title="模版方法模式的定义与特点"></a>模版方法模式的定义与特点</h2><p>模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
<h2 id="模版方法模式的优缺点"><a href="#模版方法模式的优缺点" class="headerlink" title="模版方法模式的优缺点"></a>模版方法模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>它封装了不变部分，扩展可变部分。它把认为是<font color=red>不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</font></li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
<li>由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。</li>
</ol>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><p>模板方法模式包含以下主要角色。</p>
<h4 id="抽象类-抽象模板（Abstract-Class）"><a href="#抽象类-抽象模板（Abstract-Class）" class="headerlink" title="抽象类/抽象模板（Abstract Class）"></a>抽象类/抽象模板（Abstract Class）</h4><p>抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</p>
<ol>
<li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法</li>
<li>基本方法：是整个算法中的一个步骤，包含以下几种类型。<ul>
<li>抽象方法：在抽象类中声明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
</li>
</ol>
<h4 id="具体子类-具体实现（Concrete-Class）"><a href="#具体子类-具体实现（Concrete-Class）" class="headerlink" title="具体子类/具体实现（Concrete Class）"></a>具体子类/具体实现（Concrete Class）</h4><p>具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</p>
<h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><p>创建一个定义操作的 <em>Game</em> 抽象类，其中，模板方法设置为 final，这样它就不会被重写。<em>Cricket</em> 和 <em>Football</em> 是扩展了 <em>Game</em> 的实体类，它们重写了抽象类的方法</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316151254.png" alt="image-20210316151254751"></p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 模版方法模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/16 15:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//模板</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化游戏</span></span><br><span class="line">        initialize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始游戏</span></span><br><span class="line">        startPlay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结束游戏</span></span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="具体子类"><a href="#具体子类" class="headerlink" title="具体子类"></a>具体子类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 模版方法模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/16 15:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span>  <span class="keyword">extends</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Initialized! Start playing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Started. Enjoy the game!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 模版方法模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/16 15:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Initialized! Start playing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Started. Enjoy the game!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 模版方法模式;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/16 15:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game game = <span class="keyword">new</span> Cricket();</span><br><span class="line">        game.play();</span><br><span class="line">        Game game2 = <span class="keyword">new</span> Football();</span><br><span class="line">          game2.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316151812.png" alt="image-20210316151812573"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/posts/df879792/</url>
    <content><![CDATA[<h2 id="组合模式的定义与特点"><a href="#组合模式的定义与特点" class="headerlink" title="组合模式的定义与特点"></a>组合模式的定义与特点</h2><p>组合（Composite Pattern）模式的定义：有时又叫作整体-部分（Part-Whole）模式，它是一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，顶层的节点被称为根节点，根节点下面可以包含树枝节点和叶子节点，树枝节点下面又可以包含树枝节点和叶子节点，树形结构图如下。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316145847.png" alt="image-20210316145847712"></p>
<p>由上图可以看出，<font color=red>其实根节点和树枝节点本质上属于同一种数据类型，可以作为容器使用；而叶子节点与树枝节点在语义上不属于用一种类型。但是在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型（用统一接口定义），让它们具备一致行为。</font></p>
<p>这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利。</p>
<h2 id="组合模式的优缺点"><a href="#组合模式的优缺点" class="headerlink" title="组合模式的优缺点"></a>组合模式的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>不容易限制容器中的构件</li>
<li>不容易用继承的方法来增加构件的新功能；</li>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
</ol>
<h2 id="组合模式的结构与实现"><a href="#组合模式的结构与实现" class="headerlink" title="组合模式的结构与实现"></a>组合模式的结构与实现</h2><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><p>组合模式包含以下主要角色。</p>
<ol>
<li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。（总的抽象类或接口，定义一些通用的方法，比如新增、删除）</li>
<li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件。</li>
<li>树枝构件（Composite）角色 / 中间构件：是组合中的分支节点对象，它有子节点，用于继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>一个类 <em>Employee</em>，该类被当作组合模型类。<em>CompositePatternDemo</em> 类使用 <em>Employee</em> 类来添加部门层次结构，并打印所有员工。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316150302.png" alt="image-20210316150302711"></p>
<p>创建 <em>Employee</em> 类，该类带有 <em>Employee</em> 对象的列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 组合模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String dept;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; subordinates;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,String dept, <span class="keyword">int</span> sal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.dept = dept;</span><br><span class="line">        <span class="keyword">this</span>.salary = sal;</span><br><span class="line">        subordinates = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">        subordinates.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">        subordinates.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getSubordinates</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subordinates;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;Employee :[ Name : &quot;</span>+ name</span><br><span class="line">                +<span class="string">&quot;, dept : &quot;</span>+ dept + <span class="string">&quot;, salary :&quot;</span></span><br><span class="line">                + salary+<span class="string">&quot; ]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 组合模式;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee CEO = <span class="keyword">new</span> Employee(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;CEO&quot;</span>, <span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">        Employee headSales = <span class="keyword">new</span> Employee(<span class="string">&quot;Robert&quot;</span>,<span class="string">&quot;Head Sales&quot;</span>, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">        Employee headMarketing = <span class="keyword">new</span> Employee(<span class="string">&quot;Michel&quot;</span>,<span class="string">&quot;Head Marketing&quot;</span>, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">        Employee clerk1 = <span class="keyword">new</span> Employee(<span class="string">&quot;Laura&quot;</span>,<span class="string">&quot;Marketing&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        Employee clerk2 = <span class="keyword">new</span> Employee(<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Marketing&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        Employee salesExecutive1 = <span class="keyword">new</span> Employee(<span class="string">&quot;Richard&quot;</span>,<span class="string">&quot;Sales&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        Employee salesExecutive2 = <span class="keyword">new</span> Employee(<span class="string">&quot;Rob&quot;</span>,<span class="string">&quot;Sales&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        CEO.add(headSales);</span><br><span class="line">        CEO.add(headMarketing);</span><br><span class="line"></span><br><span class="line">        headSales.add(salesExecutive1);</span><br><span class="line">        headSales.add(salesExecutive2);</span><br><span class="line"></span><br><span class="line">        headMarketing.add(clerk1);</span><br><span class="line">        headMarketing.add(clerk2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印该组织的所有员工</span></span><br><span class="line">        System.out.println(CEO);</span><br><span class="line">        <span class="keyword">for</span> (Employee headEmployee : CEO.getSubordinates()) &#123;</span><br><span class="line">            System.out.println(headEmployee);</span><br><span class="line">            <span class="keyword">for</span> (Employee employee : headEmployee.getSubordinates()) &#123;</span><br><span class="line">                System.out.println(employee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316150735.png" alt="image-20210316150735908"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的事务</title>
    <url>/posts/d2eae622/</url>
    <content><![CDATA[<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309135338.jpg" alt="16a3e7b7a6894434"></p>
<h2 id="为什么要有事务"><a href="#为什么要有事务" class="headerlink" title="为什么要有事务"></a>为什么要有事务</h2><p><strong>数据库引入事务的主要目的是事务会把数据库会从一种一致状态转换到另一种一致状态，数据库提交工作时可以确保要么所有修改都保存，要么所有修改都不保存。</strong></p>
<h3 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h3><ul>
<li><strong>A(Atomicity) 原子性</strong></li>
<li><strong>C(Consistency) 一致性</strong></li>
<li><strong>I(Isolation) 隔离性</strong></li>
<li><strong>D(Durability) 持久性</strong></li>
</ul>
<h4 id="A-Atomicity-原子性"><a href="#A-Atomicity-原子性" class="headerlink" title="A(Atomicity) 原子性"></a>A(Atomicity) 原子性</h4><p>原子性是<strong>整个数据库事务是不可分割的工作单位</strong>，只有<font color=red>事务中的所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL执行失败，已经执行成功的SQL语句也必须撤销，回到执行事务的之前的状态</font>。</p>
<h4 id="C-Consistency-一致性"><a href="#C-Consistency-一致性" class="headerlink" title="C(Consistency) 一致性"></a>C(Consistency) 一致性</h4><p>一致性是指事务将数据库从一种一致性状态变为下一种一致性状态。<font  color=red>在事务开始之前和之后，数据库的完整性约束没有被破坏。</font></p>
<h4 id="I-Isolation-隔离性"><a href="#I-Isolation-隔离性" class="headerlink" title="I(Isolation) 隔离性"></a>I(Isolation) 隔离性</h4><p>隔离性要求<font color=red>每个读写事务对其他事务的操作对象能相互分离。</font></p>
<h4 id="D-Durability-持久性"><a href="#D-Durability-持久性" class="headerlink" title="D(Durability) 持久性"></a>D(Durability) 持久性</h4><p>持久性指<font color=red>事务一旦提交，其结果就是永久性的。</font></p>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>事务的实现就是如何实现ACID特性，下面一图下概况下：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309140003.png" alt="image-20210309140003622"></p>
<font color=red>事务的实现通过 redo_log 和 undo_log， 以及锁实现，锁实现事务的</font>

<font color=blue>redo_log 实现持久化和原子性，而undo_log实现一致性，二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</font>

<h3 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log 重做日志"></a>redo log 重做日志</h3><p><strong>redo_log 重做日志上面已经提到实现持久化和原子性</strong>，重做日志由两部分组成，<font color=red>一是内存中的重做日志缓存(redo log buffer)，这部分是容易丢失的。二是重做日志文件(redo log file)，这部分是持久的</font></p>
<h4 id="redo-log更新流程"><a href="#redo-log更新流程" class="headerlink" title="redo log更新流程"></a>redo log更新流程</h4><p>redo log的更新流程如下图，以一次Update 操作为例。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309140424.png" alt="image-20210309140424737"></p>
<ol>
<li>执行update操作。</li>
<li>先将原始数据从磁盘读取到内存，修改内存中的数据。</li>
<li>生成一条重做日志写入redo log buffer，记录数据被修改后的值。</li>
<li>当事务提交时，需要将redo log buffer中的内容刷新到redo log file。</li>
<li>事务提交后，也会将内存中修改数据的值写入磁盘。</li>
</ol>
<blockquote>
<p>为了确保每次日志都写入重做日志文件，<font color=red>InnoDB存储引擎会调用一次fsync操作。</font></p>
</blockquote>
<h4 id="存储格式内容"><a href="#存储格式内容" class="headerlink" title="存储格式内容"></a>存储格式内容</h4><h5 id="mysql的binlog与redo-log区别"><a href="#mysql的binlog与redo-log区别" class="headerlink" title="mysql的binlog与redo log区别"></a>mysql的binlog与redo log区别</h5><ol>
<li>首先2者都是记录数据的改变，不同的是，binlog是记录所有数据的改变信息，而innodb的redo log只是记录所有innodb表数据的变化。</li>
<li>binlog是记录已经提交完毕之后的dml以及ddl sql语句，而innodb  redo log是正在执行中的dml以及ddl语句</li>
<li>binlog可以作为恢复数据使用 ，redo log可以作为异常down机或者介质故障后的数据恢复使用</li>
<li>在db文件目录下，也分属于不同的日志文件中。</li>
</ol>
<h5 id="mysql的binlog与redo-log的写入方式"><a href="#mysql的binlog与redo-log的写入方式" class="headerlink" title="mysql的binlog与redo log的写入方式"></a>mysql的binlog与redo log的写入方式</h5><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309141112.png" alt="image-20210309141112695"></p>
<p>binlog是每次事务才写入，所以<strong>每个事务只会有一条日志，记录的逻辑日志，也可以说记录的就是SQL语句。</strong></p>
<p>redo log是事务开始就开始写入，<strong>*T1表示事务提交</strong>。<strong>记录的是物理格式日志</strong>，即每个页的修改。</p>
<p>redo log默认是以block(块)的方式为单位进行存储，每个块是512个字节。不同的数据库引擎有对应的重做日志格式，Innodb的存储管理是基于页的，所以其重做日志也是基于页的。</p>
<p>redo log格式:</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309141251.png" alt="image-20210309141251321"></p>
<ul>
<li>redo_log_type 重做日志类型</li>
<li>space 表空间的ID</li>
<li>page_no 页的偏移量</li>
<li>redo_log_body 存储内容</li>
</ul>
<p>执行一条插入语句，重做日志大致为:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">2</span>;</span><br><span class="line">           <span class="operator">|</span></span><br><span class="line">page(<span class="number">2</span>,<span class="number">3</span>), <span class="keyword">offset</span> <span class="number">32</span>, <span class="keyword">value</span> <span class="number">1</span>,<span class="number">2</span> # 主键索引</span><br><span class="line">page(<span class="number">2</span>,<span class="number">4</span>), <span class="keyword">offset</span> <span class="number">64</span>, <span class="keyword">value</span> <span class="number">2</span>   # 辅助索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="恢复机制"><a href="#恢复机制" class="headerlink" title="恢复机制"></a>恢复机制</h4><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309141428.png" alt="image-20210309141428811"></p>
<p><strong>LSN(Log Sequence Number) 日志序列号</strong>，Innodb里，LSN占8个字节，且是单调递增的，<strong>代表的含义</strong>有: 重做日志写入的总量、checkpoint的位置、页的版本。</p>
<p>假设在LSN=10000的时候数据库出现故障，磁盘中checkpoint为10000，表示磁盘已经刷新到10000这个序列号，当前redolog的checkpoint是13000，则需要恢复10000-13000的数据。</p>
<h4 id="redo-log为什么可以实现事务的原子性和持久性。"><a href="#redo-log为什么可以实现事务的原子性和持久性。" class="headerlink" title="redo log为什么可以实现事务的原子性和持久性。"></a>redo log为什么可以实现事务的原子性和持久性。</h4><ul>
<li>原子性，是redo log记录了事务期间操作的物理日志，事务提交之前，并没有写入磁盘，保存在内存里，如果事务失败，数据库磁盘不会有影响，回滚掉事务内存部分即可。</li>
<li>持久性，redo log 会在事务提交时将日志存储到磁盘redo log file，保证日志的持久性。</li>
</ul>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>redo log一旦提交意味着持久化了，但是有时候需要对其进行rollback操作，那就需要undo log。</p>
<p>undo log是逻辑日志，只是将数据库逻辑的恢复到原来的样子。并不能将数据库物理地恢复到执行语句或者事务之前的样子。虽然所有的逻辑修改均被取消了，但是数据结构和页本身在回滚前后可能不一样了。</p>
<p>既然是逻辑日志，可以<font color=red>理解为它存储的是SQL, 在事务中使用的每一条 INSERT 都对应了一条 DELETE，每一条 UPDATE 也都对应一条相反的 UPDATE 语句。</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309141731.png" alt="image-20210309141731783"></p>
<ul>
<li><p>undo log 存放在数据库内部的一个特殊段(segment)中，也叫undo段，存在于共享表空间中。</p>
</li>
<li><p>undo log实现了事务的一致性，可以通过undo log恢复到事务之前的逻辑状态，保证一致性。</p>
</li>
<li>undo log 还可以实现MVCC（Multi-Version Concurrency Control ，多版本并发控制），<font color=red>多版本并发控制其实可以通过 undo log 形成一个事务执行过程中的版本链，每一个写操作会产生一个版本，数据库发生读的并发访问时，读操作访问版本链，返回最合适的结果直接返回</font>。从而读写操作之间没有冲突，提高了性能。</li>
</ul>
<h2 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309143119.png" alt="image-20210309143119908"></p>
<blockquote>
<p>set transaction 修改事务隔离级别，比如修改会话级别的事务:</p>
<p><strong>set session transaction isolation level read committed;</strong></p>
</blockquote>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309143218.png" alt="image-20210309143218209"></p>
<p>四种隔离级别，按READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE顺序，隔离级别是从低到高<strong>，InnoDB默认是REPEATABLE-READ级别，此级别在其余数据库中是会引起幻读问题，InnoDB采用Next-Key Lock锁算法避免了此问题</strong></p>
<h3 id="READ-UNCOMMITTED"><a href="#READ-UNCOMMITTED" class="headerlink" title="READ-UNCOMMITTED"></a>READ-UNCOMMITTED</h3><p>READ-UNCOMMITTED 中文叫<strong>未提交读</strong>，即一个事务读到了另一个未提交事务修改过的数据，整个过程如下图:</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309143631.png" alt="image-20210309143630946"></p>
<font color=red>SessionA和SessionB分别开启一个事务，SessionB中的事务先将id为1的记录的name列更新为'lisi'，然后Session 中的事务再去查询这条id为1的记录，那么在未提交读的隔离级别下，查询结果由'zhangsan'变成了'lisi'，也就是说某个事务读到了另一个未提交事务修改过的记录。但是如果SessionB中的事务稍后进行了回滚，那么SessionA中的事务相当于读到了一个不存在的数据，这种现象也称为脏读。</font>可见READ-UNCOMMITTED是非常不安全

### READ COMMITTED

READ COMMITTED 中文叫**已提交读，或者叫不可重复读**。<font color=red>即一个事务能读到另一个已经提交事务修改后的数据，如果其他事务均对该数据进行修改并提交，该事务也能查询到最新值。</font>

<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309143845.png" alt="image-20210309143845407"></p>
<p><font color=red>SessionB 修改后，如果未提交，SessionA是读不到，但SessionB一旦提交后，SessionA即可读到SessionB修改的内容。</font>不可重复读是违反事务的隔离性的。</p>
<h3 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h3><p>REPEATABLE READ 中文叫可重复读，<font color=red>即事务能读到另一个已经提交的事务修改过的数据，但是第一次读过某条记录后，即使后面其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据。</font>如下图:</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309144051.png" alt="image-20210309144051799"></p>
<p>InnoDB默认是这种隔离级别，SessionB无论怎么修改id=1的值，SessionA读到依然是自己开启事务第一次读到的内容。</p>
<h3 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a>SERIALIZABLE</h3><p>SERIALIZABLE 叫串行化， 上面三种隔离级别可以进行 读-读 或者 读-写、写-读三种并发操作，而<font color=red>SERIALIZABLE不允许读-写，写-读的并发操作</font>。 如下图:</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309144203.png" alt="image-20210309144203252"></p>
<p>SessionB 对 id=1 进行修改的时候，SessionA 读取id=1则需要等待 SessionB 提交事务。可以理解SessionB在更新的时候加了锁。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>分布式事务指<strong>允许多个独立的事务资源参与到一个全局的事务中。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚。</strong></p>
<h3 id="InnoDB-分布式事务"><a href="#InnoDB-分布式事务" class="headerlink" title="InnoDB 分布式事务"></a>InnoDB 分布式事务</h3><p>InnoDB 是支持分布式事务，由一个或多个资源管理器（Resource Managers），一个事务管理器(Transaction Manager)，以及一个应用程序(Application Program)组成。</p>
<ul>
<li>资源管理器（Resource Managers），提供访问事务资源的方法，一般一个数据库就是一个资源管理器。</li>
<li>事务管理器(Transaction Manager)，协调参与全局事务中的各个事务，需要和参与全局事务的所有资源管理器进行通信。</li>
<li>应用程序(Application Program) 定义事务的边界，指定全局事务中的操作。</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309144336.png" alt="image-20210309144336352"></p>
<p>应用程序向一个或多个数据库执行事务操作，<strong>事务管理器进行管理事务，通过二段式提交，第一阶段所有参与的全局事务的节点都开始准备，告诉事务管理器都准备好了，可以提交了。第二阶段，事务管理器告诉每一个资源管理器是执行Commit 还是 Rollback。如果任何一个节点显示不能提交，则所有的节点被告知需要回滚</strong>。</p>
<h3 id="TCC分布式事务"><a href="#TCC分布式事务" class="headerlink" title="TCC分布式事务"></a>TCC分布式事务</h3><p><strong>InnoDB的分布式是数据库实现的, 数据库外常见的分布式事务是TCC分布式事务</strong></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309144458.png" alt="image-20210309144458126"></p>
<p>上图描述了TCC分布式事务的流程，假设电商业务中，支付后需要修改库存，积分，物流仓储的数据，如果一个失败则全部回滚。</p>
<p>TCC分布式事务，有三个阶段，Try，Confirm, Cancel。也就是说每个参与事务的服务都需要实现这三个接口，库存、积分、仓储都需要实现这三个接口。</p>
<p>第一阶段，Try，业务应用调取各个服务的Try接口，告诉他们给我预留一个商品，有人要购买，可以理解为冻结，每一步都不执行成功，只是标记更新状态。</p>
<p>第二阶段，Confirm，确认阶段，即事务协调器调取每个服务Confirm执行事务操作，如果某一个服务的Confirm失败，则有第三个阶段。如果成功则结束事务。</p>
<p>第三个阶段，Cancel，如果在第二个阶段有一个事务提交失败，则事务协调器调取所有业务的Cancel接口，回滚事务，将第一阶段冻结的商品恢复。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的优化</title>
    <url>/posts/f1e1e97a/</url>
    <content><![CDATA[<p><a href="https://dev.mysql.com/doc/refman/8.0/en/optimization.html">MySQL优化官网参考</a></p>
<h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2><ul>
<li>设计数据库时：数据库表、字段的设计，存储引擎</li>
<li>利用好MySQL自身提供的功能，如索引等</li>
<li>横向扩展：MySQL集群、负载均衡、读写分离</li>
<li>SQL语句的优化（收效甚微）</li>
</ul>
<h2 id="字段设计"><a href="#字段设计" class="headerlink" title="字段设计"></a>字段设计</h2><blockquote>
<p>字段类型的选择，设计规范，范式，常见设计案例</p>
</blockquote>
<h3 id="存储IP地址"><a href="#存储IP地址" class="headerlink" title="存储IP地址"></a>存储IP地址</h3><p><strong>常规做法</strong>： varchar（15）</p>
<p><strong>优化选择</strong>：int unsigned，占用4个字节，节省空间，IP运算速度块</p>
<blockquote>
<p>inet_aton；</p>
<p>inet_ntoa;</p>
<p>a—address,n——number</p>
</blockquote>
<h3 id="尽量使用整数去表示字符串"><a href="#尽量使用整数去表示字符串" class="headerlink" title="尽量使用整数去表示字符串"></a>尽量使用整数去表示字符串</h3><p><strong>整型的优势</strong>：存储空间固定。往往是少量空间,运算速度块</p>
<blockquote>
<p>MySQL 内部的枚举（单选）类型和集合（多选）类型但是，<strong>实操的时候enum和set很少用</strong></p>
<p><strong>原因</strong>：维护成本高</p>
<p><strong>使用的替代方案</strong>：关联表</p>
</blockquote>
<h3 id="存储金额"><a href="#存储金额" class="headerlink" title="存储金额"></a>存储金额</h3><p><strong>金额，价格，统计数据的存储</strong>：对数据的精度要求高,</p>
<p><strong>优化选择</strong>：</p>
<ol>
<li><p><strong>price decimal（8，2）</strong>；定点数，有两位小数的定点数。</p>
</li>
<li><p>price int ，bigint，整数，小单位—&gt;大数额，如<strong>9.01   在数据库中存储2为901，在程序中进行相关处理</strong></p>
<blockquote>
<p>注意：定点数，支持很大的数，</p>
<p>转成小单位后，整数存储不了！</p>
</blockquote>
</li>
</ol>
<h3 id="定长数据类型和变长数据类型的选择"><a href="#定长数据类型和变长数据类型的选择" class="headerlink" title="定长数据类型和变长数据类型的选择"></a>定长数据类型和变长数据类型的选择</h3><p><strong>定点数和浮点数的选择</strong></p>
<p><strong>定点数</strong>：不会精度丢失。 占用空间随者数字的增加而增加</p>
<p><strong>浮点数</strong>：导致精度丢失 。占用固定的存储空间，无论存储多大的数据，占用的空间是固定的（类似于int）</p>
<p><strong>定长类型</strong>：存储空间固定：int，float,double.char,date,time,datetime,year,timestamp</p>
<p><strong>变长类型</strong>：存储空间可变：varchar,decimal,text</p>
<h3 id="字符串类型的选择"><a href="#字符串类型的选择" class="headerlink" title="字符串类型的选择"></a>字符串类型的选择</h3><p><strong>使用varchar</strong></p>
<blockquote>
<p>char(10) 如果你存abc，需要空间为10，3个存abc，7个存空字符，因为char是固定长度</p>
<p>varchar(10)如果你存abc，需要空间为4，3个存abc，1个存长度，varchar是可变长度</p>
<p><strong>超过10的部分，都会被截断</strong></p>
</blockquote>
<p><strong>text,类型独立存储，不占用字段总空间</strong></p>
<h3 id="尽可能选择小的数据类型和指定短的长度"><a href="#尽可能选择小的数据类型和指定短的长度" class="headerlink" title="尽可能选择小的数据类型和指定短的长度"></a>尽可能选择小的数据类型和指定短的长度</h3><h3 id="尽可能使用-not-null"><a href="#尽可能使用-not-null" class="headerlink" title="尽可能使用 not null"></a>尽可能使用 not null</h3><p><strong>非<code>null</code>字段的处理要比<code>null</code>字段的处理高效些</strong>！且不需要判断是否为<code>null</code>。</p>
<p><code>null</code>在MySQL中，不好处理，<strong>存储需要额外空间，运算也需要特殊的运算符</strong>。如<code>select null = null</code>和<code>select null &lt;&gt; null</code>（<code>&lt;&gt;</code>为不等号）有着同样的结果，只能通过<code>is null</code>和<code>is not null</code>来判断字段是否为<code>null</code>。</p>
<blockquote>
<p>MySQL中每条记录都需要额外的存储空间，表示每个字段是否为<code>null</code>。因此通常使用特殊的数据进行占位，比如<code>int not null default 0</code>、<code>string not null default ‘’</code></p>
</blockquote>
<h3 id="字段注释要完整，见名知意"><a href="#字段注释要完整，见名知意" class="headerlink" title="字段注释要完整，见名知意"></a>字段注释要完整，见名知意</h3><h3 id="单表字段不宜过多"><a href="#单表字段不宜过多" class="headerlink" title="单表字段不宜过多"></a>单表字段不宜过多</h3><blockquote>
<p>当单表字段字段过多，可以考虑拆成多张表，将小长度的字段放在一张表，其余的放在其他表中</p>
</blockquote>
<h3 id="可以预留字段"><a href="#可以预留字段" class="headerlink" title="可以预留字段"></a>可以预留字段</h3><blockquote>
<p>优先满足业务，可以预留一些字段</p>
</blockquote>
<h2 id="关联表的设计"><a href="#关联表的设计" class="headerlink" title="关联表的设计"></a>关联表的设计</h2><blockquote>
<p>外键<code>foreign key</code>只能实现一对一或一对多的映射</p>
</blockquote>
<h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><blockquote>
<p>使用外键</p>
</blockquote>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><blockquote>
<p>使用中间表存储两表之间的关联关系</p>
</blockquote>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><blockquote>
<p>如商品的基本信息（<code>item</code>）和商品的详细信息（<code>item_intro</code>），通常使用相同的主键或者增加一个外键字段（<code>item_id</code>）</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote>
<p>关键字与数据的映射关系称为索引（==包含关键字和对应的记录在磁盘中的地址==）。关键字是从数据当中提取的用于标识、检索数据的特定内容。</p>
</blockquote>
<h3 id="索引检索为什么快"><a href="#索引检索为什么快" class="headerlink" title="索引检索为什么快"></a>索引检索为什么快</h3><ol>
<li><p>关键字相对于数据本身，==数据量小==</p>
</li>
<li><p>关键字是==有序==的，二分查找可快速确定位置</p>
<blockquote>
<p>图书馆为每本书都加了索引号（类别-楼层-书架）、字典为词语解释按字母顺序编写目录等都用到了索引。</p>
</blockquote>
</li>
</ol>
<h3 id="MySQL中索引类型"><a href="#MySQL中索引类型" class="headerlink" title="MySQL中索引类型"></a>MySQL中索引类型</h3><ol>
<li><strong>普通索引</strong>（<code>key</code>）</li>
<li><strong>唯一索引</strong>（<code>unique key</code>）</li>
<li><strong>主键索引</strong>（<code>primary key</code>）</li>
<li><strong>全文索引</strong>（<code>fulltext key</code>）</li>
</ol>
<h4 id="索引的关键字有不同的限制："><a href="#索引的关键字有不同的限制：" class="headerlink" title="索引的关键字有不同的限制："></a>索引的关键字有不同的限制：</h4><ul>
<li><strong>普通索引：</strong>对关键字没有限制</li>
<li><strong>唯一索引：</strong>要求记录提供的关键字不能重复</li>
<li><strong>主键索引：</strong>要求关键字唯一且不为null</li>
</ul>
<h3 id="索引管理语法"><a href="#索引管理语法" class="headerlink" title="索引管理语法"></a>索引管理语法</h3><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看建表语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">CREATE</span> <span class="keyword">table</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="comment">--查看表中字段</span></span><br><span class="line"><span class="keyword">desc</span> 表名;</span><br><span class="line"><span class="keyword">desc</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="comment">--查看表中所有索引</span></span><br><span class="line"><span class="keyword">SHOW</span> index <span class="keyword">FROM</span> `表名`</span><br><span class="line"><span class="keyword">SHOW</span> keys <span class="keyword">FROM</span> `表名`;</span><br><span class="line"><span class="keyword">SHOW</span> index <span class="keyword">FROM</span> `user_index`;</span><br><span class="line"><span class="keyword">SHOW</span> keys <span class="keyword">FROM</span> `user_index`;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210312094403.png" alt="image-20210312094403347"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210312094416.png" alt="image-20210312094416711"></p>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><h5 id="创建表之后建立索引"><a href="#创建表之后建立索引" class="headerlink" title="创建表之后建立索引"></a>创建表之后建立索引</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> user_index(</span><br><span class="line">	id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">	first_name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">	last_name <span class="type">VARCHAR</span>(<span class="number">16</span>),</span><br><span class="line">	id_card <span class="type">VARCHAR</span>(<span class="number">18</span>),</span><br><span class="line">	information text</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个first_name和last_name的复合索引，并命名为name</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">add</span> key name (first_name,last_name),</span><br><span class="line"><span class="comment">-- 创建一个id_card的唯一索引，默认以字段名作为索引名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">add</span> <span class="keyword">UNIQUE</span> KEY (id_card),</span><br><span class="line"><span class="comment">-- 鸡肋，全文索引不支持中文</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">add</span> FULLTEXT KEY (information);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="创建表时指定索引"><a href="#创建表时指定索引" class="headerlink" title="创建表时指定索引"></a>创建表时指定索引</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_index2 (</span><br><span class="line">	id <span class="type">INT</span> auto_increment <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	first_name <span class="type">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">	last_name <span class="type">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">	id_card <span class="type">VARCHAR</span> (<span class="number">18</span>),</span><br><span class="line">	information text,</span><br><span class="line">	KEY name (first_name, last_name),</span><br><span class="line">	FULLTEXT KEY (information),</span><br><span class="line">	<span class="keyword">UNIQUE</span> KEY (id_card)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><h5 id="删除普通索引、唯一索引、全文索引"><a href="#删除普通索引、唯一索引、全文索引" class="headerlink" title="删除普通索引、唯一索引、全文索引"></a>删除普通索引、唯一索引、全文索引</h5><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-----删除普通索引、唯一索引、全文索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> KEY 索引名</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY name;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY id_card;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY information;</span><br></pre></td></tr></table></figure>
<h5 id="删除主键索引"><a href="#删除主键索引" class="headerlink" title="删除主键索引"></a>删除主键索引</h5><p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">---删除主键索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">primary</span> key</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">primary</span> key</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210312100733.png" alt="image-20210312100733734"></p>
<p><strong>需要取消自增长</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--取消主键自增</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `表名` MODIFY <span class="keyword">COLUMN</span> 字段名 字段类型（长度） <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">FIRST</span> ;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `user_index` MODIFY <span class="keyword">COLUMN</span> id <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">FIRST</span> ;</span><br><span class="line"><span class="comment">---删除主键索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">primary</span> key</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">primary</span> key</span><br></pre></td></tr></table></figure>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ol>
<li><p><strong>like 以%开头</strong>，索引无效；<strong>当like前缀没有%，后缀有%时，索引有效</strong>。</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104045.png" alt="image-20210312104045534"></p>
</li>
<li><p><strong>or语句前后没有同时使用索引</strong>。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104107.png" alt="image-20210312104107314"></p>
</li>
<li><p><strong>组合索引，不是使用第一列索引</strong>，索引失效。</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104314.png" alt="image-20210312104314829"></p>
</li>
<li><p><strong>数据类型出现隐式转化</strong>。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104329.png" alt="image-20210312104329349"></p>
</li>
<li><p><strong><font color=red>在索引列上使用 IS NULL 或 IS NOT NULL操作，索引不一定失效，可能在某些情况会失效</font></strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104455.png" alt="image-20210312104455798"></p>
<p> 此处我将重新创建一个emp表（<strong>此处索引为InnoDB类型索引</strong>）</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104819.png" alt="image-20210312104819712"></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312104905.png" alt="image-20210312104905292"></p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">----创建新索引</span></span><br><span class="line"><span class="keyword">create</span> index test2 <span class="keyword">on</span> emp(name)</span><br></pre></td></tr></table></figure>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312105105.png" alt="image-20210312105105179"></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210312105210.png" alt="image-20210312105210686"></p>
</li>
</ol>
<ol>
<li><p><strong>在索引字段上使用not，&lt;&gt;，!=</strong>。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。</p>
</li>
<li><p><strong>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。</strong></p>
</li>
<li><p><strong>不要在字段中做运算</strong></p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">----下面两条SQL语句在语义上相同，(id为主键)但是第一条会使用主键索引而第二条不会。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">20</span><span class="number">-1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">+</span><span class="number">1</span> <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a>索引使用场景（重点）</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>根据<code>id</code>查询记录，因为<code>id</code>字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增加一个没有建立索引的字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> innodb1 <span class="keyword">add</span> sex <span class="type">char</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 按sex检索时可选的索引为null</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> innodb1 <span class="keyword">where</span> sex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210312103826.png" alt="image-20210312103826193"></p>
<blockquote>
<p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（<code>alter table 表名 add index(字段名)</code>），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p>
</blockquote>
<h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><ul>
<li><p><strong>该字段没有建立索引</strong></p>
<p>  将<strong>查询出的所有数据使用外部排序</strong>（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果）</p>
</li>
<li><p><strong>该字段建立索引</strong></p>
<p>  直接<strong>按照索引的顺序和映射关系逐条取出数据</strong>。而且如果分页的，那么只用<strong>取出索引表某个范围内的索引对应的数据</strong></p>
</li>
</ul>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><blockquote>
<p>对<code>join</code>语句匹配关系（<code>on</code>）涉及的字段建立索引能够提高效率</p>
</blockquote>
<h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在<code>select</code>后==只写必要的查询字段==，以增加索引覆盖的几率。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化分析思路</title>
    <url>/posts/d1898e04/</url>
    <content><![CDATA[<h2 id="调优原则"><a href="#调优原则" class="headerlink" title="调优原则"></a>调优原则</h2><p>  在性能优化时，我们必须遵循一定的原则，否则，有可能得不到正确的调优结果。主要有以下几个方面：</p>
<ul>
<li>对性能进行分析时，要多方面分析系统的资源瓶颈所在，因为系统某一方面性能低，也许并不是它自己造成的，而是其他方面造成的。如CPU利用率是100%时，很可能是内存容量太小，因为CPU忙于处理内存调度。</li>
<li>一次只对影响性能的某方面的一个参数进行调整，多个参数同时调整的话，很难界定性能的影响是由哪个参数造成的。</li>
<li>由于在进行系统性能分析时，性能分析工具本身会占用一定的系统资源，如CPU资源、内存资源等等。我们必须注意到这点，即分析工具本身运行可能会导致系统某方面的资源瓶颈情况更加严重。</li>
<li>必须保证调优后的程序运行正确。</li>
<li>调优过程是迭代渐进的过程，每一次调优的结果都要反馈到后续的代码开发中去。</li>
<li>性能调优不能以牺牲代码的可读性和可维护性为代价。</li>
</ul>
<h2 id="调优分析思路"><a href="#调优分析思路" class="headerlink" title="调优分析思路"></a>调优分析思路</h2><ol>
<li>很多情况下压测流量并没有完全进入到服务端，在网络上可能就会出现由于各种规格（带宽、最大连接数、新建连接数等）限制，导致压测结果达不到预期。</li>
<li>看关键指标是否满足要求，如果不满足，需要确定是哪个地方有问题，一般情况下，服务器端问题可能性比较大，也有可能是客户端问题（这种情况比较小）。</li>
<li>对于服务器端问题，需要定位的是硬件相关指标，例如CPU，Memory，Disk I/O，Network I/O，如果是某个硬件指标有问题，需要深入的进行分析。</li>
<li>如果硬件指标都没有问题，需要查看数据库相关指标，例如：等待事件、内存命中率等。</li>
<li>如果以上指标都正常，应用程序的算法、缓冲、缓存、同步或异步可能有问题，需要具体深入的分析。</li>
</ol>
<h3 id="可能的瓶颈点"><a href="#可能的瓶颈点" class="headerlink" title="可能的瓶颈点"></a>可能的瓶颈点</h3><div class="table-container">
<table>
<thead>
<tr>
<th>瓶颈点</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>硬件/规格</td>
<td style="text-align:center">一般指的是CPU、内存、磁盘I/O方面的问题，分为服务器硬件瓶颈、网络瓶颈（对局域网可以不考虑）。</td>
</tr>
<tr>
<td>操作系统</td>
<td style="text-align:center">一般指的是windows、UNIX、Linux等操作系统。<br>例如，在进行性能测试出现物理内存不足时，虚拟内存设置也不合理，虚拟内存的交换效率就会大大降低，<br>从而导致行为的响应时间大大增加，这时认为操作系统上出现性能瓶颈。</td>
</tr>
<tr>
<td>数据库</td>
<td style="text-align:center">一般指的是数据库配置等方面的问题。<br>例如，由于参数配置不合理，导致数据库处理速度慢的问题，可认为是数据库层面的的问题。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="MySQL数据库优化"><a href="#MySQL数据库优化" class="headerlink" title="MySQL数据库优化"></a>MySQL数据库优化</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309171911.png" alt="image-20210309171911716"></p>
<h3 id="连接——配置优化"><a href="#连接——配置优化" class="headerlink" title="连接——配置优化"></a>连接——配置优化</h3><p>客户端连接到服务端可能出现的问题：  服务端连接数不够导致应用程序获取不到连接</p>
<p>可以从两个方面来解决连接数不够的问题：</p>
<ol>
<li><p><strong>从服务端来说，我们可以增加服务端的可用连接数</strong>。</p>
<p> 如果有多个应用或者很多请求同时访问数据库，连接数不够的时候，我们可以：</p>
<ul>
<li><p>修改配置参数增加可用连接数，修改 max_connections 的大小</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>; <span class="comment">-- 修改最大连接数，当有多个应用连接的时候</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>及时释放不活动的连接。交互式和非交互式的客户端的默认超时时 间都是 28800 秒，8 小时，我们可以把这个值调小</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>; <span class="comment">--及时释放不活动的连接，注意不要释放连接池还在使用的连接</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>从客户端来说，可以减少从服务端获取的连接数，如果我们想要不是每一次执行 SQL 都创建一个新的连接，可以引入连接池，实现连接的重用</strong>。</p>
</li>
</ol>
<h3 id="缓存——架构优化"><a href="#缓存——架构优化" class="headerlink" title="缓存——架构优化"></a>缓存——架构优化</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>在应用系统的并发数非常大的情况下，如果没有缓存，会造成两个问题：</p>
<ol>
<li>会给数据库带来很大的压力。</li>
<li>从应用的层面来说，操作数据的速度也会受到 影响。</li>
</ol>
<p><strong>解决方案</strong>：</p>
<p>用第三方的缓存服务来解决这个问题，例如 Redis。</p>
<h4 id="集群，主从复制"><a href="#集群，主从复制" class="headerlink" title="集群，主从复制"></a>集群，主从复制</h4><p>如果单台数据库服务满足不了访问需求，那我们可以做数据库的集群方案</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309172434.png" alt="image-20210309172434821"></p>
<p>做了<strong>主从复制的方案之后，我们只把数据写入 master 节点，而读的请求可以分担到 slave 节点。我们把这种方案叫做读写分离</strong>。</p>
<p><strong>读写分离可以一定程度低减轻数据库服务器的访问压力，但是需要特别注意主从数 据一致性的问题。</strong></p>
<h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p><strong>垂直分库，减少并发压力。水平分表，解决存储瓶颈</strong></p>
<p>垂直分库的做法，<strong>把一个数据库按照业务拆分成不同的数据库</strong>：</p>
<p>水平分库分表的做法，<strong>把单张表的数据按照一定的规则分布到多个数据库</strong>。</p>
<h3 id="优化器——SQL-语句分析与优化"><a href="#优化器——SQL-语句分析与优化" class="headerlink" title="优化器——SQL 语句分析与优化"></a>优化器——SQL 语句分析与优化</h3><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html">慢查询日志</a></p>
<h5 id="打开慢日志开关"><a href="#打开慢日志开关" class="headerlink" title="打开慢日志开关"></a>打开慢日志开关</h5><p>因为开启慢查询日志是有代价的（跟 bin log、optimizer-trace 一样），所以它默 认是关闭的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>除了这个开关，还有一个参数，控制执行超过多长时间的 SQL 才记录到慢日志，默 认是 10 秒。如果改成 0 秒的话就是记录所有的 SQL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>可以直接动态修改参数（重启后失效）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@global</span>.slow_query_log<span class="operator">=</span><span class="number">1</span>; <span class="comment">-- 1 开启，0 关闭，重启后失效</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@global</span>.long_query_time<span class="operator">=</span><span class="number">3</span>; <span class="comment">-- mysql 默认的慢查询时间是 10 秒，另开一个窗口后才会查到最新值</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query%&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>修改配置文件 my.cnf。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slow_query_log = ON</span><br><span class="line">long_query_time=2</span><br><span class="line">slow_query_log_file =/var/lib/mysql/localhost-slow.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="慢日志分析"><a href="#慢日志分析" class="headerlink" title="慢日志分析"></a>慢日志分析</h5><h5 id="直接查看日志内容"><a href="#直接查看日志内容" class="headerlink" title="直接查看日志内容"></a>直接查看日志内容</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;slow_queries&#x27;</span>; <span class="comment">-- 查看有多少慢查询</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query%&#x27;</span>; <span class="comment">-- 获取慢日志目录</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/lib/mysql/ localhost-slow.log</span><br></pre></td></tr></table></figure>
<h5 id="使用mysqldumpslow工具"><a href="#使用mysqldumpslow工具" class="headerlink" title="使用mysqldumpslow工具"></a>使用mysqldumpslow工具</h5><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldumpslow.html"><strong>mysqldumpslow-</strong>汇总慢查询日志文件</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查询用时最多的 10 条慢 SQL</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g &#x27;select&#x27; /var/lib/mysql/localhost-slow.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309173926.png" alt="image-20210309173926526"></p>
<p>Count 代表这个 SQL 执行了多少次；</p>
<p>Time 代表执行的时间，括号里面是累计时间；</p>
<p>Lock 表示锁定的时间，括号是累计；</p>
<p>Rows 表示返回的记录数，括号是累计。</p>
<h4 id="SHOW-PROFILE"><a href="#SHOW-PROFILE" class="headerlink" title="SHOW PROFILE"></a>SHOW PROFILE</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/show-profile.html">SHOW PROFILE语句</a></p>
<h5 id="查看是否开启"><a href="#查看是否开启" class="headerlink" title="查看是否开启"></a>查看是否开启</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看profiling状态</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br><span class="line">#设置开启</span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@profiling</span><span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309174257.png" alt="image-20210309174257643"></p>
<h5 id="查看-profile-统计"><a href="#查看-profile-统计" class="headerlink" title="查看 profile 统计"></a>查看 profile 统计</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309174406.png" alt="image-20210309174406930"></p>
<h5 id="查询指定query-id详细信息"><a href="#查询指定query-id详细信息" class="headerlink" title="查询指定query_id详细信息"></a>查询指定query_id详细信息</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#不指定id，默认查最后一条</span><br><span class="line"><span class="keyword">show</span> profile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309174559.png" alt="image-20210309174559267"></p>
<h4 id="使用performance-schema"><a href="#使用performance-schema" class="headerlink" title="使用performance schema"></a>使用performance schema</h4><p><a href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema-system-variables.html">performance schema</a></p>
<p><strong>MySQL的performance schema 用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况</strong>。</p>
<h5 id="performance-schema"><a href="#performance-schema" class="headerlink" title="performance schema"></a>performance schema</h5><p>在mysql的5.7版本中，性能模式是默认开启的，如果想要显式的关闭的话需要修改配置文件，不能直接进行修改，会报错Variable ‘performance_schema’ is a read only variable。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看performance_schema的属性</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;performance_schema&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name      <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">--在配置文件中修改performance_schema的属性值，on表示开启，off表示关闭</span></span><br><span class="line">[mysqld]</span><br><span class="line">performance_schema<span class="operator">=</span><span class="keyword">ON</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--切换数据库</span></span><br><span class="line">use performance_schema;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看当前数据库下的所有表,会看到有很多表存储着相关的信息</span></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="comment">--可以通过show create table tablename来查看创建表的时候的表结构</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> setup_consumers;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+---------------------------------</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>           <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                    </span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+---------------------------------</span></span><br><span class="line"><span class="operator">|</span> setup_consumers <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `setup_consumers` (</span><br><span class="line">  `NAME` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                      </span><br><span class="line">  `ENABLED` enum(<span class="string">&#x27;YES&#x27;</span>,<span class="string">&#x27;NO&#x27;</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>               </span><br><span class="line">) ENGINE<span class="operator">=</span>PERFORMANCE_SCHEMA <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span>  </span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+---------------------------------</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)                             </span><br></pre></td></tr></table></figure>
<p>​    instruments: 生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项。</p>
<p>​        consumers:消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项。</p>
<h5 id="performance-schema表的分类"><a href="#performance-schema表的分类" class="headerlink" title="performance_schema表的分类"></a>performance_schema表的分类</h5><p>performance_schema库下的表可以按照监视不同的纬度就行分组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--语句事件记录表，这些表记录了语句事件信息，当前语句事件表events_statements_current、历史语句事件表events_statements_history和长语句历史事件表events_statements_history_long、以及聚合后的摘要表summary，其中，summary表还可以根据帐号(account)，主机(host)，程序(program)，线程(thread)，用户(user)和全局(global)再进行细分)</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%statement%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--等待事件记录表，与语句事件类型的相关记录表类似：</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%wait%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--阶段事件记录表，记录语句执行的阶段事件的表</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%stage%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务事件记录表，记录事务相关的事件的表</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%transaction%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--监控文件系统层调用的表</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%file%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--监视内存使用的表</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%memory%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--动态对performance_schema进行配置的配置表</span></span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;%setup%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h5 id="performance-schema的简单配置与使用"><a href="#performance-schema的简单配置与使用" class="headerlink" title="performance_schema的简单配置与使用"></a>performance_schema的简单配置与使用</h5><p>数据库刚刚初始化并启动时，并非所有instruments(事件采集项，在采集项的配置表中每一项都有一个开关字段，或为YES，或为NO)和consumers(与采集项类似，也有一个对应的事件类型保存表配置项，为YES就表示对应的表保存性能数据，为NO就表示对应的表不保存性能数据)都启用了，所以默认不会收集所有的事件，可能你需要检测的事件并没有打开，需要进行设置，可以使用如下两个语句打开对应的instruments和consumers（行计数可能会因MySQL版本而异)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--打开等待事件的采集器配置项开关，需要修改setup_instruments配置表中对应的采集器配置项</span></span><br><span class="line">UPDATE setup_instruments <span class="keyword">SET</span> ENABLED <span class="operator">=</span> <span class="string">&#x27;YES&#x27;</span>, TIMED <span class="operator">=</span> <span class="string">&#x27;YES&#x27;</span><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;wait%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--打开等待事件的保存表配置开关，修改setup_consumers配置表中对应的配置项</span></span><br><span class="line">UPDATE setup_consumers <span class="keyword">SET</span> ENABLED <span class="operator">=</span> <span class="string">&#x27;YES&#x27;</span><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%wait%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--当配置完成之后可以查看当前server正在做什么，可以通过查询events_waits_current表来得知，该表中每个线程只包含一行数据，用于显示每个线程的最新监视事件</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> events_waits_current\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">            THREAD_ID: <span class="number">11</span></span><br><span class="line">             EVENT_ID: <span class="number">570</span></span><br><span class="line">         END_EVENT_ID: <span class="number">570</span></span><br><span class="line">           EVENT_NAME: wait<span class="operator">/</span>synch<span class="operator">/</span>mutex<span class="operator">/</span>innodb<span class="operator">/</span>buf_dblwr_mutex</span><br><span class="line">               SOURCE: </span><br><span class="line">          TIMER_START: <span class="number">4508505105239280</span></span><br><span class="line">            TIMER_END: <span class="number">4508505105270160</span></span><br><span class="line">           TIMER_WAIT: <span class="number">30880</span></span><br><span class="line">                SPINS: <span class="keyword">NULL</span></span><br><span class="line">        OBJECT_SCHEMA: <span class="keyword">NULL</span></span><br><span class="line">          OBJECT_NAME: <span class="keyword">NULL</span></span><br><span class="line">           INDEX_NAME: <span class="keyword">NULL</span></span><br><span class="line">          OBJECT_TYPE: <span class="keyword">NULL</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">67918392</span></span><br><span class="line">     NESTING_EVENT_ID: <span class="keyword">NULL</span></span><br><span class="line">   NESTING_EVENT_TYPE: <span class="keyword">NULL</span></span><br><span class="line">            OPERATION: lock</span><br><span class="line">      NUMBER_OF_BYTES: <span class="keyword">NULL</span></span><br><span class="line">                FLAGS: <span class="keyword">NULL</span></span><br><span class="line"><span class="comment">/*该信息表示线程id为11的线程正在等待buf_dblwr_mutex锁，等待事件为30880</span></span><br><span class="line"><span class="comment">属性说明：</span></span><br><span class="line"><span class="comment">	id:事件来自哪个线程，事件编号是多少</span></span><br><span class="line"><span class="comment">	event_name:表示检测到的具体的内容</span></span><br><span class="line"><span class="comment">	source:表示这个检测代码在哪个源文件中以及行号</span></span><br><span class="line"><span class="comment">	timer_start:表示该事件的开始时间</span></span><br><span class="line"><span class="comment">	timer_end:表示该事件的结束时间</span></span><br><span class="line"><span class="comment">	timer_wait:表示该事件总的花费时间</span></span><br><span class="line"><span class="comment">注意：_current表中每个线程只保留一条记录，一旦线程完成工作，该表中不会再记录该线程的事件信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">_history表中记录每个线程应该执行完成的事件信息，但每个线程的事件信息只会记录10条，再多就会被覆盖，*_history_long表中记录所有线程的事件信息，但总记录数量是10000，超过就会被覆盖掉</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> thread_id,event_id,event_name,timer_wait <span class="keyword">from</span> events_waits_history <span class="keyword">order</span> <span class="keyword">by</span> thread_id limit <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">summary表提供所有事件的汇总信息，该组中的表以不同的方式汇总事件数据（如：按用户，按主机，按线程等等）。例如：要查看哪些instruments占用最多的时间，可以通过对events_waits_summary_global_by_event_name表的COUNT_STAR或SUM_TIMER_WAIT列进行查询（这两列是对事件的记录数执行COUNT（*）、事件记录的TIMER_WAIT列执行SUM（TIMER_WAIT）统计而来）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> EVENT_NAME,COUNT_STAR <span class="keyword">FROM</span> events_waits_summary_global_by_event_name  <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">instance表记录了哪些类型的对象会被检测。这些对象在被server使用时，在该表中将会产生一条事件记录，例如，file_instances表列出了文件I/O操作及其关联文件名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> file_instances limit <span class="number">20</span>; </span><br></pre></td></tr></table></figure>
<h5 id="常用配置项的参数说明"><a href="#常用配置项的参数说明" class="headerlink" title="常用配置项的参数说明"></a>常用配置项的参数说明</h5><h6 id="启动选项"><a href="#启动选项" class="headerlink" title="启动选项"></a>启动选项</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">performance_schema_consumer_events_statements_current<span class="operator">=</span><span class="literal">TRUE</span></span><br><span class="line">是否在mysql server启动时就开启events_statements_current表的记录功能(该表记录当前的语句事件信息)，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新setup_consumers配置表中的events_statements_current配置项，默认值为<span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">performance_schema_consumer_events_statements_history<span class="operator">=</span><span class="literal">TRUE</span></span><br><span class="line">与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件短历史信息，默认为<span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">performance_schema_consumer_events_stages_history_long<span class="operator">=</span><span class="literal">FALSE</span></span><br><span class="line">与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件长历史信息，默认为<span class="literal">FALSE</span></span><br><span class="line"></span><br><span class="line">除了statement(语句)事件之外，还支持：wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个启动项分别进行配置，但这些等待事件默认未启用，如果需要在MySQL Server启动时一同启动，则通常需要写进my.cnf配置文件中</span><br><span class="line">performance_schema_consumer_global_instrumentation<span class="operator">=</span><span class="literal">TRUE</span></span><br><span class="line">是否在MySQL Server启动时就开启全局表（如：mutex_instances、rwlock_instances、cond_instances、file_instances、users、hostsaccounts、socket_summary_by_event_name、file_summary_by_instance等大部分的全局对象计数统计和事件汇总统计信息表 ）的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新全局配置项</span><br><span class="line">默认值为<span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">performance_schema_consumer_statements_digest<span class="operator">=</span><span class="literal">TRUE</span></span><br><span class="line">是否在MySQL Server启动时就开启events_statements_summary_by_digest 表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新digest配置项</span><br><span class="line">默认值为<span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">performance_schema_consumer_thread_instrumentation<span class="operator">=</span><span class="literal">TRUE</span></span><br><span class="line">是否在MySQL Server启动时就开启</span><br><span class="line"></span><br><span class="line">events_xxx_summary_by_yyy_by_event_name表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新线程配置项</span><br><span class="line">默认值为<span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line">performance_schema_instrument[<span class="operator">=</span>name]</span><br><span class="line">是否在MySQL Server启动时就启用某些采集器，由于instruments配置项多达数千个，所以该配置项支持key<span class="operator">-</span><span class="keyword">value</span>模式，还支持<span class="operator">%</span>号进行通配等，如下:</span><br><span class="line"></span><br><span class="line"># [<span class="operator">=</span>name]可以指定为具体的Instruments名称（但是这样如果有多个需要指定的时候，就需要使用该选项多次），也可以使用通配符，可以指定instruments相同的前缀<span class="operator">+</span>通配符，也可以使用<span class="operator">%</span>代表所有的instruments</span><br><span class="line"></span><br><span class="line">## 指定开启单个instruments</span><br><span class="line"></span><br><span class="line"><span class="comment">--performance-schema-instrument= &#x27;instrument_name=value&#x27;</span></span><br><span class="line"></span><br><span class="line">## 使用通配符指定开启多个instruments</span><br><span class="line"></span><br><span class="line"><span class="comment">--performance-schema-instrument= &#x27;wait/synch/cond/%=COUNTED&#x27;</span></span><br><span class="line"></span><br><span class="line">## 开关所有的instruments</span><br><span class="line"></span><br><span class="line"><span class="comment">--performance-schema-instrument= &#x27;%=ON&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--performance-schema-instrument= &#x27;%=OFF&#x27;</span></span><br><span class="line"></span><br><span class="line">注意，这些启动选项要生效的前提是，需要设置performance_schema<span class="operator">=</span><span class="keyword">ON</span>。另外，这些启动选项虽然无法使用<span class="keyword">show</span> variables语句查看，但我们可以通过setup_instruments和setup_consumers表查询这些选项指定的值。</span><br></pre></td></tr></table></figure>
<h6 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%performance_schema%&#x27;</span>;</span><br><span class="line"><span class="comment">--重要的属性解释</span></span><br><span class="line">performance_schema<span class="operator">=</span><span class="keyword">ON</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制performance_schema功能的开关，要使用MySQL的performance_schema，需要在mysqld启动时启用，以启用事件收集功能</span></span><br><span class="line"><span class="comment">该参数在5.7.x之前支持performance_schema的版本中默认关闭，5.7.x版本开始默认开启</span></span><br><span class="line"><span class="comment">注意：如果mysqld在初始化performance_schema时发现无法分配任何相关的内部缓冲区，则performance_schema将自动禁用，并将performance_schema设置为OFF</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">performance_schema_digests_size<span class="operator">=</span><span class="number">10000</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制events_statements_summary_by_digest表中的最大行数。如果产生的语句摘要信息超过此最大值，便无法继续存入该表，此时performance_schema会增加状态变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">performance_schema_events_statements_history_long_size<span class="operator">=</span><span class="number">10000</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制events_statements_history_long表中的最大行数，该参数控制所有会话在events_statements_history_long表中能够存放的总事件记录数，超过这个限制之后，最早的记录将被覆盖</span></span><br><span class="line"><span class="comment">全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10000，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10000 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">performance_schema_events_statements_history_size<span class="operator">=</span><span class="number">10</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制events_statements_history表中单个线程（会话）的最大行数，该参数控制单个会话在events_statements_history表中能够存放的事件记录数，超过这个限制之后，单个会话最早的记录将被覆盖</span></span><br><span class="line"><span class="comment">全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10</span></span><br><span class="line"><span class="comment">除了statement(语句)事件之外，wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个参数分别进行存储限制配置，有兴趣的同学自行研究，这里不再赘述</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">performance_schema_max_digest_length<span class="operator">=</span><span class="number">1024</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用于控制标准化形式的SQL语句文本在存入performance_schema时的限制长度，该变量与max_digest_length变量相关(max_digest_length变量含义请自行查阅相关资料)</span></span><br><span class="line"><span class="comment">全局变量，只读变量，默认值1024字节，整型值，取值范围0~1048576</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">performance_schema_max_sql_text_length<span class="operator">=</span><span class="number">1024</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制存入events_statements_current，events_statements_history和events_statements_history_long语句事件表中的SQL_TEXT列的最大SQL长度字节数。 超出系统变量performance_schema_max_sql_text_length的部分将被丢弃，不会记录，一般情况下不需要调整该参数，除非被截断的部分与其他SQL比起来有很大差异</span></span><br><span class="line"><span class="comment">全局变量，只读变量，整型值，默认值为1024字节，取值范围为0~1048576，5.7.6版本引入</span></span><br><span class="line"><span class="comment">降低系统变量performance_schema_max_sql_text_length值可以减少内存使用，但如果汇总的SQL中，被截断部分有较大差异，会导致没有办法再对这些有较大差异的SQL进行区分。 增加该系统变量值会增加内存使用，但对于汇总SQL来讲可以更精准地区分不同的部分。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h6 id="重要配置表的相关说明"><a href="#重要配置表的相关说明" class="headerlink" title="重要配置表的相关说明"></a>重要配置表的相关说明</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">performance_timers表中记录了server中有哪些可用的事件计时器</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	timer_name:表示可用计时器名称，CYCLE是基于CPU周期计数器的定时器</span></span><br><span class="line"><span class="comment">	timer_frequency:表示每秒钟对应的计时器单位的数量,CYCLE计时器的换算值与CPU的频率相关、</span></span><br><span class="line"><span class="comment">	timer_resolution:计时器精度值，表示在每个计时器被调用时额外增加的值</span></span><br><span class="line"><span class="comment">	timer_overhead:表示在使用定时器获取事件时开销的最小周期值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_timers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">setup_timers表中记录当前使用的事件计时器信息</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	name:计时器类型，对应某个事件类别</span></span><br><span class="line"><span class="comment">	timer_name:计时器类型名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> setup_timers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">setup_consumers表中列出了consumers可配置列表项</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	NAME：consumers配置名称</span></span><br><span class="line"><span class="comment">	ENABLED：consumers是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> setup_consumers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">setup_instruments 表列出了instruments 列表配置项，即代表了哪些事件支持被收集：</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	NAME：instruments名称，instruments名称可能具有多个部分并形成层次结构</span></span><br><span class="line"><span class="comment">	ENABLED：instrumetns是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。如果设置为NO，则这个instruments不会被执行，不会产生任何的事件信息</span></span><br><span class="line"><span class="comment">	TIMED：instruments是否收集时间信息，有效值为YES或NO，此列可以使用UPDATE语句修改，如果设置为NO，则这个instruments不会收集时间信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> setup_instruments;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">setup_actors表的初始内容是匹配任何用户和主机，因此对于所有前台线程，默认情况下启用监视和历史事件收集功能</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	HOST：与grant语句类似的主机名，一个具体的字符串名字，或使用“％”表示“任何主机”</span></span><br><span class="line"><span class="comment">	USER：一个具体的字符串名称，或使用“％”表示“任何用户”</span></span><br><span class="line"><span class="comment">	ROLE：当前未使用，MySQL 8.0中才启用角色功能</span></span><br><span class="line"><span class="comment">	ENABLED：是否启用与HOST，USER，ROLE匹配的前台线程的监控功能，有效值为：YES或NO</span></span><br><span class="line"><span class="comment">	HISTORY：是否启用与HOST， USER，ROLE匹配的前台线程的历史事件记录功能，有效值为：YES或NO</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> setup_actors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">setup_objects表控制performance_schema是否监视特定对象。默认情况下，此表的最大行数为100行。</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	OBJECT_TYPE：instruments类型，有效值为：“EVENT”（事件调度器事件）、“FUNCTION”（存储函数）、“PROCEDURE”（存储过程）、“TABLE”（基表）、“TRIGGER”（触发器），TABLE对象类型的配置会影响表I/O事件（wait/io/table/sql/handler instrument）和表锁事件（wait/lock/table/sql/handler instrument）的收集</span></span><br><span class="line"><span class="comment">	OBJECT_SCHEMA：某个监视类型对象涵盖的数据库名称，一个字符串名称，或“％”(表示“任何数据库”)</span></span><br><span class="line"><span class="comment">	OBJECT_NAME：某个监视类型对象涵盖的表名，一个字符串名称，或“％”(表示“任何数据库内的对象”)</span></span><br><span class="line"><span class="comment">	ENABLED：是否开启对某个类型对象的监视功能，有效值为：YES或NO。此列可以修改</span></span><br><span class="line"><span class="comment">	TIMED：是否开启对某个类型对象的时间收集功能，有效值为：YES或NO，此列可以修改</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> setup_objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">threads表对于每个server线程生成一行包含线程相关的信息，</span></span><br><span class="line"><span class="comment">字段解释：</span></span><br><span class="line"><span class="comment">	THREAD_ID：线程的唯一标识符（ID）</span></span><br><span class="line"><span class="comment">	NAME：与server中的线程检测代码相关联的名称(注意，这里不是instruments名称)</span></span><br><span class="line"><span class="comment">	TYPE：线程类型，有效值为：FOREGROUND、BACKGROUND。分别表示前台线程和后台线程</span></span><br><span class="line"><span class="comment">	PROCESSLIST_ID：对应INFORMATION_SCHEMA.PROCESSLIST表中的ID列。</span></span><br><span class="line"><span class="comment">	PROCESSLIST_USER：与前台线程相关联的用户名，对于后台线程为NULL。</span></span><br><span class="line"><span class="comment">	PROCESSLIST_HOST：与前台线程关联的客户端的主机名，对于后台线程为NULL。</span></span><br><span class="line"><span class="comment">	PROCESSLIST_DB：线程的默认数据库，如果没有，则为NULL。</span></span><br><span class="line"><span class="comment">	PROCESSLIST_COMMAND：对于前台线程，该值代表着当前客户端正在执行的command类型，如果是sleep则表示当前会话处于空闲状态</span></span><br><span class="line"><span class="comment">	PROCESSLIST_TIME：当前线程已处于当前线程状态的持续时间（秒）</span></span><br><span class="line"><span class="comment">	PROCESSLIST_STATE：表示线程正在做什么事情。</span></span><br><span class="line"><span class="comment">	PROCESSLIST_INFO：线程正在执行的语句，如果没有执行任何语句，则为NULL。</span></span><br><span class="line"><span class="comment">	PARENT_THREAD_ID：如果这个线程是一个子线程（由另一个线程生成），那么该字段显示其父线程ID</span></span><br><span class="line"><span class="comment">	ROLE：暂未使用</span></span><br><span class="line"><span class="comment">	INSTRUMENTED：线程执行的事件是否被检测。有效值：YES、NO </span></span><br><span class="line"><span class="comment">	HISTORY：是否记录线程的历史事件。有效值：YES、NO * </span></span><br><span class="line"><span class="comment">	THREAD_OS_ID：由操作系统层定义的线程或任务标识符（ID）：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> threads</span><br></pre></td></tr></table></figure>
<h5 id="performance-schema实践操作"><a href="#performance-schema实践操作" class="headerlink" title="performance_schema实践操作"></a>performance_schema实践操作</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--1、哪类的SQL执行最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,COUNT_STAR,FIRST_SEEN,LAST_SEEN <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--2、哪类SQL的平均响应时间最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,AVG_TIMER_WAIT <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--3、哪类SQL排序记录数最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_SORT_ROWS <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--4、哪类SQL扫描记录数最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_ROWS_EXAMINED <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--5、哪类SQL使用临时表最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_CREATED_TMP_TABLES,SUM_CREATED_TMP_DISK_TABLES <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--6、哪类SQL返回结果集最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_ROWS_SENT <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--7、哪个表物理IO最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> file_name,event_name,SUM_NUMBER_OF_BYTES_READ,SUM_NUMBER_OF_BYTES_WRITE <span class="keyword">FROM</span> file_summary_by_instance <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUM_NUMBER_OF_BYTES_READ <span class="operator">+</span> SUM_NUMBER_OF_BYTES_WRITE <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--8、哪个表逻辑IO最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> object_name,COUNT_READ,COUNT_WRITE,COUNT_FETCH,SUM_TIMER_WAIT <span class="keyword">FROM</span> table_io_waits_summary_by_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> sum_timer_wait <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--9、哪个索引访问最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> OBJECT_NAME,INDEX_NAME,COUNT_FETCH,COUNT_INSERT,COUNT_UPDATE,COUNT_DELETE <span class="keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUM_TIMER_WAIT <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--10、哪个索引从来没有用过？</span></span><br><span class="line"><span class="keyword">SELECT</span> OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME <span class="keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="keyword">WHERE</span> INDEX_NAME <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> COUNT_STAR <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> OBJECT_SCHEMA <span class="operator">&lt;&gt;</span> <span class="string">&#x27;mysql&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> OBJECT_SCHEMA,OBJECT_NAME;</span><br><span class="line"><span class="comment">--11、哪个等待事件消耗时间最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> EVENT_NAME,COUNT_STAR,SUM_TIMER_WAIT,AVG_TIMER_WAIT <span class="keyword">FROM</span> events_waits_summary_global_by_event_name <span class="keyword">WHERE</span> event_name <span class="operator">!=</span> <span class="string">&#x27;idle&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUM_TIMER_WAIT <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--12-1、剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息</span></span><br><span class="line"><span class="keyword">SELECT</span> EVENT_ID,sql_text <span class="keyword">FROM</span> events_statements_history <span class="keyword">WHERE</span> sql_text <span class="keyword">LIKE</span> <span class="string">&#x27;%count(*)%&#x27;</span>;</span><br><span class="line"><span class="comment">--12-2、查看每个阶段的时间消耗</span></span><br><span class="line"><span class="keyword">SELECT</span> event_id,EVENT_NAME,SOURCE,TIMER_END <span class="operator">-</span> TIMER_START <span class="keyword">FROM</span> events_stages_history_long <span class="keyword">WHERE</span> NESTING_EVENT_ID <span class="operator">=</span> <span class="number">1553</span>;</span><br><span class="line"><span class="comment">--12-3、查看每个阶段的锁等待情况</span></span><br><span class="line"><span class="keyword">SELECT</span> event_id,event_name,source,timer_wait,object_name,index_name,operation,nesting_event_id <span class="keyword">FROM</span> events_waits_history_longWHERE nesting_event_id <span class="operator">=</span> <span class="number">1553</span>;</span><br></pre></td></tr></table></figure>
<h4 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">mysql执行计划</a></p>
<p>可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。</p>
<h5 id="执行计划中包含的信息"><a href="#执行计划中包含的信息" class="headerlink" title="执行计划中包含的信息"></a>执行计划中包含的信息</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">列名</th>
<th style="text-align:center">涵义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id</td>
<td style="text-align:center">The <code>SELECT</code> identifier</td>
</tr>
<tr>
<td style="text-align:center">select_type</td>
<td style="text-align:center">The <code>SELECT</code> type</td>
</tr>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">The table for the output row</td>
</tr>
<tr>
<td style="text-align:center">partitions</td>
<td style="text-align:center">The matching partitions</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">The join type</td>
</tr>
<tr>
<td style="text-align:center">possible_keys</td>
<td style="text-align:center">The possible indexes to choose</td>
</tr>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">The index actually chosen</td>
</tr>
<tr>
<td style="text-align:center">key_len</td>
<td style="text-align:center">The length of the chosen key</td>
</tr>
<tr>
<td style="text-align:center">ref</td>
<td style="text-align:center">The columns compared to the index</td>
</tr>
<tr>
<td style="text-align:center">rows</td>
<td style="text-align:center">Estimate of rows to be examined</td>
</tr>
<tr>
<td style="text-align:center">filtered</td>
<td style="text-align:center">Percentage of rows filtered by table condition</td>
</tr>
<tr>
<td style="text-align:center">extra</td>
<td style="text-align:center">Additional information</td>
</tr>
</tbody>
</table>
</div>
<p><strong>执行计划是</strong>：当执行SQL语句时，首先会分析、优化，形成执行计划，在按照执行计划执行。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的索引</title>
    <url>/posts/9edcaf99/</url>
    <content><![CDATA[<h2 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h2><p>索引是什么了，查阅了官方文档。官方文档写了索引的作用和没有索引会带来全表扫描，非常费时间。 <code>Indexes are used to find rows with specific column values quickly. Without an index, MySQL must begin with the first row and then read through the entire table to find the relevant rows.</code> 简单的说索引是提高查询速度。这个很好理解，就像是以前的英文词典，找单词如果没有前面目录的话，效率很低，得全文找一遍。</p>
<h2 id="索引实现原理"><a href="#索引实现原理" class="headerlink" title="索引实现原理"></a>索引实现原理</h2><p>要搞清楚索引的实现原理，先看看索引的底层实现，<strong>MySQL索引大部分采用B-Tree实现，B-Tree又有B-树和B+树</strong>。还有一些使用Hash索引。</p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>再说B-Tree之前，先简单了解一下二叉搜索树（Binary Search Trees）。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309160238.png" alt="image-20210309160238726"></p>
<p>理解二叉搜索树，对于后面理解B-和B+树很有帮助，因为这2种有些特性跟二叉搜索树很像。二叉搜索树的特点是左孩子的值小于父亲节点的值，父亲节点的值小于右孩子的值，即按二叉树的中序遍历，刚好是一个按小到大排序的。二叉搜索树的查找就可以使用二分查找，如果要查找10，因为10比27小，所以往左孩子找，10&lt;14，还在左孩子找。最坏的情况下，<strong>查找的次数等于树的高度</strong>。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p><strong>B树和B-tree理解成了两种不同类别的树，其实这两个是同一种树;</strong></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构</p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol>
<li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</li>
<li>子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</li>
<li>关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</li>
<li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309163100.png" alt="image-20210309163059977"></p>
<h4 id="B树查询流程"><a href="#B树查询流程" class="headerlink" title="B树查询流程"></a>B树查询流程</h4><p>从上图中找到E字母，查找流程如下</p>
<ol>
<li>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li>
<li>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</li>
<li>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</li>
</ol>
<h4 id="B树插入节点流程"><a href="#B树插入节点流程" class="headerlink" title="B树插入节点流程"></a>B树插入节点流程</h4><p>节点要处于违规状态，它必须包含在可接受范围之外数目的元素。</p>
<ol>
<li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。</li>
<li>如果没有节点处于违规状态则处理结束。</li>
<li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。</li>
</ol>
<h4 id="B树删除节点流程"><a href="#B树删除节点流程" class="headerlink" title="B树删除节点流程"></a>B树删除节点流程</h4><ol>
<li>首先，查找要删除的值。接着从包含它的节点中删除这个值。</li>
<li>如果没有节点处于违规状态则处理结束。</li>
<li>如果节点处于违规状态则有两种可能情况：<ol>
<li>它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。</li>
<li>它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</li>
</ol>
</li>
</ol>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。</p>
<h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><ol>
<li>B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；</li>
<li>B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li>
<li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li>
<li><strong>非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）</strong>;</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快</li>
<li>B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li>
<li>B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li>
<li>B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
</ol>
<blockquote>
<p>B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</p>
</blockquote>
<h2 id="为什么是B-Tree-B-来实现数据库索引"><a href="#为什么是B-Tree-B-来实现数据库索引" class="headerlink" title="为什么是B-Tree(B+)来实现数据库索引"></a>为什么是B-Tree(B+)来实现数据库索引</h2><h3 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h3><p>数据导论书中开头就是说： B树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树,计算机系统有主存和基于磁盘的辅存，主存通常就是我们说的RAM，也就是内存，这里不展开说它。<strong>索引文件本身很大，一般不会存在内存里，因此索引往往是以文件的形式存储在磁盘里，所以索引检索需要磁盘I/O操作</strong></p>
<p>为了缩短磁盘读取的时间，计算机做了一些优化：磁盘预读。磁盘预读是基于局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。所以磁盘I/O操作时不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部性原理告诉我们，<strong>当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到</strong>.</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。</p>
<ul>
<li>文件很大，不可能全部存储在内存中，故要存储到磁盘上。</li>
<li>索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因为每次磁盘I/O消耗时间都是非常多的。</li>
<li>局部性原理与磁盘预读，预读的长度一般为页（page）的整倍数。</li>
</ul>
<h3 id="B-B-的查找性能"><a href="#B-B-的查找性能" class="headerlink" title="B-/B+的查找性能"></a>B-/B+的查找性能</h3><p>数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。B-树也利用这一点，每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一次磁盘I/O就读取了一页的数据。下面是B-树的示例图：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309164634.png" alt="image-20210309164634346"></p>
<p>根据B-Tree的定义，可知检索一次最多需要访问h个节点（h个树的高度）。<strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。所以B-Tree作为索引效率是非常高，相比平衡二叉树、红黑树要高很多，</strong>因为这些树的h一般都比较深。</p>
<h3 id="B-树的直观图"><a href="#B-树的直观图" class="headerlink" title="B+树的直观图"></a>B+树的直观图</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309164727.png" alt="image-20210309164727718"></p>
<p>B+树比B-树更加适合作为磁盘的索引数据结构，原因是B+树的内部结点不存储data，内部结点的出度d越大，那么渐进复杂度越小。出度d的上限取决于节点内key和data的大小： <strong>dmax=floor(pagesize/(keysize+datasize+pointsize))</strong></p>
<p>一般3层B+树可以存储上百万的数据，也就是读取上百万的数据，只需要3次磁盘I/O，可见这效率，大大提升了。</p>
<h2 id="不同引擎的索引实现原理"><a href="#不同引擎的索引实现原理" class="headerlink" title="不同引擎的索引实现原理"></a>不同引擎的索引实现原理</h2><h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p>MyISAM的索引采用B+树实现，MyISAM的索引和数据时分开的，叶子节点data存取的是数据的地址，要根据索引找到数据，先根据索引找到叶子节点，再根据叶子节点找到数据的地址，然后再根据数据地址取出数据</p>
<h4 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a>主键索引：</h4><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。<br>下图是MyISAM主键索引的原理图：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309165534.png" alt="image-20210309165534544"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，图myisam1是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。</p>
<h4 id="辅助索引（Secondary-key）"><a href="#辅助索引（Secondary-key）" class="headerlink" title="辅助索引（Secondary key）"></a>辅助索引（Secondary key）</h4><p><strong>在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</strong> 如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309165625.png" alt="image-20210309165625118"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，<strong>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</strong><br>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<ol>
<li><strong>第一个重大区别是InnoDB的数据文件本身就是索引文件。</strong></li>
<li>InnoDB的辅助索引data域存储相应记录主键的值而不是地址。</li>
</ol>
<h4 id="主键索引：-1"><a href="#主键索引：-1" class="headerlink" title="主键索引："></a>主键索引：</h4><p> MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309165746.png" alt="image-20210309165746780"></p>
<p>以上是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做<strong>聚集索引</strong>。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<h4 id="InnoDB的辅助索引"><a href="#InnoDB的辅助索引" class="headerlink" title="InnoDB的辅助索引"></a>InnoDB的辅助索引</h4><p> InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309165824.png" alt="image-20210309165824763"></p>
<p><strong>InnoDB 表是基于聚簇索引建立的</strong>。因此InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列， <strong>所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义很多索引，则争取尽量把主键定义得小一些。</strong> InnoDB 不会压缩索引。</p>
<p>文字符的ASCII码作为比较准则。<strong>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</strong></p>
<p>不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白<strong>为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</strong> 再例如， <strong>用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</strong></p>
<h3 id="InnoDB索引和MyISAM索引的区别："><a href="#InnoDB索引和MyISAM索引的区别：" class="headerlink" title="InnoDB索引和MyISAM索引的区别："></a>InnoDB索引<strong>和</strong>MyISAM索引的区别：</h3><p>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</p>
<p>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</p>
<h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>InnoDB辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录，不建议使用过长的字段作为主键，因为<strong>所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</strong></p>
<p><strong>不建议用非单调的字段作为InnoDB的主键</strong>，因为InnoDB数据文件本身是一颗B+Tree，<strong>非单调的主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，所以一般使用自增字段作为主键。</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的Sql执行流程</title>
    <url>/posts/6b5d697/</url>
    <content><![CDATA[<h2 id="执行流程图"><a href="#执行流程图" class="headerlink" title="执行流程图"></a>执行流程图</h2><p>简易的流程图如下:</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309144801.png" alt="image-20210309144801371"></p>
<p>大致流程描述:</p>
<ol>
<li>MySQL客户端通过协议将SQL语句发送给MySQL服务器。</li>
<li>服务器会先检查查询缓存中是否有执行过这条SQL，如果命中缓存，则将结果返回，否则进入下一个环节（<strong>查询缓存默认不开启</strong>）。</li>
<li>服务器端进行SQL解析，预处理，然后由查询优化器生成对应的执行计划。</li>
<li>服务器根据查询优化器给出的执行计划，再调用存储引擎的API执行查询。</li>
<li>将结果返回给客户端，如果<strong>开启查询缓存，则会备份一份到查询缓存中</strong>。</li>
</ol>
<h2 id="流程图详解"><a href="#流程图详解" class="headerlink" title="流程图详解"></a>流程图详解</h2><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>MySQL查询缓存会保存查询返回的完整结构。当查询命中该缓存时，MySQL会立刻返回结果，跳过了解析、优化和执行阶段。 但查询缓存是默认不开启的，且要求SQL和参数都是一样，同时查询缓存系统会跟踪查询中涉及的每一个表，如果这些表发生变化，则该表相关的所有缓存数据均会失效。所以命中率一般较低，生产环境中也很少用到，</p>
<h3 id="解析和预处理"><a href="#解析和预处理" class="headerlink" title="解析和预处理"></a>解析和预处理</h3><p>如果查询缓存未命中，则到解析器。解析器主要是对SQL语句进行解析，使用MySQLy语法规则进行验证和解析查询，并生成对应的解析树。 得到解析数之后，还需要做预处理，预处理则进一步检查解释树是否合法，以及进行一些优化，比如检查数据表和列是否存在，如果有计算，会将计算的结果算出来等等。</p>
<h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>查询优化器是整个流程中重要的一环。查询优化器会将预处理之后的解析树转化成执行计划。一条查询可以有多种执行方法，最后均会返回相同结果。查询优化器的作用就是找到这其中最好的执行计划。  生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。 通常所讲的优化SQL，其实就是想让查询优化器，按照我们的思路,帮我们选择最优的执行方案。</p>
<h3 id="查询执行计划"><a href="#查询执行计划" class="headerlink" title="查询执行计划"></a>查询执行计划</h3><p>查询执行计划，就是MySQL查询中的执行计划，比如是执行where语句还是from语句，下面有一张执行顺序的图。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309145045.png" alt="image-20210309145045381"></p>
<p>最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。</p>
<ul>
<li><p>FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</p>
</li>
<li><p>ON: 对虚表VT1进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。</p>
</li>
<li><p>JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3， 如果 from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</p>
</li>
<li><p>WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。</p>
</li>
<li><p>GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</p>
</li>
<li><p>CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.</p>
</li>
<li><p>HAVING： 对虚拟表VT6应用having过滤，只有符合的记录才会被 插入到虚拟表VT7中。</p>
</li>
<li><p>SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。</p>
</li>
<li><p>DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9.</p>
</li>
<li><p>ORDER BY: 将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10.</p>
</li>
<li><p>LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。</p>
</li>
</ul>
<h3 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h3><p>执行计划会传给查询执行引擎，执行引擎选择存储引擎来执行计划，到磁盘中的文件中去查询。 影响这个查询性能最根本的原因是什么? 其实是硬盘的机械运动，也就是我们平时熟悉的IO，所以一条查询语句是快还是慢，就是根据这个时间的IO来确定的。那怎么执行IO又是什么来确定的?就是传过来的这一份执行计划.</p>
<p>原文链接：<a href="https://juejin.cn/post/6844903780987715592">https://juejin.cn/post/6844903780987715592</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的多表查询及约束</title>
    <url>/posts/c746dd2d/</url>
    <content><![CDATA[<h2 id="MySQL的约束"><a href="#MySQL的约束" class="headerlink" title="MySQL的约束"></a>MySQL的约束</h2><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><ul>
<li>语法：order by 子句</li>
<li>order by 排序字段1 排序方式1 ，  排序字段2 排序方式2…</li>
<li>排序方式：<ul>
<li>ASC：升序，默认的。</li>
<li>DESC：降序。</li>
</ul>
</li>
<li><strong>如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</strong></li>
</ul>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>将一列数据作为一个整体，进行纵向的计算。</p>
<ul>
<li><strong>count</strong>：计算个数<ul>
<li>一般选择非空的列：主键</li>
<li>count(*)  </li>
</ul>
</li>
<li><strong>max</strong>：计算最大值</li>
<li><strong>min</strong>：计算最小值</li>
<li><strong>sum</strong>：计算和</li>
<li><strong>avg</strong>：计算平均值</li>
</ul>
<blockquote>
<p>聚合函数的计算，<strong>排除null值。</strong></p>
<p><strong>解决方案：</strong></p>
<ol>
<li>选择不包含非空的列进行计算</li>
<li>IFNULL函数</li>
</ol>
</blockquote>
<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>group by 分组字段</p>
<p>employee 表数据</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>gender</th>
<th>hire_date</th>
<th>salary</th>
<th>performance</th>
<th>manage</th>
<th>deparmant</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>张三</td>
<td>男</td>
<td>2/12/1991 00:00:00</td>
<td>2000</td>
<td>200</td>
<td>500</td>
<td>营销部</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>男</td>
<td>5/8/1993 00:00:00</td>
<td>4000</td>
<td>500</td>
<td></td>
<td>营销部</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>女</td>
<td>12/13/1993 00:00:00</td>
<td>1000</td>
<td>100</td>
<td>5000</td>
<td>研发部</td>
</tr>
<tr>
<td>1004</td>
<td>赵六</td>
<td>男</td>
<td>8/19/1996 00:00:00</td>
<td>8000</td>
<td>1000</td>
<td>4000</td>
<td>财务部</td>
</tr>
<tr>
<td>1005</td>
<td>孙七</td>
<td>女</td>
<td>11/6/1997 00:00:00</td>
<td>5000</td>
<td>500</td>
<td></td>
<td>研发部</td>
</tr>
<tr>
<td>1006</td>
<td>周八</td>
<td>男</td>
<td>10/16/1994 00:00:00</td>
<td>6000</td>
<td>2000</td>
<td>1000</td>
<td>人事部</td>
</tr>
<tr>
<td>1007</td>
<td>吴九</td>
<td>女</td>
<td>9/22/1995 00:00:00</td>
<td>8000</td>
<td>1500</td>
<td></td>
<td>研发部</td>
</tr>
<tr>
<td>1008</td>
<td>郑十</td>
<td>女</td>
<td>10/25/1998 00:00:00</td>
<td>4000</td>
<td>900</td>
<td></td>
<td>人事部</td>
</tr>
</tbody>
</table>
</div>
<h4 id="GroupBy-Group-concat"><a href="#GroupBy-Group-concat" class="headerlink" title="GroupBy+Group_concat"></a>GroupBy+Group_concat</h4><p>group by 是分组，是分组，是分组，分组并不是去重，而是分组</p>
<p>将查询结果按一个或多个进行分组，字段值相同的为一组</p>
<p>GroupBy+Group_concat ： 表示分组之后，根据分组结果，使用 group_contact() 来放置每一组的每字段的值的集合</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deparmant, GROUP_CONCAT(`name`) <span class="keyword">from</span> employee <span class="keyword">GROUP</span> <span class="keyword">BY</span> deparmant</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309112830.png" alt="image-20210309112830453"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,gender <span class="keyword">from</span> employee <span class="keyword">GROUP</span> <span class="keyword">BY</span> gender,name</span><br><span class="line"><span class="comment">-- 先按gender分组，再按姓名分组...</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309112918.png" alt="image-20210309112918423"></p>
<h4 id="SQL分组-聚合函数"><a href="#SQL分组-聚合函数" class="headerlink" title="SQL分组+聚合函数"></a>SQL分组+聚合函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deparmant, GROUP_CONCAT(salary), <span class="built_in">SUM</span>(salary),<span class="built_in">AVG</span>(salary) 平均工资,<span class="built_in">MAX</span>(salary) 最高工资 <span class="keyword">from</span> employee <span class="keyword">GROUP</span> <span class="keyword">BY</span> deparmant;</span><br><span class="line"><span class="comment">-- 根据department 分组，计算各部门下工资总数，平均工资，最高工资![1532919789347]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309112957.png" alt="image-20210309112957603"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询每个部门的部门名称以及每个部门的人数</span></span><br><span class="line"><span class="keyword">SELECT</span> deparmant, GROUP_CONCAT(`name`), <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">from</span> employee <span class="keyword">GROUP</span> <span class="keyword">BY</span> deparmant</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309113025.png" alt="image-20210309113025515"></p>
<h4 id="SQL分组GroupBy-Having"><a href="#SQL分组GroupBy-Having" class="headerlink" title="SQL分组GroupBy+Having"></a>SQL分组GroupBy+Having</h4><ul>
<li>group by + having 用来分组查询后指定一些条件来输出查询结果</li>
<li>having 和 where 一样，但 having 只能用于 group by</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资总和大于 9000的部门名称</span></span><br><span class="line"><span class="keyword">SELECT</span> deparmant, GROUP_CONCAT(salary), <span class="built_in">SUM</span>(salary) <span class="keyword">FROM</span> employee </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deparmant </span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(salary) <span class="operator">&gt;</span> <span class="number">9000</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309113103.png" alt="image-20210309113103212"></p>
<h5 id="having-和-where-的区别："><a href="#having-和-where-的区别：" class="headerlink" title="having 和 where 的区别："></a>having 和 where 的区别：</h5><ol>
<li>having 是在分组后对数据进行过滤，where 是在分组前对数据进行过滤</li>
<li>having后面可以使用分组函数(统计函数)，where后面不可以使用分组函数</li>
<li>where 是对分组前记录的条件，如果某行记录没有满足where字句的条件，那么这行记录不会参加分组；而having是对分组后数据的约束</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资大于2000的，工资总和大于9000的部门名称以及工资和</span></span><br><span class="line"><span class="keyword">select</span> deparmant,GROUP_CONCAT(salary), <span class="built_in">SUM</span>(salary) <span class="keyword">from</span> employee </span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">2000</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deparmant </span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">sum</span>(salary) <span class="operator">&gt;</span> <span class="number">9000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">SUM</span>(salary) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309113315.png" alt="image-20210309113315352"></p>
<h3 id="sql语句书写顺序"><a href="#sql语句书写顺序" class="headerlink" title="sql语句书写顺序"></a>sql语句书写顺序</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309113332.png" alt="image-20210309113332101"></p>
<h2 id="MySQL的多表查询"><a href="#MySQL的多表查询" class="headerlink" title="MySQL的多表查询"></a>MySQL的多表查询</h2><h3 id="准备sql"><a href="#准备sql" class="headerlink" title="准备sql"></a>准备sql</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建部门表</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept (NAME) <span class="keyword">VALUES</span> (<span class="string">&#x27;开发部&#x27;</span>),(<span class="string">&#x27;市场部&#x27;</span>),(<span class="string">&#x27;财务部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 创建员工表</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">	gender <span class="type">CHAR</span>(<span class="number">1</span>), <span class="comment">-- 性别</span></span><br><span class="line">	salary <span class="keyword">DOUBLE</span>, <span class="comment">-- 工资</span></span><br><span class="line">	join_date <span class="type">DATE</span>, <span class="comment">-- 入职日期</span></span><br><span class="line">	dept_id <span class="type">INT</span>,</span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY (dept_id) <span class="keyword">REFERENCES</span> dept(id) <span class="comment">-- 外键，关联部门表(部门表的主键)</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">7200</span>,<span class="string">&#x27;2013-02-24&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">&#x27;猪八戒&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">3600</span>,<span class="string">&#x27;2010-12-02&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">&#x27;唐僧&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">9000</span>,<span class="string">&#x27;2008-08-08&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">&#x27;白骨精&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">5000</span>,<span class="string">&#x27;2015-10-07&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dept_id) <span class="keyword">VALUES</span>(<span class="string">&#x27;蜘蛛精&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">4500</span>,<span class="string">&#x27;2011-03-14&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h4><h5 id="隐式内连接"><a href="#隐式内连接" class="headerlink" title="隐式内连接"></a>隐式内连接</h5><p> 使用where条件消除无用数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有员工信息和对应的部门信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;</span><br><span class="line">			</span><br><span class="line"><span class="comment">-- 查询员工表的名称，性别。部门表的名称</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.name,emp.gender,dept.name <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;</span><br><span class="line">			</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">t1.name, <span class="comment">-- 员工表的姓名</span></span><br><span class="line">t1.gender,<span class="comment">-- 员工表的性别</span></span><br><span class="line">t2.name <span class="comment">-- 部门表的名称</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp t1,</span><br><span class="line">dept t2</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">t1.`dept_id` <span class="operator">=</span> t2.`id`;</span><br></pre></td></tr></table></figure>
<h5 id="显式内连接"><a href="#显式内连接" class="headerlink" title="显式内连接"></a>显式内连接</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;	</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;	</span><br></pre></td></tr></table></figure>
<h4 id="外链接查询"><a href="#外链接查询" class="headerlink" title="外链接查询"></a>外链接查询</h4><h5 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h5><p>左向外联接的结果集包括 LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；</span></span><br></pre></td></tr></table></figure>
<p>查询的是左表所有数据以及其交集部分。</p>
<blockquote>
<p>效果: 内连接查询与多表联合查询的效果是一样的.</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称</span></span><br><span class="line"><span class="keyword">SELECT</span> 	t1.<span class="operator">*</span>,t2.`name` <span class="keyword">FROM</span> emp t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept t2 <span class="keyword">ON</span> t1.`dept_id` <span class="operator">=</span> t2.`id`;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309115012.png" alt="image-20210309115012503"></p>
<h5 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h5><p>右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；</span></span><br></pre></td></tr></table></figure>
<p>查询的是右表所有数据以及其交集部分。</p>
<blockquote>
<p>效果:人员表中的数据全部都显示,而 部门表中的数据符合条件的才会显示,不符合条件的会以 null 进行填充.</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept t2 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> emp t1 <span class="keyword">ON</span> t1.`dept_id` <span class="operator">=</span> t2.`id`; </span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309114953.png" alt="image-20210309114953597"></p>
<h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p>查询中嵌套查询，称嵌套查询为子查询。    </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工信息</span></span><br><span class="line"><span class="comment">--  1 查询最高的工资是多少 9000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> emp;</span><br><span class="line"><span class="comment">--  2 查询员工信息，并且工资等于9000的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`salary` <span class="operator">=</span> <span class="number">9000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用子查询</span></span><br><span class="line"><span class="comment">-- 一条sql就完成这个操作。子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`salary` <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure>
<h5 id="子查询不同情况"><a href="#子查询不同情况" class="headerlink" title="子查询不同情况"></a>子查询不同情况</h5><h6 id="子查询的结果是单行单列的"><a href="#子查询的结果是单行单列的" class="headerlink" title="子查询的结果是单行单列的"></a>子查询的结果是单行单列的</h6><ul>
<li><p>子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =</p>
</li>
<li><p>查询员工工资小于平均工资的人</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.salary <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="子查询的结果是多行单列"><a href="#子查询的结果是多行单列" class="headerlink" title="子查询的结果是多行单列"></a>子查询的结果是多行单列</h6><ul>
<li><p>查询可以作为条件，使用运算符in来判断</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询&#x27;财务部&#x27;和&#x27;市场部&#x27;所有的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">OR</span> NAME <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">OR</span> dept_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">--- 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">OR</span> NAME <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="查询的结果是多行多列的"><a href="#查询的结果是多行多列的" class="headerlink" title="查询的结果是多行多列的"></a>查询的结果是多行多列的</h6><p>子查询可以作为一张虚拟表参与查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息</span></span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept t1 ,(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`join_date` <span class="operator">&gt;</span> <span class="string">&#x27;2011-11-11&#x27;</span>) t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t2.dept_id;</span><br><span class="line"><span class="comment">-- 普通内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp t1,dept t2 <span class="keyword">WHERE</span> t1.`dept_id` <span class="operator">=</span> t2.`id` <span class="keyword">AND</span> t1.`join_date` <span class="operator">&gt;</span>  <span class="string">&#x27;2011-11-11&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的常见命令</title>
    <url>/posts/4ae76812/</url>
    <content><![CDATA[<h2 id="操作数据库：CRUD"><a href="#操作数据库：CRUD" class="headerlink" title="操作数据库：CRUD"></a>操作数据库：CRUD</h2><h3 id="C-Create-：创建"><a href="#C-Create-：创建" class="headerlink" title="C(Create)：创建"></a>C(Create)：创建</h3><ul>
<li>创建数据库：<ul>
<li>create database 数据库名称;</li>
</ul>
</li>
<li>创建数据库，判断不存在，再创建：<ul>
<li>create database if not exists 数据库名称;</li>
</ul>
</li>
<li><p>创建数据库，并指定字符集</p>
<ul>
<li>create database 数据库名称 character set 字符集名;</li>
</ul>
</li>
<li><p>例子： 创建db4数据库，判断是否存在，并制定字符集为utf8</p>
<ul>
<li>create database if not exists db4 character set utf8mb4;</li>
</ul>
</li>
</ul>
<h3 id="R-Retrieve-：查询"><a href="#R-Retrieve-：查询" class="headerlink" title="R(Retrieve)：查询"></a>R(Retrieve)：查询</h3><ul>
<li><p>查询所有数据库的名称:</p>
<ul>
<li>show databases;</li>
</ul>
</li>
<li><p>查询某个数据库的字符集:查询某个数据库的创建语句</p>
<ul>
<li>show create database 数据库名称;</li>
</ul>
</li>
</ul>
<h3 id="U-Update-：修改"><a href="#U-Update-：修改" class="headerlink" title="U(Update)：修改"></a>U(Update)：修改</h3><ul>
<li>修改数据库的字符集<ul>
<li>alter database 数据库名称 character set 字符集名称;</li>
</ul>
</li>
</ul>
<h3 id="D-Delete-：删除"><a href="#D-Delete-：删除" class="headerlink" title="D(Delete)：删除"></a>D(Delete)：删除</h3><ul>
<li>删除数据库<ul>
<li>drop database 数据库名称;</li>
</ul>
</li>
<li>判断数据库存在，存在再删除<ul>
<li>drop database if exists 数据库名称;</li>
</ul>
</li>
</ul>
<h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><ul>
<li>查询当前正在使用的数据库名称<ul>
<li>select database();</li>
</ul>
</li>
<li>使用数据库<ul>
<li>use 数据库名称;</li>
</ul>
</li>
</ul>
<h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><h3 id="C-Create-：创建-1"><a href="#C-Create-：创建-1" class="headerlink" title="C(Create)：创建"></a>C(Create)：创建</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	列名<span class="number">1</span> 数据类型<span class="number">1</span>,</span><br><span class="line">	列名<span class="number">2</span> 数据类型<span class="number">2</span>,</span><br><span class="line">	....</span><br><span class="line">	列名n 数据类型n</span><br><span class="line">);</span><br><span class="line">#注意：最后一列，不需要加逗号（,）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h4><ul>
<li><p>int：整数类型  age int,</p>
</li>
<li><p>double:小数类型  score double(5,2)</p>
</li>
<li><p>date:日期，只包含年月日，yyyy-MM-dd</p>
</li>
<li><p>datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss</p>
</li>
<li><p>timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss</p>
<p>  <strong>如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</strong></p>
</li>
<li><p>varchar：字符串</p>
<p>  name varchar(20):姓名最大20个字符</p>
<p>  zhangsan 8个字符  张三 2个字符</p>
<h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`  (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `account` <span class="type">varchar</span>(<span class="number">50</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">50</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">  `mobile` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `create_time` datetime(<span class="number">0</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `creator` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">  `operator` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改人&#x27;</span>,</span><br><span class="line">  `operat_time` datetime(<span class="number">0</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `create_ip` <span class="type">varchar</span>(<span class="number">512</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建记录ip&#x27;</span>,</span><br><span class="line">  `operat_ip` <span class="type">varchar</span>(<span class="number">512</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改记录的ip&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">2</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数据状态：1-启用， 2-屏蔽（页面可以显示，可以恢复）， 3-禁用(页面不显示该条数据)&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> MyISAM AUTO_INCREMENT <span class="operator">=</span> <span class="number">3</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> COMPACT;</span><br></pre></td></tr></table></figure>
<h4 id="创建表-1"><a href="#创建表-1" class="headerlink" title="创建表"></a>创建表</h4>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#复制表结构及数据到新表(新表中没有了旧表的<span class="keyword">primary</span> key、Extra（auto_increment）等属性)</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 新表<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 旧表</span><br><span class="line">#只复制表结构到新表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 新表<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 旧表<span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 <span class="keyword">like</span> 被复制的表名;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> usertest <span class="keyword">like</span> <span class="keyword">user</span>;</span><br><span class="line">#复制旧表的数据到新表(假设两个表结构一样)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 新表<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 旧表</span><br><span class="line">复制旧表的数据到新表(假设两个表结构不一样)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 新表(字段<span class="number">1</span>,字段<span class="number">2</span>,.......) <span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段<span class="number">2</span>,...... <span class="keyword">FROM</span> 旧表</span><br><span class="line">#可以将表<span class="number">1</span>结构复制到表<span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">INTO</span> 表<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span></span><br><span class="line">#可以将表<span class="number">1</span>内容全部复制到表<span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">INTO</span> 表<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"># <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 旧表;</span><br><span class="line">将旧表的创建命令列出。我们只需要将该命令拷贝出来，更改<span class="keyword">table</span>的名字，就可以建立一个完全一样的表</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 旧表;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="R-Retrieve-：查询-1"><a href="#R-Retrieve-：查询-1" class="headerlink" title="R(Retrieve)：查询"></a>R(Retrieve)：查询</h3><h4 id="查询某个数据库中所有的表名称"><a href="#查询某个数据库中所有的表名称" class="headerlink" title="查询某个数据库中所有的表名称"></a>查询某个数据库中所有的表名称</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure>
<h4 id="查询表结构"><a href="#查询表结构" class="headerlink" title="查询表结构"></a>查询表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名;</span><br><span class="line"><span class="keyword">desc</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure>
<h3 id="U-Update-：修改-1"><a href="#U-Update-：修改-1" class="headerlink" title="U(Update)：修改"></a>U(Update)：修改</h3><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 rename <span class="keyword">to</span> 新的表名;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> usertest rename <span class="keyword">to</span> user_test;</span><br></pre></td></tr></table></figure>
<h4 id="修改表的字符集"><a href="#修改表的字符集" class="headerlink" title="修改表的字符集"></a>修改表的字符集</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="type">character</span> <span class="keyword">set</span> 字符集名称;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_test <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure>
<h4 id="添加一列"><a href="#添加一列" class="headerlink" title="添加一列"></a>添加一列</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_test <span class="keyword">add</span> test <span class="keyword">DOUBLE</span>;</span><br></pre></td></tr></table></figure>
<h4 id="修改列名称-类型"><a href="#修改列名称-类型" class="headerlink" title="修改列名称 类型"></a>修改列名称 类型</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 列名 新列别 新数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 列名 新数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_test change test test1 <span class="type">int</span>;</span><br></pre></td></tr></table></figure>
<h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_test <span class="keyword">drop</span> test1;</span><br></pre></td></tr></table></figure>
<h3 id="D-Delete-：删除-1"><a href="#D-Delete-：删除-1" class="headerlink" title="D(Delete)：删除"></a>D(Delete)：删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span>  if <span class="keyword">exists</span> 表名 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span>  if <span class="keyword">exists</span> user_test ;</span><br></pre></td></tr></table></figure>
<h2 id="操作表中数据"><a href="#操作表中数据" class="headerlink" title="操作表中数据"></a>操作表中数据</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#列名和值要一一对应，除了数字类型，其他类型需要使用引号(单双都可以)引起来</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>,...列名n) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...值n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`(`id`, `account`, `password`, `name`, `mobile`, `create_time`, `creator`, `operator`, `operat_time`, `create_ip`, `operat_ip`, `status`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, <span class="string">&#x27;管理员&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;2020-03-12 10:35:57&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;2020-03-12 10:36:06&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#如果不加任何条件，则会将表中所有记录全部修改。</span><br><span class="line">update 表名 <span class="keyword">set</span> 列名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>, 列名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span>,... [<span class="keyword">where</span> 条件];</span><br><span class="line">UPDATE `khxttest`.`<span class="keyword">user</span>` <span class="keyword">SET</span> `account` <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span>, `password` <span class="operator">=</span> <span class="string">&#x27;123456&#x27;</span>, `name` <span class="operator">=</span> <span class="string">&#x27;管理员&#x27;</span>, `mobile` <span class="operator">=</span> <span class="keyword">NULL</span>, `create_time` <span class="operator">=</span> <span class="string">&#x27;2020-03-12 10:35:57&#x27;</span>, `creator` <span class="operator">=</span> <span class="number">0</span>, `operator` <span class="operator">=</span> <span class="number">0</span>, `operat_time` <span class="operator">=</span> <span class="string">&#x27;2020-03-12 10:36:06&#x27;</span>, `create_ip` <span class="operator">=</span> <span class="string">&#x27;127.0.0.1&#x27;</span>, `operat_ip` <span class="operator">=</span> <span class="string">&#x27;127.0.0.1&#x27;</span>, `status` <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `khxttest`.`<span class="keyword">user</span>` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">29</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>delete from 表名; — 不推荐使用。有多少条记录就会执行多少次删除操作</p>
<p>TRUNCATE TABLE 表名; — 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</p>
</blockquote>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄大于20岁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄等于20岁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄不等于20岁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄大于等于20 小于等于30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="operator">&amp;&amp;</span>  age <span class="operator">&lt;=</span><span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">AND</span>  age <span class="operator">&lt;=</span><span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄22岁，18岁，25岁的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">18</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">25</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="number">22</span>,<span class="number">18</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询英语成绩为null</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english <span class="operator">=</span> <span class="keyword">NULL</span>; <span class="comment">-- 不对的。null值不能使用 = （!=） 判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询英语成绩不为null</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english  <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="comment">-- 查询姓马的有哪些？ like</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;马%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询姓名第二个字是化的人</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> &quot;_化%&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓名是3个字的人</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;___&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询姓名中包含德的人</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%德%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>where子句后跟条件</p>
<ul>
<li><strong>&lt;  &lt;=  &gt;=   =     &lt;&gt;</strong></li>
<li>BETWEEN…AND  </li>
<li>IN( 集合) </li>
<li>LIKE：模糊查询<ul>
<li>占位符：<ol>
<li>_:单个任意字符</li>
<li>%：多个任意字符</li>
</ol>
</li>
</ul>
</li>
<li>IS NULL  </li>
<li>and  或 &amp;&amp;</li>
<li>or  或 || </li>
<li>not  或 !</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的安装与卸载</title>
    <url>/posts/5a759233/</url>
    <content><![CDATA[<p><strong>相关环境</strong></p>
<p>操作系统：centos7</p>
<p>mysql版本：mysql 5.7</p>
<h2 id="MySQL-5-7-的安装"><a href="#MySQL-5-7-的安装" class="headerlink" title="MySQL 5.7 的安装"></a>MySQL 5.7 的安装</h2><h4 id="检测系统是否自带安装mysql"><a href="#检测系统是否自带安装mysql" class="headerlink" title="检测系统是否自带安装mysql"></a>检测系统是否自带安装mysql</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list installed | grep mysql</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309101055.png" alt="image-20210309101055184"></p>
<h4 id="删除系统自带的mysql及其依赖（防止冲突）"><a href="#删除系统自带的mysql及其依赖（防止冲突）" class="headerlink" title="删除系统自带的mysql及其依赖（防止冲突）"></a>删除系统自带的mysql及其依赖（防止冲突）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">此处对应的是自身版本</span></span><br><span class="line">yum -y remove mysql-libs.x86_64</span><br></pre></td></tr></table></figure>
<h4 id="安装wget命名"><a href="#安装wget命名" class="headerlink" title="安装wget命名"></a>安装wget命名</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install wget -y </span><br></pre></td></tr></table></figure>
<h4 id="下载并安装MySQL官方的-Yum-Repository"><a href="#下载并安装MySQL官方的-Yum-Repository" class="headerlink" title="下载并安装MySQL官方的 Yum Repository"></a>下载并安装MySQL官方的 Yum Repository</h4><p>由于CentOS 的yum源中没有mysql，需要到mysql的官网下载yum repo配置文件。并进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm</span><br><span class="line"> yum install mysql-community-release-el6-5.noarch.rpm -y</span><br></pre></td></tr></table></figure>
<h4 id="使用yum安装mysql"><a href="#使用yum安装mysql" class="headerlink" title="使用yum安装mysql"></a>使用yum安装mysql</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install mysql-community-server -y</span><br></pre></td></tr></table></figure>
<h4 id="启动mysql服务并设置开机启动"><a href="#启动mysql服务并设置开机启动" class="headerlink" title="启动mysql服务并设置开机启动"></a>启动mysql服务并设置开机启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动之前需要生成临时密码，需要用到证书，可能证书过期，需要进行更新操作</span></span><br><span class="line">yum update -y</span><br><span class="line"><span class="meta">#</span><span class="bash">启动mysql服务</span></span><br><span class="line">service mysqld start</span><br><span class="line"><span class="meta">#</span><span class="bash">设置mysql开机启动</span></span><br><span class="line">chkconfig mysqld on</span><br></pre></td></tr></table></figure>
<h4 id="获取mysql的临时密码"><a href="#获取mysql的临时密码" class="headerlink" title="获取mysql的临时密码"></a>获取mysql的临时密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;password&quot; /var/log/mysqld.log</span><br><span class="line"><span class="meta">#</span><span class="bash">没有获取到说明没有密码可以直接登陆</span></span><br></pre></td></tr></table></figure>
<h4 id="使用临时密码登录"><a href="#使用临时密码登录" class="headerlink" title="使用临时密码登录"></a>使用临时密码登录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p 密码</span><br></pre></td></tr></table></figure>
<h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">#上面这条命令不行时，使用下面这条命令</span><br><span class="line">#<span class="number">6</span>BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 对应<span class="number">123456</span></span><br><span class="line">#也可以通过 <span class="keyword">select</span> password(<span class="string">&#x27;123456&#x27;</span>)获取</span><br><span class="line"> <span class="keyword">set</span> password<span class="operator">=</span><span class="string">&#x27; 6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309103437.png" alt=""></p>
<h4 id="允许远程连接数据库"><a href="#允许远程连接数据库" class="headerlink" title="允许远程连接数据库"></a>允许远程连接数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<h4 id="设置字符集为utf-8"><a href="#设置字符集为utf-8" class="headerlink" title="设置字符集为utf-8"></a>设置字符集为utf-8</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在[mysqld]部分添加：</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="meta">#</span><span class="bash">在文件末尾新增[client]段，并在[client]段添加：</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line"><span class="meta">#</span><span class="bash">重启mysql</span></span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309103825.png" alt="image-20210309103825273"></p>
<h2 id="Linux下mysql的彻底卸载"><a href="#Linux下mysql的彻底卸载" class="headerlink" title="Linux下mysql的彻底卸载"></a>Linux下mysql的彻底卸载</h2><h4 id="查看mysql的安装情况"><a href="#查看mysql的安装情况" class="headerlink" title="查看mysql的安装情况"></a>查看mysql的安装情况</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep -i mysql</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309104128.png" alt="image-20210309104128079"></p>
<h4 id="删除上图安装的软件"><a href="#删除上图安装的软件" class="headerlink" title="删除上图安装的软件"></a>删除上图安装的软件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ev mysql-community-libs-5.6.51-2.el6.x86_64</span><br><span class="line">rpm -ev mysql-community-server-5.6.51-2.el6.x86_64</span><br><span class="line">rpm -ev mysql-community-release-el6-5.noarch</span><br><span class="line">rpm -ev mysql-community-common-5.6.51-2.el6.x86_64</span><br><span class="line">rpm -ev  mysql-community-client-5.6.51-2.el6.x86_64</span><br></pre></td></tr></table></figure>
<h4 id="都删除成功之后，查找相关的mysql的文件"><a href="#都删除成功之后，查找相关的mysql的文件" class="headerlink" title="都删除成功之后，查找相关的mysql的文件"></a>都删除成功之后，查找相关的mysql的文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name mysql</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210309104242.png" alt="image-20210309104242918"></p>
<h4 id="删除全部文件"><a href="#删除全部文件" class="headerlink" title="删除全部文件"></a>删除全部文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /etc/logrotate.d/mysql</span><br><span class="line">rm -rf /etc/selinux/targeted/active/modules/100/mysql</span><br><span class="line">rm -rf /var/lib/mysql</span><br><span class="line">rm -rf /var/lib/mysql/mysql</span><br><span class="line">rm -rf /usr/bin/mysql</span><br><span class="line">rm -rf /usr/lib64/mysql</span><br><span class="line">rm -rf /usr/share/mysql</span><br></pre></td></tr></table></figure>
<h4 id="再次执行命令"><a href="#再次执行命令" class="headerlink" title="再次执行命令"></a>再次执行命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep -i mysql</span><br><span class="line"><span class="meta">#</span><span class="bash">如果没有显式则表示卸载完成</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/posts/e19da94a/</url>
    <content><![CDATA[<h1 id="享元模式的定义与特点"><a href="#享元模式的定义与特点" class="headerlink" title="享元模式的定义与特点"></a>享元模式的定义与特点</h1><p>享元（Flyweight）模式的定义：运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。例如：<font color=red>线程池，连接池等</font></p>
<h1 id="享元模式的优缺点"><a href="#享元模式的优缺点" class="headerlink" title="享元模式的优缺点"></a>享元模式的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li>
<li>读取享元模式的外部状态会使得运行时间稍微变长。</li>
</ol>
<h1 id="享元模式的应用场景"><a href="#享元模式的应用场景" class="headerlink" title="享元模式的应用场景"></a>享元模式的应用场景</h1><p><strong>享元模式其实是工厂方法模式的一个改进机制</strong>，享元模式同样要求创建一个或一组对象，并且就是通过工厂方法模式生成对象的，只不过享元模式为工厂方法模式增加了缓存这一功能。</p>
<ol>
<li>系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。</li>
<li>大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。</li>
<li>由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。</li>
</ol>
<h2 id="享元模式的结构与实现"><a href="#享元模式的结构与实现" class="headerlink" title="享元模式的结构与实现"></a>享元模式的结构与实现</h2><p>享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。</p>
<ul>
<li>内部状态指对象共享出来的信息，存储在享元信息内部，并且不回随环境的改变而改变；</li>
<li>外部状态指对象得以依赖的一个标记，随环境的改变而改变，不可共享。</li>
</ul>
<p>比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。</p>
<p>享元模式的本质是缓存共享对象，降低内存消耗。</p>
<h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>享元模式的主要角色有如下。</p>
<ol>
<li>抽象享元角色（Flyweight）：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</li>
<li>具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</li>
<li>非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</li>
<li>享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ol>
<p>享元模式的结构图，其中：</p>
<ul>
<li>UnsharedConcreteFlyweight 是非享元角色，里面包含了非共享的外部状态信息 info；</li>
<li>Flyweight 是抽象享元角色，里面包含了享元方法 operation(UnsharedConcreteFlyweight state)，非享元的外部状态以参数的形式通过该方法传入；</li>
<li>ConcreteFlyweight 是具体享元角色，包含了关键字 key，它实现了抽象享元接口；</li>
<li>FlyweightFactory 是享元工厂角色，它是关键字 key 来管理具体享元；</li>
<li>客户角色通过享元工厂获取具体享元，并访问具体享元的相关方法。</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210305113805.png" alt="image-20210305113805940"></p>
<h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><p>享元角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 享元模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 享元模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/5 11:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(String color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">int</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle: Draw() [Color : &quot;</span> + color</span><br><span class="line">                +<span class="string">&quot;, x : &quot;</span> + x +<span class="string">&quot;, y :&quot;</span> + y +<span class="string">&quot;, radius :&quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>享元工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 享元模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, Shape&gt; circleMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getCircle</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        Circle circle = (Circle)circleMap.get(color);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(circle == <span class="keyword">null</span>) &#123;</span><br><span class="line">            circle = <span class="keyword">new</span> Circle(color);</span><br><span class="line">            circleMap.put(color, circle);</span><br><span class="line">            System.out.println(<span class="string">&quot;Creating circle of color : &quot;</span> + color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>客户角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 享元模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/5 11:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String colors[] =</span><br><span class="line">            &#123; <span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Blue&quot;</span>, <span class="string">&quot;White&quot;</span>, <span class="string">&quot;Black&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">            Circle circle =</span><br><span class="line">                    (Circle)ShapeFactory.getCircle(getRandomColor());</span><br><span class="line">            circle.setX(getRandomX());</span><br><span class="line">            circle.setY(getRandomY());</span><br><span class="line">            circle.setRadius(<span class="number">100</span>);</span><br><span class="line">            circle.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRandomColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> colors[(<span class="keyword">int</span>)(Math.random()*colors.length)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210305112815.png" alt="image-20210305112815359"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper集群简单介绍</title>
    <url>/posts/5af4d7fe/</url>
    <content><![CDATA[<p><a href="https://zookeeper.apache.org/doc/r3.6.2/zookeeperOver.html">官方文档地址</a></p>
<h1 id="Zookeeper介绍"><a href="#Zookeeper介绍" class="headerlink" title="Zookeeper介绍"></a>Zookeeper介绍</h1><p>ZooKeeper是一个<a href="https://baike.baidu.com/item/分布式/19276232">分布式</a>的，开放源码的<a href="https://baike.baidu.com/item/分布式应用程序/9854429">分布式应用程序</a>协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<p>ZooKeeper具有<strong>高性能</strong>，<strong>高可用性</strong>，<strong>严格排序的访问</strong>的特性。ZooKeeper的<strong>高性能</strong>意味着它<strong>可以在大型的分布式系统中使用</strong>。<strong>可靠性</strong>方面使它<strong>不会产生单点故障</strong>。<strong>严格的排序</strong>意味着可以<strong>在客户端上实现复杂的同步原语</strong>。</p>
<blockquote>
<p>详细测试对比可看官方文档   ：   <a href="https://zookeeper.apache.org/doc/r3.6.2/zookeeperOver.html">官方文档地址</a></p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210228144326.png" alt="image-20210228144326215"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210228143924.png" alt="image-20210228143924298"></p>
<blockquote>
<p><a href="https://juejin.cn/post/6844903919026438158">Zookeeper顺序一致性的理解</a></p>
</blockquote>
<h1 id="Zookeeper的读写机制"><a href="#Zookeeper的读写机制" class="headerlink" title="Zookeeper的读写机制"></a>Zookeeper的读写机制</h1><ul>
<li>Zookeeper是一个由多个server组成的集群</li>
<li>一个leader，多个follower</li>
<li>每个server保存一份数据副本</li>
<li>全局数据一致</li>
<li>分布式读写</li>
<li>更新请求转发，由<strong>leader实施</strong></li>
</ul>
<h1 id="Zookeeper-的保证"><a href="#Zookeeper-的保证" class="headerlink" title="Zookeeper 的保证"></a><strong>Zookeeper 的保证</strong></h1><ul>
<li><font color=red>更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行</font></li>
<li>数据更新原子性，一次数据更新要么成功，要么失败</li>
<li>全局<strong>唯一数据视图</strong>，client无论连接到哪个server，<strong>数据视图都是一致的</strong></li>
<li>实时性，在一定事件范围内，client能读到最新数据</li>
</ul>
<h1 id="集群中的角色"><a href="#集群中的角色" class="headerlink" title="集群中的角色"></a>集群中的角色</h1><ul>
<li>领导者（leader），负责进行投票的发起和决议，更新系统状态</li>
<li>学习者（learner），包括跟随者（follower）和观察者（observer），follower用于接受客户端请求并想客户端返回结果，在选主过程中参与投票</li>
<li>Observer可以接受客户端连接，将写请求转发给leader，但<strong>observer不参加投票过程</strong>，只同步leader的状态，<font color=red>observer的目的是为了扩展系统，提高读取速度,放大查询能力</font></li>
<li>客户端（client），请求发起方</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302102953.png" alt="183233-20160316222444771-1363762533"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302103007.jpg" alt=""></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303103255.png" alt="节点间连接模式"></p>
<ul>
<li>　　Zookeeper的核心<strong>是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。</strong>当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</li>
</ul>
<ul>
<li>　为了保证事务的顺序一致性<strong>，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid</strong>。<strong>实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</strong></li>
</ul>
<p><strong>每个Server在工作过程中有三种状态：</strong></p>
<ul>
<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>
<li>LEADING：当前Server即为选举出来的leader</li>
<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>
</ul>
<p><strong>Follower主要有四个功能</strong></p>
<ol>
<li>向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</li>
<li>接收Leader消息并进行处理；</li>
<li>接收Client的请求，如果为写请求，发送给Leader进行投票；</li>
<li>返回Client结果。</li>
</ol>
<p><strong>Follower的消息循环处理如下几种来自Leader的消息：</strong></p>
<ol>
<li>PING消息： 心跳消息；</li>
<li>PROPOSAL消息：Leader发起的提案，要求Follower投票；</li>
<li>COMMIT消息：服务器端最新一次提案的信息；</li>
<li>UPTODATE消息：表明同步完成；</li>
<li>.REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</li>
<li>SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</li>
</ol>
<p>其他文档：<a href="http://www.cnblogs.com/lpshou/archive/2013/06/14/3136738.html">http://www.cnblogs.com/lpshou/archive/2013/06/14/3136738.html</a></p>
<h1 id="Zookeeper中节点的状态信息各字段含义"><a href="#Zookeeper中节点的状态信息各字段含义" class="headerlink" title="Zookeeper中节点的状态信息各字段含义"></a>Zookeeper中节点的状态信息各字段含义</h1><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302100241.png" alt="image-20210302100241394"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stat</span> <span class="keyword">implements</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> czxid; <span class="comment">// 该数据节点被创建时的事务id</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> mzxid; <span class="comment">// 该数据节点被修改时最新的事务id（集群中会不一样）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> ctime; <span class="comment">// 该数据节点创建时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> mtime; <span class="comment">// 该数据节点最后修改时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> version; <span class="comment">// 当前节点版本号（可以理解为修改次数，每修改一次值+1）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> cversion;<span class="comment">// 子节点版本号（子节点修改次数，每修改一次值+1）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> aversion; <span class="comment">// 当前节点acl版本号（acl节点被修改次数，每修改一次值+1）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> ephemeralOwner; <span class="comment">// 临时节点标示，当前节点如果是临时节点，则存储的创建者的会话id（sessionId），如果不是，那么值=0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> dataLength;<span class="comment">// 当前节点数据长度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> numChildren; <span class="comment">// 当前节点子节点个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> pzxid; <span class="comment">// 当前节点的父级节点事务ID</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Stat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><font color=red>其中zxid表示的是zookeeper的事务ID，由64位数字组成，分为高32位和低32位</font></strong></p>
<p><strong>高32位</strong>：Epoch周期数，值为最新的领导的对应的id，其实就是就是一个递增的数字</p>
<p><strong>低32位</strong>：计数器，一个递增的计数器，当处理了一个事务，值+1</p>
<p>zxid生成的规则：ZxidUtils.makeZxid</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZxidUtils</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getEpochFromZxid</span><span class="params">(<span class="keyword">long</span> zxid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zxid &gt;&gt; <span class="number">32L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getCounterFromZxid</span><span class="params">(<span class="keyword">long</span> zxid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zxid &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">makeZxid</span><span class="params">(<span class="keyword">long</span> epoch, <span class="keyword">long</span> counter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (epoch &lt;&lt; <span class="number">32L</span>) | (counter &amp; <span class="number">0xffffffffL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">zxidToString</span><span class="params">(<span class="keyword">long</span> zxid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Long.toHexString(zxid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Zookeeper节点数据操作流程"><a href="#Zookeeper节点数据操作流程" class="headerlink" title="Zookeeper节点数据操作流程"></a>Zookeeper节点数据操作流程</h1><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302103739.png" alt="183233-20160316223234865-1124736424"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303103735.png" alt=""></p>
<p><strong>详细说明</strong></p>
<ol>
<li>在Client向Follwer发出一个写的请求</li>
<li>Follwer把请求发送给Leader</li>
<li>Leader接收到以后开始发起投票并通知Follwer进行投票</li>
<li>Follwer把投票结果发送给Leader</li>
<li>Leader将结果汇总后如果需要写入，则开始写入同时把写入操作通知给Leader然后commit;</li>
<li>Follwer把请求结果返回给Client</li>
</ol>
<h1 id="Zookeeper集群的两种运行状态"><a href="#Zookeeper集群的两种运行状态" class="headerlink" title="Zookeeper集群的两种运行状态"></a>Zookeeper集群的两种运行状态</h1><h2 id="leader可用状态"><a href="#leader可用状态" class="headerlink" title="leader可用状态"></a>leader可用状态</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210228144112.png" alt="image-20210228144111968"></p>
<h2 id="leader不可用状态"><a href="#leader不可用状态" class="headerlink" title="leader不可用状态"></a>leader不可用状态</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210228144131.png" alt="image-20210228144131837"></p>
<p>不可用状态恢复到可用状态根据官方测试<font color=red>小于200ms</font></p>
<h1 id="Zookeeper的集群选举"><a href="#Zookeeper的集群选举" class="headerlink" title="Zookeeper的集群选举"></a>Zookeeper的集群选举</h1><p>Leader选举是ZooKeeper中最重要的技术之一，也是保证分布式数据一致性的关键所在。</p>
<p> <a href="https://blog.csdn.net/qq_39554452/article/details/109988266">zookeeper集群搭建及选举模式</a></p>
<h2 id="服务器启动时期的选举"><a href="#服务器启动时期的选举" class="headerlink" title="服务器启动时期的选举"></a>服务器启动时期的选举</h2><h3 id="服务器启动时期的Leader选举"><a href="#服务器启动时期的Leader选举" class="headerlink" title="服务器启动时期的Leader选举"></a>服务器启动时期的Leader选举</h3><p> Leader选举的时候，需要注意的是，<strong>隐式条件便是ZooKeeper的集群规模至少是2台机器</strong>，这里我们以3台机器组成的服务器集群为例。在服务器集群初始化阶段，当有一台服务器(我们假设这台机器的myid为1，因此称其为Server1)启动的时候，它是无法完成Leader选举的。当第二胎机器(同样，我们假设这台服务器的myid是2，称其为Server2)也启动后，此时这两台机器已经能够进行互相通信，每台机器都试图找到一个Leader，于是便进入了Leader选举流程。</p>
<ol>
<li><p>每个Server会发出一个投票，由于是初始情况，因此对于Server1和Server2来说，都会将自己作为Leader服务器来进行投票，每次投票包含最基本的元素有：所推举的服务器的myid和ZXID，我们以(myid,ZXID)的形式来表示。因为是初始化阶段，因此无论是Server1还是Server2,都会投给自己，即Server1的投票为(1,0),Server2的投票为(2,0),然后各自将这个投票发给集群中其他所有机器。</p>
</li>
<li><p>接收来自各个服务器的投票，每个服务器都会接收来自其他服务器的投票。集群中的每个服务器在接收到投票后，首先会判断该投票的有效性，包括检查是否是本轮投票，是否来自LOOKING状态的服务器。</p>
</li>
<li><p>处理投票，在接收到来自其他服务器的投票后，针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK的<strong>步骤及处理流程</strong>如下：</p>
<ol>
<li><p>==统计投票==，每次投票后，服务器都会统计所有投票，判断是否已经有过半的及其接收到相同的投票信息。对于Server1和Server2服务器来说，都统计出集群中已经有两台机器接受了(2,0)这个投票信息。这里我们需要对“过半”的概念做一个简单的介绍。所有“过半”就是指大于集群机器数量的一半，即大于或等于(n/2+1)。对于这里由3台机器构成的集群，大于等于2台即为达到“过半”要求。，当<strong>选举票数机器相同</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优先检查ZXID，ZXID比较大的服务器优先作为Leader</span><br><span class="line"></span><br><span class="line">如果ZXID相同的话，那么就比较myid。myid比较大的服务器作为Leader服务器</span><br></pre></td></tr></table></figure>
</li>
<li><p>==改变服务器状态==，一旦确定Leader，每个服务器就会更新自己的状态。如果是Follower，那么就变更为FOLLOWING，如果是Leader，那么就变更为LEADING。</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210303103925.png" alt=""></p>
</li>
</ol>
</li>
</ol>
<h3 id="服务器运行时期的Leader选举"><a href="#服务器运行时期的Leader选举" class="headerlink" title="服务器运行时期的Leader选举"></a>服务器运行时期的Leader选举</h3><p>在Zookeeper集群正常运行过程中，<strong>一旦选出一个Leader，那么所有服务器的集群角色一般不会再发生变化</strong>，也就是说，Leader服务器将一直作为集群的Leader，<strong>即使集群中有非Leader挂了或有新机器加入集群也不会影响Leader</strong>。但是<strong>一旦Leader所在机器挂了，那么整个集群将暂时无法对外提供服务，而是进入新一轮的Leader选举</strong>。服务器运行期间的Leader选举和启动时期的Leader选举基本过程一致的。</p>
<h1 id="ZooKeeper的Watch"><a href="#ZooKeeper的Watch" class="headerlink" title="ZooKeeper的Watch"></a>ZooKeeper的Watch</h1><p>  Zookeeper提供了数据的发布/订阅功能，多个订阅者可同时监听某一特定主题对象，当该主题对象的自身状态发生变化时(例如节点内容改变、节点下的子节点列表改变等)，会实时、主动通知所有订阅者。</p>
<p>  Zookeeper采用了Watcher机制实现数据的发布/订阅功能。该机制在被订阅对象发生变化时会异步通知客户端，因此客户端不必在Watcher注册后轮询阻塞，从而减轻了客户端压力。</p>
<blockquote>
<p>Watcher机制实际上<strong>与观察者模式类似</strong>，也可看作是一种观察者模式在分布式场景下的实现方式。</p>
</blockquote>
<h2 id="watcher架构"><a href="#watcher架构" class="headerlink" title="watcher架构"></a>watcher架构</h2><p>Watcher实现由三个部分组成：</p>
<ul>
<li>Zookeeper服务端；</li>
<li>Zookeeper客户端；</li>
<li>客户端的ZKWatchManager对象；</li>
</ul>
<p>客户端首先将Watcher注册到服务端，同时将Watcher对象保存到客户端的Watch管理器中。当ZooKeeper服务端监听的数据状态发生变化时，服务端会主动通知客户端，接着客户端的Watch管理器会触发相关Watcher来回调相应处理逻辑，从而完成整体的数据发布/订阅流程。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303104435.png" alt="image-20210303104435501"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303104900.webp" alt="img"></p>
<p>此时小红旗是一个watcher，当小红旗被创建并注册到node1节点(会有相应的API实现)后，就会监听node1+node_a+node_b或node_a+node_b。这里两种情况是因为在创建watcher注册时会有多种途径。并且watcher不能监听到孙节点。注意注意注意，watcher设置后，一旦触发一次后就会失效，如果要想一直监听，需要在process回调函数里重新注册相同的 <strong>watcher</strong>。</p>
<h2 id="Watcher特性"><a href="#Watcher特性" class="headerlink" title="Watcher特性"></a>Watcher特性</h2><div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>一次性</td>
<td>Watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册</td>
</tr>
<tr>
<td>客户端顺序回调</td>
<td>Watcher回调是顺序串行化执行的，只有回调后客户端才能看到最新的数据状态。一个Watcher回调逻辑不应该太多，以免影响别的watcher执行</td>
</tr>
<tr>
<td>轻量级</td>
<td>WatchEvent是最小的通信单元，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容；</td>
</tr>
<tr>
<td>时效性</td>
<td>Watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，则watcher依然存在，仍可接收到通知；</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Zookeeper顺序一致性简单验证"><a href="#Zookeeper顺序一致性简单验证" class="headerlink" title="Zookeeper顺序一致性简单验证"></a>Zookeeper顺序一致性简单验证</h1><ol>
<li><p>启动三个1，2，3三个节点(共四个节点)，三个节点已经可以选举出leader</p>
<p> <code>./bin/zkServer.sh start-foreground</code></p>
<p> <strong>节点1日志</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302121105.png" alt="image-20210302121105538"></p>
<p> <strong>节点2日志</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302121316.png" alt="image-20210302121316291"></p>
<p> <strong>节点3日志</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302123647.png" alt="image-20210302123647739"></p>
</li>
<li><p>启动节点4</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302124033.png" alt=""></p>
</li>
<li><p>连接3，4节点并新增数据，会发现cZxid会自增</p>
<p> <code>./bin/zkCli.sh -server 127.0.0.1:12183</code></p>
<p> <code>./bin/zkCli.sh -server 127.0.0.1:12184</code></p>
<p> <code>create -s /ooxx/xxx</code></p>
<p> <code>get -s /ooxx/xxx</code></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302124819.png" alt="image-20210302124819564"></p>
<p> 当进行修改时，会自动在mzxid（该数据节点被修改时最新的事务id）字段加1</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302125027.png" alt="image-20210302125027621"></p>
<p> 4.在此时中断leader进程，并在4节点继续新增相关数据</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302130145.png" alt=""></p>
<p> <strong>mZxid前两次（剩余2个following节点）事务是进行了数据同步，第三次事务才是修改/ooxx节点数据</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302130252.png" alt="image-20210302130252033"></p>
<p> 5.不同客户端创建同一个节点</p>
<p> <strong>leader会在此节点进行递增，不会覆盖创建</strong>，规避数据被覆盖</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302130554.png" alt="image-20210302130554281"></p>
</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302130614.png" alt="image-20210302130614931"></p>
<p>当删除节点重新创建，但是数据名会继续递增（leade内部维护）</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302130920.png" alt="image-20210302130920351"></p>
<h1 id="Zookeeper的应用场景"><a href="#Zookeeper的应用场景" class="headerlink" title="Zookeeper的应用场景"></a>Zookeeper的应用场景</h1><ol>
<li>统一的配置管理  ——————节点下可以存储1M的数据</li>
<li>分组管理              ———————Zookeeper的树结构，可以有多个节点</li>
<li>统一命名              ——————-顺序一致性的能力（不会覆盖数据）</li>
<li>分布式同步          ——————-临时节点<ul>
<li>分布式锁   ————-临时节点下放置分布式锁（session挂掉自动消失，就会释放锁）</li>
<li>带事务(队列形式)的公平锁   ———————在持久的父节点下，建立多个同级同名(create -s  会自动的添加序列)的临时节点（可以持有多把锁），后面的锁盯住前面的锁（01-02-03）</li>
<li>HA,选主（hadoop）</li>
</ul>
</li>
<li>发布订阅</li>
</ol>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 的击穿，穿透，雪崩，分布式锁，缓存一致性</title>
    <url>/posts/8f6adc3b/</url>
    <content><![CDATA[<h5 id="1-Redis-的击穿，穿透，雪崩"><a href="#1-Redis-的击穿，穿透，雪崩" class="headerlink" title="1. Redis 的击穿，穿透，雪崩"></a>1. Redis 的击穿，穿透，雪崩</h5><h6 id="1-1-Redis-击穿"><a href="#1-1-Redis-击穿" class="headerlink" title="1.1 Redis 击穿"></a>1.1 Redis 击穿</h6><p><strong>产生原因</strong>：在高并发的情况下，在某一时间点，<strong>在高频获取的key在此时过期，大量请求直接请求到服务器上</strong>，导致缓存击穿</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>可以将<strong>热点数据设置为永远不过期</strong>；</p>
</li>
<li><p>基于 <strong>redis</strong> or <strong>zookeeper</strong> 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p>
<blockquote>
<p>redis的分布式锁主要是通过  setnx 命令，设置锁的过期时间，只有返回是ok的才能去数据库中获取数据</p>
<p><strong>产生问题</strong>：在db端超时导致锁过期 </p>
<p><strong>解决方案</strong>： 通过<strong>zookeeper</strong> 实现分布式锁</p>
</blockquote>
</li>
</ul>
<h6 id="1-2-Redis穿透"><a href="#1-2-Redis穿透" class="headerlink" title="1.2 Redis穿透"></a>1.2 Redis穿透</h6><p>  一般是出现这种情况是因为恶意频繁查询才会对系统造成很大的问题: <strong>key缓存并且数据库不存在</strong>，所以<strong>每次查询都会查询数据库从而导致数据库崩溃</strong>。</p>
<p><strong>解决方案：</strong>使用布隆过滤器</p>
<blockquote>
<p>布隆过滤器缺点：只能增加不能删除</p>
<p>可使用布谷鸟过滤器 ，设置空key</p>
</blockquote>
<h6 id="1-3-Redis雪崩"><a href="#1-3-Redis雪崩" class="headerlink" title="1.3 Redis雪崩"></a>1.3 Redis雪崩</h6><p>雪崩指的是<strong>多个key</strong>查询并且出现<strong>高并发</strong>，缓存中失效或者查不到，然后都去db查询，从而导致db压力突然飙升，从而崩溃。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>时点性无关:<strong>均匀的设计过期时间</strong></p>
</li>
<li><p>时点性有关:<strong>强依赖击穿的方案</strong></p>
<p>​                    也可在<strong>程序设计的时候在业务层进行时点进行请求延时操作</strong></p>
<p>​                    当知道<strong>时点之后的数据也可以进行预加载工作</strong></p>
</li>
<li><p>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</p>
</li>
<li><p>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</p>
</li>
<li><p>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</p>
<blockquote>
<p>时点性有关指<strong>某一个时间段某些key必须要过期使用新数据</strong></p>
</blockquote>
</li>
</ul>
<h5 id="2-Redis-的分布式锁实现"><a href="#2-Redis-的分布式锁实现" class="headerlink" title="2. Redis  的分布式锁实现"></a>2. Redis  的分布式锁实现</h5><p>最好是使用zookeeper实现分布式锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原理需要三个关键元素</span><br><span class="line">1. setnx</span><br><span class="line">2.过期时间</span><br><span class="line">3.多线程（守护进程），延长过期</span><br></pre></td></tr></table></figure>
<h6 id="2-1-Redis加锁实现"><a href="#2-1-Redis加锁实现" class="headerlink" title="2.1 Redis加锁实现"></a>2.1 Redis加锁实现</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">&quot;NX&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">&quot;PX&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-2-redis-解锁代码"><a href="#2-2-redis-解锁代码" class="headerlink" title="2.2 redis 解锁代码"></a>2.2 redis 解锁代码</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Redis的弊端"><a href="#Redis的弊端" class="headerlink" title="Redis的弊端"></a>Redis的弊端</h6><ul>
<li>数据库事务超时，导致锁过期</li>
<li><code>redis cluster</code>集群环境下，假如现在<code>A客户端</code>想要加锁，它会根据路由规则选择一台<code>master</code>节点写入<code>key</code> <code>mylock</code>，在加锁成功后，<code>master</code>节点会把<code>key</code>异步复制给对应的<code>slave</code>节点。如果此时<code>redis master</code>节点宕机，为保证集群可用性，会进行<code>主备切换</code>，<code>slave</code>变为了<code>redis master</code>。<code>B客户端</code>在新的<code>master</code>节点上加锁成功，而<code>A客户端</code>也以为自己还是成功加了锁的。此时就会导致同一时间内多个客户端对一个分布式锁完成了加锁，导致各种脏数据的产生。</li>
</ul>
<h5 id="Redis-缓存一致性"><a href="#Redis-缓存一致性" class="headerlink" title="Redis 缓存一致性"></a>Redis 缓存一致性</h5><h6 id="出现场景"><a href="#出现场景" class="headerlink" title="出现场景"></a>出现场景</h6><p>在<strong>高并发的情况</strong>下涉及到数据更新：数据库和缓存更新，就容易出现<strong>缓存(Redis)和数据库（MySQL）间的数据一致性问题</strong>。</p>
<p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：</p>
<p>1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p>
<p>2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p>
<p>因为<strong>写和读是并发</strong>的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。</p>
<h6 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h6><p><strong>1.第一种方案：采用延时双删策略</strong></p>
<p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line"> redis.delKey(key);</span><br><span class="line"> db.updateData(data);</span><br><span class="line"> Thread.sleep(<span class="number">500</span>);</span><br><span class="line"> redis.delKey(key);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>具体的步骤就是：</strong></p>
<ul>
<li>先删除缓存；</li>
<li>再写数据库；</li>
<li>休眠500毫秒；</li>
<li>再次删除缓存</li>
</ul>
<p><strong>该方案的弊端</strong></p>
<p>结合<strong>双删策略+缓存超时设置</strong>，这样<strong>最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</strong></p>
<p><strong>2、第二种方案：异步更新缓存(基于订阅binlog的同步机制)</strong></p>
<p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p>
<ul>
<li><strong>读Redis</strong>：热数据基本都在Redis</li>
<li><strong>写MySQL</strong>:增删改都是操作MySQL</li>
<li><strong>更新Redis数据</strong>：MySQ的数据操作binlog，来更新到Redis</li>
</ul>
<p><strong>1）数据操作主要分为两大块：</strong></p>
<ul>
<li>一个是全量(将全部数据一次写入到redis)</li>
<li>一个是增量（实时更新）</li>
</ul>
<p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p>
<p><strong>2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</strong></p>
<p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p>
<p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p>
<p><strong>消息推送工具</strong>你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>redis集群</title>
    <url>/posts/b153a32a/</url>
    <content><![CDATA[<h5 id="1-单节点redis的缺陷"><a href="#1-单节点redis的缺陷" class="headerlink" title="1.单节点redis的缺陷"></a>1.单节点redis的缺陷</h5><ul>
<li>单点故障导致服务不可用</li>
<li>redis的容量优先</li>
<li>redis的服务压力</li>
</ul>
<h5 id="2-集群的AKF原则"><a href="#2-集群的AKF原则" class="headerlink" title="2. 集群的AKF原则"></a>2. 集群的AKF原则</h5><p><a href="https://www.cnblogs.com/-wenli/p/13584796.html">AKF原则</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113708.png" alt="image-20210222095931709"></p>
<blockquote>
<p>x轴：全量，镜像</p>
<p>Y轴：业务，功能</p>
<p>Z轴：优先级，逻辑再拆分</p>
</blockquote>
<h6 id="2-1-redis使用AKF原则扩展为集群产生的问题"><a href="#2-1-redis使用AKF原则扩展为集群产生的问题" class="headerlink" title="2.1 redis使用AKF原则扩展为集群产生的问题"></a>2.1 redis使用AKF原则扩展为集群产生的问题</h6><p>通过AKF一变多 ：<strong>数据一致性问题</strong></p>
<blockquote>
<p>X轴：redis的主从复制</p>
<p>y轴：redis的集群</p>
<p>z轴：redis的集群（根据用户需求）</p>
</blockquote>
<p>​                            </p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113717.png" alt="image-20210222102653774"></p>
<h5 id="3-CAP原则"><a href="#3-CAP原则" class="headerlink" title="3. CAP原则"></a>3. CAP原则</h5><p><a href="https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99/5712863?fr=aladdin">CAP原则百科</a></p>
<p>CAP原则又称CAP定理，指的是在一个分布式系统中，<a href="https://baike.baidu.com/item/一致性/9840083">一致性</a>（Consistency）、<a href="https://baike.baidu.com/item/可用性/109628">可用性</a>（Availability）、<a href="https://baike.baidu.com/item/分区容错性/23734073">分区容错性</a>（Partition tolerance）。CAP 原则指的是，这三个<a href="https://baike.baidu.com/item/要素/5261200">要素</a>最多只能同时实现两点，不可能三者兼顾。</p>
<h5 id="4-Redis的复制（同步）"><a href="#4-Redis的复制（同步）" class="headerlink" title="4. Redis的复制（同步）"></a>4. Redis的复制（同步）</h5><p><a href="http://redis.cn/topics/replication.html">redis的复制</a></p>
<p>Redis使用默认的<strong>异步复制</strong>，其特点是低延迟和高性能，是绝大多数 Redis 用例的自然复制模式。但是，从 Redis 服务器会异步地确认其从主 Redis 服务器周期接收到的数据量。</p>
<blockquote>
<p>主从模式，从节点不支持写入，如果主节点宕机，这个集群就会失去写的能力，不具备自动容错和恢复功能。</p>
<p>redis搭建读写分离的时候，<strong>当连接到从节点发生写操作的时候，命令会默认重定向到主节点去</strong></p>
</blockquote>
<h6 id="4-1-redis复制的重要细节"><a href="#4-1-redis复制的重要细节" class="headerlink" title="4.1. redis复制的重要细节"></a>4.1. redis复制的重要细节</h6><ul>
<li>Redis 使用异步复制，slave 和 master 之间异步地确认处理的数据量</li>
<li>一个 master 可以拥有多个 slave</li>
<li>slave 可以接受其他 slave 的连接。除了多个 slave 可以连接到同一个 master 之外， slave 之间也可以像层叠状的结构（cascading-like structure）连接到其他 slave 。自 Redis 4.0 起，所有的 sub-slave 将会从 master 收到完全一样的复制流。</li>
<li>Redis 复制在 master 侧是非阻塞的。这意味着 master 在一个或多个 slave 进行初次同步或者是部分重同步时，可以继续处理查询请求。</li>
<li>复制在 slave 侧大部分也是非阻塞的。当 slave 进行初次同步时，它可以使用旧数据集处理查询请求，假设你在 redis.conf 中配置了让 Redis 这样做的话。否则，你可以配置如果复制流断开， Redis slave 会返回一个 error 给客户端。但是，在初次同步之后，旧数据集必须被删除，同时加载新的数据集。 slave 在这个短暂的时间窗口内（如果数据集很大，会持续较长时间），会阻塞到来的连接请求。自 Redis 4.0 开始，可以配置 Redis 使删除旧数据集的操作在另一个不同的线程中进行，但是，加载新数据集的操作依然需要在主线程中进行并且会阻塞 slave 。</li>
<li>复制既可以被用在可伸缩性，以便只读查询可以有多个 slave 进行（例如 O(N) 复杂度的慢操作可以被下放到 slave ），或者仅用于数据安全。</li>
<li>可以使用复制来避免 master 将全部数据集写入磁盘造成的开销：一种典型的技术是配置你的 master Redis.conf 以避免对磁盘进行持久化，然后连接一个 slave ，其配置为不定期保存或是启用 AOF。但是，这个设置必须小心处理，因为重新启动的 master 程序将从一个空数据集开始：如果一个 slave 试图与它同步，那么这个 slave 也会被清空。</li>
</ul>
<h6 id="Redis-复制功能的细节过程"><a href="#Redis-复制功能的细节过程" class="headerlink" title="Redis 复制功能的细节过程"></a>Redis 复制功能的细节过程</h6><p>master 开启一个<strong>后台保存进程，以便于生产一个 RDB 文件</strong>。同时它开始缓冲所有从客户端接收到的新的写入命令。当后台保存完成时， master 将数据集文件传输给 slave， slave将之保存在磁盘上，然后加载文件到内存。再然后 master 会发送所有缓冲的命令发给 slave。这个过程以指令流的形式完成并且和 Redis 协议本身的格式相同。</p>
<p>你可以用 telnet 自己进行尝试。在服务器正在做一些工作的同时连接到 Redis 端口并发出 <a href="https://redis.io/commands/sync">SYNC</a> 命令。你将会看到一个批量传输，并且之后每一个 master 接收到的命令都将在 telnet 回话中被重新发出。事实上 SYNC 是一个旧协议，在新的 Redis 实例中已经不再被使用，但是其仍然向后兼容：但它不允许部分重同步，所以现在 <strong>PSYNC</strong> 被用来替代 SYNC。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226145730.png" alt="image-20210226145730728"></p>
<h5 id="5-Redis中哨兵sentinel"><a href="#5-Redis中哨兵sentinel" class="headerlink" title="5. Redis中哨兵sentinel"></a>5. Redis中哨兵sentinel</h5><p><a href="http://redis.cn/topics/sentinel.html">Redis 的 Sentinel 文档</a></p>
<p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p>
<ul>
<li><strong>监控（Monitoring</strong>）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong>： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会<strong>将失效主服务器的其中一个从服务器升级为新的主服务器</strong>， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis Sentinel 是一个<strong>分布式系统</strong>， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用<strong>流言协议（gossip protocols)</strong>来接收关于主服务器是否下线的信息， 并使用<strong>投票协议</strong>（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器</p>
<blockquote>
<p>在此时sentinel集群会在内部先选举出一个leader，然后由这个leader对集群中某个出现问题的主master进行故障迁移（选出从节点当master）</p>
</blockquote>
<h6 id="客观下线和主观下线"><a href="#客观下线和主观下线" class="headerlink" title="客观下线和主观下线"></a>客观下线和主观下线</h6><ul>
<li>主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。</li>
<li>客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）</li>
</ul>
<p>客观下线条件<strong>只适用于主服务器</strong>： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。</p>
<p>从主观下线状态切换到客观下线状态并没有使用严格的法定人数算法（strong quorum algorithm）， 而是使用了<strong>流言协议</strong>： 如果 <strong>Sentinel 在给定的时间范围内， 从其他 Sentinel 那里接收到了足够数量的主服务器下线报告， 那么 Sentinel 就会将主服务器的状态从主观下线改变为客观下线</strong>。 如果之后其他 Sentinel 不再报告主服务器已下线， 那么客观下线状态就会被移除。</p>
<h5 id="6-Redis集群"><a href="#6-Redis集群" class="headerlink" title="6.Redis集群"></a>6.Redis集群</h5><p><a href="http://redis.cn/topics/cluster-tutorial.html">redis集群教程</a></p>
<h6 id="Redis集群的拆分方案"><a href="#Redis集群的拆分方案" class="headerlink" title="Redis集群的拆分方案"></a>Redis集群的拆分方案</h6><ul>
<li>数据可以分类，交集不多</li>
<li>数据没办法拆分,用一致性hash算法进行拆分(redis-cluster)</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226152546.png" alt="image-20210226152546200"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226153455.png" alt="image-20210226153454965"></p>
<h6 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h6><p>希算法就是将任意长度的二进制值映射为较短的固定长度的唯一的二进制值(即哈希值)。敲黑板，哈希算法的入参可以是任意长度，而出参是固定长度而且唯一。一致性哈希算法就是，先构造一个0到2^32的整数环(hash环，java中可用SortedMap实现)，根据缓存服务器名称(也可以是ip:port)计算出hash值，根据其hash值将缓存服务器放置在hash环上。每次根据要缓存的key计算得到hash值，在hash环上顺时针查找距离最近的缓存服务器节点(SortedMap.tailMap(key)实现)，进行set/set操作<br><img src="https://gitee.com/CNRF/image/raw/master/img/20210226153659.png" alt="image-20210226153659880"></p>
<p><strong>一致性hash算法的问题</strong></p>
<p>1.加减缓存服务器节点会造成hash环部分数据无法命中；</p>
<p>2.少量缓存服务器节点时，数据分布不均匀，同时缓存服务器节点变化将影响大范围数据;</p>
<p>3.普通的一致性哈希分区需要增加一倍或减掉一半缓存服务器节点才能保持数据负载均衡；</p>
<p>当只有少量缓存服务器又想尽量保证负载均衡时，我们一般采用下面的办法：将一个缓存服务器节点虚拟成一组，比如某台缓存服务器为192.168.2.1:6379，我们就可以将其虚拟成一个虚拟节点数组，为192.168.2.1:6379-1，192.168.2.1:6379-2，192.168.2.1:6379-3……然后分别计算数组里的元素的hash值并映射到hash环上，每台缓存服务器都如此处理。当不同key的缓存路由到虚拟节点时，最终都是指向真实的缓存服务器节点。通过这样增加节点的方式，可以一定概率上使数据路由均衡</p>
<h6 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis-cluster"></a>redis-cluster</h6><p> Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p> 其结构特点：</p>
<p>1、所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。</p>
<p> 2、节点的fail是通过集群中超过半数的节点检测失效时才生效。</p>
<p> 3、客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</p>
<p> 4、redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value。</p>
<p> 5、Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。</p>
<p><strong>a.redis cluster节点分配</strong><br> 现在我们是三个主节点分别是：A, B, C 三个节点，它们可以是一台机器上的三个端口，也可以是三台不同的服务器。那么，采用哈希槽 (hash slot)的方式来分配16384个slot 的话，它们三个节点分别承担的slot 区间是：</p>
<ul>
<li><p>节点A覆盖0－5460;</p>
</li>
<li><p>节点B覆盖5461－10922;</p>
</li>
<li><p>节点C覆盖10923－16383.</p>
<p>  获取数据:<br>   如果存入一个值，按照redis cluster哈希槽的<a href="http://lib.csdn.net/base/datastructure">算法</a>： CRC16(‘key’)384 = 6782。 那么就会把这个key 的存储分配到 B 上了。同样，当我连接(A,B,C)任何一个节点想获取’key’这个key时，也会这样的算法，然后内部跳转到B节点上获取数据</p>
<p>  新增一个主节点:<br>   新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上，我会在接下来的实践中实验。大致就会变成这样：</p>
</li>
<li><p>节点A覆盖1365-5460</p>
</li>
<li><p>节点B覆盖6827-10922</p>
</li>
<li><p>节点C覆盖12288-16383</p>
</li>
<li><p>节点D覆盖0-1364,5461-6826,10923-12287</p>
</li>
</ul>
<p>同样删除一个节点也是类似，移动完成后就可以删除这个节点了。</p>
<p><strong>b.Redis Cluster主从模式</strong><br> redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉</p>
<p>上面那个例子里, 集群有ABC三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了。A和C的slot也无法访问。</p>
<p>所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像这样, 集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。</p>
<p>B1节点替代了B节点，所以Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。</p>
<p>不过需要注意，如果<strong>节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了</strong>。</p>
<h5 id="8-Redis集群的代理"><a href="#8-Redis集群的代理" class="headerlink" title="8.Redis集群的代理"></a>8.Redis集群的代理</h5><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226154729.png" alt="image-20210226154729661"></p>
<p><a href="https://blog.csdn.net/qq_34944535/article/details/106803261?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.control&amp;dist_request_id=46a127bd-e7dd-4660-b485-d998c0726304&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.control">redis cluster代理</a></p>
<p>目前市面上主流的代理包含：predixy、twemproxy、codis、redis-cerberus四款，这四款各有各的优势，我们逐个对比进行对比分析。</p>
<div class="table-box"><table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td><strong>特性</strong></td><td><strong>predixy</strong></td><td><strong>twemproxy</strong></td><td><strong>codis</strong></td><td><strong>redis-cerberus</strong></td></tr><tr><td>高可用</td><td>Redis Sentinel或Redis Cluster</td><td>一致性哈希</td><td>Redis Sentinel</td><td>Redis Cluster</td></tr><tr><td>可扩展</td><td>Key哈希分布或Redis Cluster</td><td>Key哈希分布</td><td>Key哈希分布</td><td>Redis Cluster</td></tr><tr><td>开发语言</td><td>C++</td><td>C</td><td>GO</td><td>C++</td></tr><tr><td>多线程</td><td>是</td><td>否</td><td>是</td><td>是</td></tr><tr><td>事务</td><td>Redis Sentinel模式单Redis组下支持</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>BLPOP/BRPOP/BLPOPRPUSH</td><td>支持</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>Pub/Sub</td><td>支持</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>Script</td><td>支持load</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>Scan</td><td>支持</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>Select DB</td><td>支持</td><td>不支持</td><td>支持</td><td>Redis Cluster只有一个DB</td></tr><tr><td>Auth</td><td>支持定义多个密码，给予不同读写及管理权限和Key访问空间</td><td>不支持</td><td>同redis</td><td>不支持</td></tr><tr><td>读从节点</td><td>支持，可定义丰富规则读指定的从节点</td><td>不支持</td><td>支持，简单规则</td><td>支持，简单规则</td></tr><tr><td>多机房支持</td><td>支持，可定义丰富规则调度流量</td><td>不支持</td><td>有限支持</td><td>有限支持</td></tr><tr><td>统计信息</td><td>丰富</td><td>丰富</td><td>丰富</td><td>简单</td></tr></tbody></table></div>

]]></content>
      <categories>
        <category>Redis</category>
        <category>一致性Hash算法</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>一致性Hash算法</tag>
      </tags>
  </entry>
  <entry>
    <title>redis持久化</title>
    <url>/posts/dcfaa904/</url>
    <content><![CDATA[<h5 id="1-redis的持久化方式"><a href="#1-redis的持久化方式" class="headerlink" title="1. redis的持久化方式"></a>1. redis的持久化方式</h5><ol>
<li><p>RDB持久化</p>
<p> 原理是将<strong>Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化</strong></p>
</li>
<li><p>AOF持久化</p>
<p>原理是将<strong>Reids的操作日志以追加的方式写入文件</strong></p>
<p><a href="https://www.cnblogs.com/zxs117/p/11242026.html">两种持久化方式区别</a></p>
<p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。不过生产环境其实更多都是二者结合使用的。</p>
</li>
</ol>
<h5 id="2-RDB持久化"><a href="#2-RDB持久化" class="headerlink" title="2.RDB持久化"></a>2.RDB持久化</h5><p><strong>原理</strong> :在liunx系统系统中，<strong>进程之间的数据是隔离的</strong>，在使用export的环境变量，<strong>父子进程的修改都不会影响到其他进程的数据</strong></p>
<p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是<strong>fork一个子进程</strong>，先将<strong>数据集写入临时文件</strong>，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303093740.png" alt=""></p>
<h6 id="2-1-RDB的优缺点"><a href="#2-1-RDB的优缺点" class="headerlink" title="2.1 RDB的优缺点"></a>2.1 RDB的优缺点</h6><p><strong>优点</strong>： </p>
<ol>
<li><strong>还原速度快</strong>（类似java的对象序列化，可快速还原）</li>
<li><strong>整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的</strong>。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li>
</ol>
<p><strong>弊端</strong>：</p>
<ol>
<li>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么<strong>RDB将不是一个很好的选择。因为系统一旦在定时持久化完成之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失</strong>。</li>
<li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，<strong>如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</strong></li>
</ol>
<blockquote>
<p>fork命令只是创建进程，并不会在此时进行复制，因此创建进程的速度变快</p>
<p>fork出来的父子进程具有 <strong>相同但是独立的地址空间</strong>因为父进程和子进程是独立的进程，他们都有自己私有的地址空间，当父进程或者子进程单独改变时，不会影响到彼此，类似于c++的写实拷贝的形式自建一个副本</p>
<p><a href="https://blog.csdn.net/weixin_40853073/article/details/81873398?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;dist_request_id=4254810a-f10f-43c5-8965-6b775b5a3682&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">fork命令详细说明</a></p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113700.png" alt="image-20210221233300160"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303093910.png" alt="image-20210303093910862"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226151043.png" alt="image-20210226151042967"></p>
<h5 id="3-AOF持久化"><a href="#3-AOF持久化" class="headerlink" title="3. AOF持久化"></a>3. AOF持久化</h5><p>AOF持久化以<strong>日志的形式</strong>记录服务器所处理的<strong>每一个写、删除操作</strong>，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p>
<blockquote>
<p>当redis同时开启RDB和AOF备份，redis恢复是只会依据AOF的备份（AOF的数据丢失较少）</p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113653.png" alt="image-20210221233312115"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226151129.png" alt="image-20210226151129085"></p>
<h6 id="3-1-AOF的优缺点"><a href="#3-1-AOF的优缺点" class="headerlink" title="3.1 AOF的优缺点"></a>3.1 AOF的优缺点</h6><p><strong>优点</strong>：</p>
<p>1). 该机制可以带来<strong>更高的数据安全性，即数据持久性</strong>。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。</p>
<p>2). 由于该机制对日志文件的<strong>写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容</strong>。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以<strong>通过redis-check-aof工具来帮助我们解决数据一致性的问题。</strong></p>
<p>3). 如果<strong>日志过大，Redis可以自动启用rewrite机制</strong>。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</p>
<blockquote>
<p>redis4.0以前：rewrite其实是删除抵消的命令（创建和删除），合并重复的命名。最终会生成重复命令</p>
<p>redis4.0以后：将老的数据RDB到AOF中，将增量的以指令的方式append到aof中（实际就是混合RDB+AOF的持久化方式）</p>
</blockquote>
<p>4). <strong>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建</strong>。</p>
<p><strong>缺点</strong>：</p>
<p>1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。<strong>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</strong></p>
<p>2). 根据同步策略的不同，<strong>AOF在运行效率上往往会慢于RDB</strong>。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的消息订阅，pipeline，事务</title>
    <url>/posts/d09e787/</url>
    <content><![CDATA[<h5 id="1-Redis-管道（Pipelining）"><a href="#1-Redis-管道（Pipelining）" class="headerlink" title="1.Redis 管道（Pipelining）"></a>1.Redis 管道（Pipelining）</h5><p><a href="http://redis.cn/topics/pipelining.html">Redis 管道（Pipelining）</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113641.png" alt="image-20210220103817162"></p>
<p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将<em>多个命令</em>发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
<p><strong>重要说明</strong>: 使用管道发送命令时，服务器将被迫回复一个队列答复，占用很多内存。如果需要发送大量的命令，最好是按照合理数量分批次的处理，例如10K的命令，读回复，然后再发送另一个10k的命令，等等。这样速度几乎是相同的，但是在回复这10k命令队列需要非常大量的内存用来组织返回数据内容。</p>
<h5 id="2-redis的消息订阅"><a href="#2-redis的消息订阅" class="headerlink" title="2. redis的消息订阅"></a>2. redis的消息订阅</h5><p><a href="http://redis.cn/topics/pubsub.html">redis的消息订阅</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303110111.png" alt="redis发布订阅过程"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUBLISH  &#x2F;&#x2F;发布消息</span><br><span class="line">SUBSCRIBE foo bar</span><br><span class="line">SUBSCRIBE  &#x2F;&#x2F;接收指定队列消息</span><br><span class="line">SUBSCRIBE foo</span><br></pre></td></tr></table></figure>
<h5 id="3-redis的事务"><a href="#3-redis的事务" class="headerlink" title="3. redis的事务"></a>3. redis的事务</h5><p><a href="http://redis.cn/topics/transactions.html">redis的事务</a></p>
<p><a href="http://redis.cn/commands/multi.html">MULTI</a> 、 <a href="http://redis.cn/commands/exec.html">EXEC</a> 、 <a href="http://redis.cn/commands/discard.html">DISCARD</a> 和 <a href="http://redis.cn/commands/watch.html">WATCH</a> 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<p><a href="http://redis.cn/commands/exec.html">EXEC</a> 命令负责触发并执行事务中的所有命令：</p>
<ul>
<li><p>如果客户端在使用 <a href="http://redis.cn/commands/multi.html">MULTI</a> 开启了一个事务之后，却因为断线而没有成功执行 <a href="http://redis.cn/commands/exec.html">EXEC</a> ，那么事务中的所有命令都不会被执行。</p>
</li>
<li><p>另一方面，如果客户端成功在开启事务之后执行 <a href="http://redis.cn/commands/exec.html">EXEC</a> ，那么事务中的所有命令都会被执行</p>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210303101618.png" alt=""></p>
<blockquote>
<p>开启事务，修改k2 的值，但是<font  color=red>没有进行事务的提交，导致修改不成功</font></p>
</blockquote>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210303102359.png" alt="image-20210303102359486"></p>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210303102525.png" alt=""></p>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210303102720.png" alt=""></p>
<blockquote>
<p>由于redis是单线程，当<font  color=red>2的事务(exec)先到达，则先回执行2的事务，则事务1无法获取到k1的值</font></p>
<p>当<font  color=red>1的事务(exec)先到达，则先回执行1的事务，则事务1能获取到k1的值</font></p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>AOF 方式做持久化</code>的时候，Redis 会使用单个 write(2) 命令将事务写入到磁盘中。然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p>
<p>Redis (2.2版本开始)还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作</p>
</blockquote>
<h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><p><a href="http://redis.cn/commands/multi.html">MULTI</a> 命令用于开启一个事务，它总是返回 <code>OK</code> 。 <a href="http://redis.cn/commands/multi.html">MULTI</a> 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 <a href="http://redis.cn/commands/exec.html">EXEC</a>命令被调用时， 所有队列中的命令才会被执行。</p>
<p>另一方面， 通过调用 <a href="http://redis.cn/commands/discard.html">DISCARD</a> ， 客户端可以清空事务队列， 并放弃执行事务。</p>
<p>以下是一个事务例子， 它原子地增加了 <code>foo</code> 和 <code>bar</code> 两个键的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br></pre></td></tr></table></figure>
<p><a href="http://redis.cn/commands/exec.html">EXEC</a> 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。</p>
<p>当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 <code>QUEUED</code> 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行</p>
<h6 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h6><ul>
<li>事务在执行 <a href="http://redis.cn/commands/exec.html">EXEC</a> 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 <code>maxmemory</code> 设置了最大内存限制的话）。</li>
<li>命令可能在 <a href="http://redis.cn/commands/exec.html">EXEC</a> 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。</li>
</ul>
<p>服务器会对命令入队失败的情况进行记录，并在客户端调用 <a href="http://redis.cn/commands/exec.html">EXEC</a> 命令时，<strong>拒绝执行并自动放弃这个事务</strong>。</p>
<h6 id="Redis-不支持回滚（roll-back）原因"><a href="#Redis-不支持回滚（roll-back）原因" class="headerlink" title="Redis 不支持回滚（roll back）原因"></a>Redis 不支持回滚（roll back）原因</h6><ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，<strong>失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中</strong>。</li>
<li>因为<strong>不需要对回滚进行支持</strong>，所以 Redis 的内部可以保持<strong>简单且快速</strong>。</li>
</ul>
<h5 id="4-布隆过滤器"><a href="#4-布隆过滤器" class="headerlink" title="4.布隆过滤器"></a>4.布隆过滤器</h5><p><a href="https://github.com/RedisBloom/RedisBloom">第三方实现的redis的布隆过滤器</a></p>
<h6 id="redis添加过滤器的意义"><a href="#redis添加过滤器的意义" class="headerlink" title="redis添加过滤器的意义"></a>redis添加过滤器的意义</h6><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303094333.png" alt="image-20210303094333858"></p>
<h6 id="redis的布隆过滤器实现"><a href="#redis的布隆过滤器实现" class="headerlink" title="redis的布隆过滤器实现"></a>redis的布隆过滤器实现</h6><ol>
<li>Client自己承载，<strong>实现bloom算法并承载bitmap</strong></li>
<li>Client实现bloom算法，对应redis的bitmap</li>
<li>redis安装bloom插件</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303094514.png" alt="image-20210303094514053"></p>
<blockquote>
<p>第三方实现redis的相关功能： <a href="https://redis.io/modules">https://redis.io/modules</a></p>
</blockquote>
<h5 id="5-redis的LRU（Least-Recently-Used）淘汰策略"><a href="#5-redis的LRU（Least-Recently-Used）淘汰策略" class="headerlink" title="5.redis的LRU（Least Recently Used）淘汰策略"></a>5.redis的LRU（Least Recently Used）淘汰策略</h5><p><a href="http://redis.cn/topics/lru-cache.html">将redis当做使用LRU算法的缓存来使用</a></p>
<p><strong>LRU是Redis唯一支持的回收方法</strong>，Redis的<code>maxmemory</code>指令用于将可用内存限制成一个固定大小，还包括了Redis使用的LRU算法，这个实际上只是近似的LRU。</p>
<p><strong>Redis的LRU算法并非完整的实现</strong>。这意味着<strong>Redis并没办法选择最佳候选来进行回收</strong>，也就是最久未被访问的键。相反它会尝试运行一个近似LRU的算法，<strong>通过对少量keys进行取样，然后回收其中一个最好的key（被访问时间较早的）</strong>。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303094057.png" alt=""></p>
<h6 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h6><p>以下的策略是可用的:</p>
<ul>
<li><strong>noeviction</strong>:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</li>
<li><strong>allkeys-lru</strong>: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</li>
<li><strong>volatile-lru</strong>: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</li>
<li><strong>allkeys-random</strong>: 回收随机的键使得新添加的数据有空间存放。</li>
<li><strong>volatile-random</strong>: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li>
<li><strong>volatile-ttl</strong>: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</li>
</ul>
<h6 id="回收进程如何工作"><a href="#回收进程如何工作" class="headerlink" title="回收进程如何工作"></a><strong>回收进程如何工作</strong></h6><p>理解回收进程如何工作是非常重要的:</p>
<ul>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ul>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis快的原因</title>
    <url>/posts/400dad18/</url>
    <content><![CDATA[<h1 id="Liunx的IO"><a href="#Liunx的IO" class="headerlink" title="Liunx的IO"></a>Liunx的IO</h1><h1 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h1><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<br>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303092341.png" alt="image-20210303092341779"></p>
<h1 id="non-blocking-IO"><a href="#non-blocking-IO" class="headerlink" title="non-blocking IO"></a>non-blocking IO</h1><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303093047.png" alt="image-20210303093047688"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303092823.png" alt="image-20210303092823060"></p>
<p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<br>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。</p>
<h1 id="多路复用NIO"><a href="#多路复用NIO" class="headerlink" title="多路复用NIO"></a>多路复用NIO</h1><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303093109.png" alt="image-20210303093109692"></p>
<h3 id="Liunx的IO演变"><a href="#Liunx的IO演变" class="headerlink" title="Liunx的IO演变"></a>Liunx的IO演变</h3><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303093222.png" alt="image-20210303093222430"></p>
<h1 id="Redis中IO"><a href="#Redis中IO" class="headerlink" title="Redis中IO"></a>Redis中IO</h1><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210303102906.png" alt="image-20210303102906808"></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>win10添加新建文件md方式以及设置md模版</title>
    <url>/posts/558e0cc4/</url>
    <content><![CDATA[<p><strong><em>务必先创建系统还原点或者备份注册表</em></strong></p>
<h1 id="添加新建方式步骤"><a href="#添加新建方式步骤" class="headerlink" title="添加新建方式步骤"></a>添加新建方式步骤</h1><p>新建<code>temp.txt</code>输入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@&#x3D;&quot;.md&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;&#x3D;&quot;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>把<code>temp.txt</code>改名为<code>temp.reg</code></p>
</li>
<li><p>双击运行，就ok了，有问题记得先重启，如果不行，就采用下面这个</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@&#x3D;&quot;typora.md&quot;</span><br><span class="line">&quot;icon&quot;&#x3D;&quot;E:\\Typora\\bin\\typora.exe&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\OpenWithProgids]</span><br><span class="line">&quot;Typora.md&quot;&#x3D;&quot;&quot;</span><br><span class="line">&quot;VSCode.md&quot;&#x3D;&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;&#x3D;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="配置md文件模版"><a href="#配置md文件模版" class="headerlink" title="配置md文件模版"></a>配置md文件模版</h1><p>1、使用<code>notepad++</code>新建<code>新建 Markdown.md</code>文件，填入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">tags: []</span><br><span class="line">categories:</span><br><span class="line">- []</span><br><span class="line">- []</span><br><span class="line">description: </span><br><span class="line">updated: </span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>将文件移动到不会<strong>轻易删除的文件夹</strong></p>
<p>打开注册表，按如下(没有就创建)</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226105517.png" alt="image-20210226105516945"></p>
]]></content>
      <categories>
        <category>Typora</category>
        <category>Win10</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Win10</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+NexT博客归档/标签/分类页美化</title>
    <url>/posts/be9758cd/</url>
    <content><![CDATA[<p>NexT自带的<code>归档</code>、<code>标签</code>、<code>分类</code>页的样式比较单一，我们可以在样式文件中添加一些<code>css</code>配置来将我们想要的样式添加到这些页面中，本文就来介绍如何添加或修改这些页面的样式。</p>
<h1 id="彩色标签页"><a href="#彩色标签页" class="headerlink" title="彩色标签页"></a>彩色标签页</h1><ol>
<li>在 /themes/next/layout/ 目录下，新增 tag-color.swig 文件，填入如下内容:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">     var alltags &#x3D; document.getElementsByClassName(&#39;tag-cloud-tags&#39;);</span><br><span class="line">     var tags &#x3D; alltags[0].getElementsByTagName(&#39;a&#39;);</span><br><span class="line">     for (var i &#x3D; tags.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">       var r&#x3D;Math.floor(Math.random()*75+130);</span><br><span class="line">       var g&#x3D;Math.floor(Math.random()*75+100);</span><br><span class="line">       var b&#x3D;Math.floor(Math.random()*75+80);</span><br><span class="line">       tags[i].style.background &#x3D; &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    &#x2F;*font-family: Helvetica, Tahoma, Arial;*&#x2F;</span><br><span class="line">    &#x2F;*font-weight: 100;*&#x2F;</span><br><span class="line">    text-align: center;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a&#123;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin: 8px 5px 0px 0px;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a:before&#123;</span><br><span class="line">    content: &quot;🔖&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags a:hover&#123;</span><br><span class="line">     box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4);</span><br><span class="line">     transform: scale(1.1);</span><br><span class="line">     &#x2F;*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*&#x2F;</span><br><span class="line">     transition-duration: 0.15s;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>在同级目录的 page.swig 中引入 tag-color.swig</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tag-cloud&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 目前共计xxx个标签</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tag-cloud-title&quot;</span>&gt;</span><br><span class="line">            &#123;&#123; _p(<span class="string">&#x27;counter.tag_cloud&#x27;</span>, site.tags.length) &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        --&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tag-cloud-tags&quot;</span>&gt;</span><br><span class="line">          &#123;&#123; tagcloud(&#123;<span class="attr">min_font</span>: <span class="number">10</span>, <span class="attr">max_font</span>: <span class="number">15</span>, <span class="attr">amount</span>: <span class="number">300</span>, <span class="attr">color</span>: <span class="literal">true</span>, <span class="attr">start_color</span>: <span class="string">&#x27;#ccc&#x27;</span>, <span class="attr">end_color</span>: <span class="string">&#x27;#111&#x27;</span>&#125;) &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">+     &#123;% include <span class="string">&#x27;tag-color.swig&#x27;</span> %&#125;</span><br><span class="line">    </span><br><span class="line">    &#123;% elif page.type === <span class="string">&#x27;categories&#x27;</span> %&#125;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;category-all-page&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;category-all-title&quot;</span>&gt;</span><br><span class="line">            &#123;&#123; _p(<span class="string">&#x27;counter.categories&#x27;</span>, site.categories.length) &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;category-all&quot;</span>&gt;</span><br><span class="line">          &#123;&#123; list_categories() &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>以下是文章底部的标签样式（代码拷入 /themes/next/source/css/_schemes/(自己选择的主题)/index.styl 即可）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*文章底部标签样式*&#x2F;</span><br><span class="line">.posts-expand .post-tags a &#123;</span><br><span class="line">  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, .12), 0 1px 2px rgba(0, 0, 0, .24);</span><br><span class="line">  -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, .12), 0 1px 2px rgba(0, 0, 0, .24);</span><br><span class="line">  box-shadow: 0 1px 3px rgba(0, 0, 0, .12), 0 1px 2px rgba(0, 0, 0, .24);</span><br><span class="line">  font-family: &#39;Comic Sans MS&#39;, sans-serif;</span><br><span class="line">  transition: .2s ease-out;</span><br><span class="line">  padding: 3px 5px;</span><br><span class="line">  margin: 5px;</span><br><span class="line">  background: #f5f5f5;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-radius: 15px;</span><br><span class="line"></span><br><span class="line">  +mobile()&#123;</span><br><span class="line">    padding: 1px 3px;</span><br><span class="line">    font-size: 8px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    background: rgba(100,154,182,0.902);</span><br><span class="line">    color: #fff;</span><br><span class="line">    -webkit-box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);</span><br><span class="line">    -moz-box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);</span><br><span class="line">    box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现效果如下：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226130811.png" alt="image-20210226130811067"></p>
<h1 id="归档页美化"><a href="#归档页美化" class="headerlink" title="归档页美化"></a>归档页美化</h1><ol>
<li>修改 /themes/next/ layout/_ macro/post collapse.swig 后的代码如下:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% macro render(posts) %&#125;</span><br><span class="line">&#123;%- set current_year &#x3D; &#39;1970&#39; %&#125;</span><br><span class="line">&#123;%- for post in posts.toArray() %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- set year &#x3D; date(post.date, &#39;YYYY&#39;) %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- if year !&#x3D;&#x3D; current_year %&#125;</span><br><span class="line">    &#123;%- set current_year &#x3D; year %&#125;</span><br><span class="line">    &lt;div class&#x3D;&quot;collection-year&quot;&gt;</span><br><span class="line">      &lt;&#123;%- if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;%- endif %&#125; class&#x3D;&quot;collection-header&quot;&gt;&#123;&#123; current_year &#125;&#125;&lt;&#x2F;&#123;%- if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;%- endif %&#125;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;article class&#x3D;&quot;my-post post-type-&#123;&#123; post.type | default(&#39;normal&#39;) &#125;&#125;&quot; itemscope itemtype&#x3D;&quot;http:&#x2F;&#x2F;schema.org&#x2F;Article&quot;&gt;</span><br><span class="line">    &lt;header class&#x3D;&quot;my-post-header&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div class&#x3D;&quot;my-post-meta&quot;&gt;</span><br><span class="line">        &lt;time class&#x3D;&quot;my-post-time&quot; itemprop&#x3D;&quot;dateCreated&quot;</span><br><span class="line">              datetime&#x3D;&quot;&#123;&#123; moment(post.date).format() &#125;&#125;&quot;</span><br><span class="line">              content&#x3D;&quot;&#123;&#123; date(post.date, config.date_format) &#125;&#125;&quot;&gt;</span><br><span class="line">          &#123;&#123; date(post.date, &#39;MM-DD&#39;) &#125;&#125;</span><br><span class="line">        &lt;&#x2F;time&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;&#123;%- if theme.seo %&#125;h3&#123;% else %&#125;h2&#123;%- endif %&#125; class&#x3D;&quot;my-post-title&quot;&gt;</span><br><span class="line">        &#123;%- if post.link %&#125;&#123;# Link posts #&#125;</span><br><span class="line">          &lt;a class&#x3D;&quot;my-post-title-link post-title-link-external&quot; target&#x3D;&quot;_blank&quot; href&#x3D;&quot;&#123;&#123; url_for(post.link) &#125;&#125;&quot; itemprop&#x3D;&quot;url&quot;&gt;</span><br><span class="line">            &#123;&#123; post.title or post.link &#125;&#125;</span><br><span class="line">            &lt;i class&#x3D;&quot;fa fa-external-link&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">          &lt;&#x2F;a&gt;</span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">          &lt;a class&#x3D;&quot;my-post-title-link&quot; href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; itemprop&#x3D;&quot;url&quot;&gt;</span><br><span class="line">            &#123;% if post.type &#x3D;&#x3D;&#x3D; &#39;picture&#39; %&#125;</span><br><span class="line">              &#123;&#123; post.content &#125;&#125;</span><br><span class="line">            &#123;% else %&#125;</span><br><span class="line">              &lt;span itemprop&#x3D;&quot;name&quot;&gt;&#123;&#123; post.title or __(&#39;post.untitled&#39;) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">          &lt;&#x2F;a&gt;</span><br><span class="line">        &#123;%- endif %&#125;</span><br><span class="line">      &lt;&#x2F;&#123;%- if theme.seo %&#125;h3&#123;% else %&#125;h2&#123;%- endif %&#125;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;header&gt;</span><br><span class="line">  &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">&#123;%- endfor %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure>
<p>主要修改：一是将 post-meta这个div移到前面header 标签下；二是将所有的 class 属性都加上 my-，例如 my-post-meta，这样改动是为了不影响其它页面引用的样式。</p>
<ol>
<li>在 /themes/next/source/css/_schemes/(自己选择的主题)/index.styl 新增如下样式：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 归档页样式 began *&#x2F;</span><br><span class="line">.page-archive .archive-page-counter &#123;</span><br><span class="line">  font-size: 18px;</span><br><span class="line">  background-color: #49b1f5;</span><br><span class="line">  padding-left: 10px;</span><br><span class="line">  padding-right: 10px;</span><br><span class="line">  border-radius: 8px;</span><br><span class="line">  color: #fff;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.my-post-time&#123;</span><br><span class="line">  font-size: 11px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  color: #fff;</span><br><span class="line">  background-color: #49b1f5;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">  padding-left: 5px;</span><br><span class="line">  padding-right: 5px;</span><br><span class="line">  margin-left: 15px;</span><br><span class="line">&#125;</span><br><span class="line">.mypost&#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  margin-bottom: 1rem;</span><br><span class="line">  -webkit-transition: all .2s ease-in-out;</span><br><span class="line">  -moz-transition: all .2s ease-in-out;</span><br><span class="line">  -o-transition: all .2s ease-in-out;</span><br><span class="line">  -ms-transition: all .2s ease-in-out;</span><br><span class="line">  transition: all .2s ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line">a.my-post-title-link:before&#123;</span><br><span class="line">  top: 10px;</span><br><span class="line">  width: 18px;</span><br><span class="line">  height: 18px;</span><br><span class="line">  content: &quot;📚&quot;;</span><br><span class="line">  margin-right: 5px;</span><br><span class="line">  font: normal normal normal 14px&#x2F;1 FontAwesome;</span><br><span class="line">  font-size: 15px;</span><br><span class="line">  line-height: 18px;</span><br><span class="line">&#125;</span><br><span class="line">.my-post:hover&#123;</span><br><span class="line">  transform: scale(1.1);</span><br><span class="line">  box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);</span><br><span class="line">  border-radius: 30px;</span><br><span class="line">  width: 400px;</span><br><span class="line">  padding: 1px 10px;</span><br><span class="line">  margin-left: 25px;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  transition-duration: 0.15s;</span><br><span class="line">  +mobile()&#123;</span><br><span class="line">    width: 260px;</span><br><span class="line">    margin-left: 18px;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;display:flex;</span><br><span class="line">&#125;</span><br><span class="line">a.my-post-title-link&#123;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  font-size: 15px;</span><br><span class="line">  font-weight: 400;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.my-post-title&#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin-left: 4.5rem;</span><br><span class="line">  color: #4c4948;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  font-size: .8rem;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    &#x2F;&#x2F;margin-left: 4rem;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.my-post-header&#123;</span><br><span class="line">  position: top;</span><br><span class="line">  margin-bottom: 1rem;</span><br><span class="line">  -webkit-transition: all .2s ease-in-out;</span><br><span class="line">  -moz-transition: all .2s ease-in-out;</span><br><span class="line">  -o-transition: all .2s ease-in-out;</span><br><span class="line">  -ms-transition: all .2s ease-in-out;</span><br><span class="line">  transition: all .2s ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;.my-post-title-link&#123;</span><br><span class="line">&#x2F;&#x2F;  font-size: 16px;</span><br><span class="line">&#x2F;&#x2F;  font-weight: 500;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">.my-post-meta&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  color: #99a9bf;</span><br><span class="line">  width: 80px;</span><br><span class="line">  color: #114142;</span><br><span class="line">&#125;</span><br><span class="line">div.post-block.tag .collection-title h2 &#123;</span><br><span class="line">  border-width: 1px;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: #3f3f3f;</span><br><span class="line">  border-radius: 20px;</span><br><span class="line">  font-size: 22px;</span><br><span class="line">  background-color: #b4e8fa;</span><br><span class="line">  padding: 2px 15px;</span><br><span class="line">  letter-spacing: 1.5px;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  color: #3f3f3f;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin: 10px 0 10px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  +mobile()&#123;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 归档页样式 end *&#x2F;</span><br></pre></td></tr></table></figure>
<p>实现效果如下：</p>
<p><a href="https://img-blog.csdnimg.cn/20200720163209724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTY5Mzgz,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200720163209724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTY5Mzgz,size_16,color_FFFFFF,t_70" alt="img"></a></p>
<h1 id="分类页美化"><a href="#分类页美化" class="headerlink" title="分类页美化"></a>分类页美化</h1><p>在 /themes/next/source/css/_schemes/(自己选择的主题)/index.styl 新增如下样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 分类页样式 began *&#x2F;</span><br><span class="line">.category-list-link:hover&#123;</span><br><span class="line">  transform: scale(1.1);</span><br><span class="line">  box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);</span><br><span class="line">  border-radius: 15px;</span><br><span class="line">  padding: 6px 16px;</span><br><span class="line">  margin-left: 0px;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  transition-duration: 0.15s;</span><br><span class="line">  &#x2F;&#x2F;display:flex;</span><br><span class="line">&#125;</span><br><span class="line">a.category-list-link:before&#123;</span><br><span class="line">  top: 10px;</span><br><span class="line">  width: 18px;</span><br><span class="line">  height: 18px;</span><br><span class="line">  content: &quot;📚&quot;;</span><br><span class="line">  margin-right: 5px;</span><br><span class="line">  font: normal normal normal 14px&#x2F;1 FontAwesome;</span><br><span class="line">  font-size: 15px;</span><br><span class="line">  line-height: 18px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 分类页样式 end *&#x2F;</span><br></pre></td></tr></table></figure>
<p>实现效果如下：</p>
<p><a href="https://img-blog.csdnimg.cn/20200720172136778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTY5Mzgz,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200720172136778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTY5Mzgz,size_16,color_FFFFFF,t_70" alt="img"></a></p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/posts/f7de8aa8/</url>
    <content><![CDATA[<h1 id="外观模式的定义与特点"><a href="#外观模式的定义与特点" class="headerlink" title="外观模式的定义与特点"></a>外观模式的定义与特点</h1><p>外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。<font color=red>该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</font></p>
<h1 id="外观模式的优缺点"><a href="#外观模式的优缺点" class="headerlink" title="外观模式的优缺点"></a>外观模式的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>不能很好地限制客户使用子系统类，很容易带来未知风险。</li>
<li>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</li>
</ol>
<h1 id="外观模式的应用场景"><a href="#外观模式的应用场景" class="headerlink" title="外观模式的应用场景"></a>外观模式的应用场景</h1><ol>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问</li>
<li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li>
</ol>
<h1 id="外观模式的结构与实现"><a href="#外观模式的结构与实现" class="headerlink" title="外观模式的结构与实现"></a>外观模式的结构与实现</h1><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。</p>
<h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>外观（Facade）模式包含以下主要角色。</p>
<ol>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
<li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210305110932.png" alt="外观（Facade）模式的结构图"></p>
<h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><p>外观角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 外观模式;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeMaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Shape circle;</span><br><span class="line">    <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">    <span class="keyword">private</span> Shape square;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeMaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        square = <span class="keyword">new</span> Square();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        circle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSquare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        square.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子系统角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 外观模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 外观模式;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wmx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/5 11:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 外观模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rectangle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 外观模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>客户角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 外观模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeMaker shapeMaker = <span class="keyword">new</span> ShapeMaker();</span><br><span class="line">        shapeMaker.drawCircle();</span><br><span class="line">        shapeMaker.drawRectangle();</span><br><span class="line">        shapeMaker.drawSquare();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210305112226.png" alt="image-20210305112226482"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/posts/e671036b/</url>
    <content><![CDATA[<h1 id="装饰模式的定义与特点"><a href="#装饰模式的定义与特点" class="headerlink" title="装饰模式的定义与特点"></a>装饰模式的定义与特点</h1><p>装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<h1 id="装饰模式的优缺点"><a href="#装饰模式的优缺点" class="headerlink" title="装饰模式的优缺点"></a>装饰模式的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li>
<li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>装饰器模式会增加许多子类，过度使用会增加程序得复杂性。</p>
<h1 id="装饰器模式的应用场景"><a href="#装饰器模式的应用场景" class="headerlink" title="装饰器模式的应用场景"></a>装饰器模式的应用场景</h1><ol>
<li>扩展一个类的功能。</li>
<li>动态增加功能，动态撤销</li>
<li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰器模式却很好实现。</li>
</ol>
<h1 id="装饰器模式的结构与实现"><a href="#装饰器模式的结构与实现" class="headerlink" title="装饰器模式的结构与实现"></a>装饰器模式的结构与实现</h1><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。下面来分析其基本结构和实现方法</p>
<h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>装饰器模式主要包含以下角色。</p>
<ol>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210304172754.png" alt="image-20210304172754153"></p>
<h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><p>抽象构件（Component）角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 装饰模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 抽象构件角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体构件（ConcreteComponent）角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 装饰模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 具体构件角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建具体构件角色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>抽象装饰（Decorator）角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 装饰模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 抽象装饰角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span>  <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体装饰（ConcreteDecorator）角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 装饰模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span>  <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 装饰模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component p = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        Component d = <span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式的定义与特点</title>
    <url>/posts/2a7709eb/</url>
    <content><![CDATA[<h1 id="桥接模式的定义与特点"><a href="#桥接模式的定义与特点" class="headerlink" title="桥接模式的定义与特点"></a>桥接模式的定义与特点</h1><p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<h1 id="桥接模式的优缺点"><a href="#桥接模式的优缺点" class="headerlink" title="桥接模式的优缺点"></a>桥接模式的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>抽象与实现分离，扩展能力强</li>
<li>符合开闭原则</li>
<li>实现细节对客户透明。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。</li>
</ol>
<h1 id="桥接模式的应用场景"><a href="#桥接模式的应用场景" class="headerlink" title="桥接模式的应用场景"></a>桥接模式的应用场景</h1><p>当一个类内部具备两种或多种变化维度时，使用桥接模式可以解耦这些变化的维度，使高层代码架构稳定。</p>
<ol>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</li>
</ol>
<p>桥接模式的一个常见使用场景就是<strong>替换继承</strong>。我们知道，继承拥有很多优点，比如，抽象、封装、多态等，父类封装共性，子类实现特性。继承可以很好的实现代码复用（封装）的功能，但这也是<strong>继承的一大缺点</strong>。因为父类拥有的方法，子类也会继承得到，无论子类需不需要，这说明<strong>继承具备强侵入性（父类代码侵入子类）</strong>，同时会导致子类臃肿。因此，在设计模式中，有一个原则为优先使用组合/聚合，而不是继承。</p>
<h1 id="桥接模式的结构与实现"><a href="#桥接模式的结构与实现" class="headerlink" title="桥接模式的结构与实现"></a>桥接模式的结构与实现</h1><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p>
<h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>桥接（Bridge）模式包含以下主要角色。</p>
<ol>
<li><strong>抽象化（Abstraction）角色：</strong>定义抽象类，并包含一个对实现化对象的引用。</li>
<li><strong>扩展抽象化（Refined Abstraction）角色：</strong>是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li><strong>实现化（Implementor）角色：</strong>定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li><strong>具体实现化（Concrete Implementor）角色：</strong>给出实现化角色接口的具体实现。</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210304164850.png" alt=" 桥接模式的结构图"></p>
<h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><ol>
<li><p><strong>抽象化（Abstraction）角色：</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 桥接模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 抽象化角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor imple;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imple = imple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>扩展抽象化（Refined Abstraction）角色：</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 桥接模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 扩展抽象化角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(imple);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展抽象化(Refined Abstraction)角色被访问&quot;</span>);</span><br><span class="line">        imple.OperationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>实现化（Implementor）角色：</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 桥接模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  实现化角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>具体实现化（Concrete Implementor）角色：</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 桥接模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span>  <span class="keyword">implements</span>  <span class="title">Implementor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体实现化(Concrete Implementor)角色被访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>测试</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 桥接模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       Implementor implementor  = <span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">       Abstraction A = <span class="keyword">new</span> RefinedAbstraction(implementor);</span><br><span class="line">       A.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/posts/7b510e10/</url>
    <content><![CDATA[<h1 id="代理模式的定义与特点"><a href="#代理模式的定义与特点" class="headerlink" title="代理模式的定义与特点"></a>代理模式的定义与特点</h1><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<h1 id="代理模式的优缺点"><a href="#代理模式的优缺点" class="headerlink" title="代理模式的优缺点"></a>代理模式的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</li>
<li>职责清晰</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢</li>
<li>代理模式会造成系统设计中类的数量增加</li>
<li>增加了系统的复杂度；</li>
</ol>
<h1 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h1><ul>
<li><strong>远程代理</strong>，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li>
<li><strong>虚拟代理</strong>，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li>
<li><strong>安全代理</strong>，这种方式通常用于控制不同种类客户对真实对象的访问权限。</li>
<li><strong>智能指引</strong>，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li>
<li><strong>延迟加载</strong>，指为了提高系统的性能，延迟对目标的加载。例如，<a href="http://c.biancheng.net/hibernate/">Hibernate</a> 中就存在属性的延迟加载和关联表的延时加载。</li>
</ul>
<h1 id="代理模式的结构与实现"><a href="#代理模式的结构与实现" class="headerlink" title="代理模式的结构与实现"></a>代理模式的结构与实现</h1><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法</p>
<h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>代理模式的主要角色如下。</p>
<ol>
<li><strong>抽象主题（Subject）类：</strong>通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li><strong>真实主题（Real Subject）类：</strong>实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li><strong>代理（Proxy）类：</strong>提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210304162617.png" alt="image-20210304162617527"></p>
<p>在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。</p>
<p>根据代理的创建时期，代理模式分为<strong>静态代理</strong>和<strong>动态代理</strong>。</p>
<ul>
<li><strong>静态</strong>：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li>
<li><strong>动态</strong>：在程序运行时，运用反射机制动态创建而成</li>
</ul>
<h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><p>抽象主题（Subject）类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 代理模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 真实主题（Real Subject）类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 代理模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>   真实主题类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        loadFromDisk(fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Loading&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Displaying &quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 代理模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 代理（Proxy）类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealImage realImage;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(realImage == <span class="keyword">null</span>)&#123;</span><br><span class="line">            realImage = <span class="keyword">new</span> RealImage(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        realImage.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 代理模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> ProxyImage(<span class="string">&quot;代理模式&quot;</span>);</span><br><span class="line">        image.display();</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        image.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210304164220.png" alt="image-20210304164220816"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/posts/fe816c3c/</url>
    <content><![CDATA[<h1 id="建造者模式定义和特点"><a href="#建造者模式定义和特点" class="headerlink" title="建造者模式定义和特点"></a>建造者模式定义和特点</h1><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p>
<h1 id="建造者模式的优缺点"><a href="#建造者模式的优缺点" class="headerlink" title="建造者模式的优缺点"></a>建造者模式的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>封装性好，构建和表示分离。</li>
<li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦</li>
<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li>
</ol>
<h2 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><ul>
<li>相同的方法，不同的执行顺序，产生不同的结果。</li>
<li>多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。</li>
<li>产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。</li>
<li>初始化一个对象特别复杂，参数多，而且很多参数都具有默认值</li>
</ul>
<h1 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h1><p>建造者（Builder）模式由<font color=red>产品、抽象建造者、具体建造者、指挥者等 4 个要素构成</font>，现在我们来分析其基本结构和实现方法。</p>
<h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>建造者（Builder）模式的主要角色如下</p>
<ol>
<li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。</li>
<li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li>
<li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li>
<li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210304144916.png" alt="建造者模式的结构图"></p>
<h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><p>(1) 产品角色：包含多个组成部件的复杂对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 建造者模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 产品角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartB</span><span class="params">(String partB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartC</span><span class="params">(String partC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partC = partC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">        System.out.println(partA);</span><br><span class="line">        System.out.println(partB);</span><br><span class="line">        System.out.println(partC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(2) 抽象建造者：包含创建产品各个子部件的抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 建造者模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 抽象建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;建造 PartB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;建造 PartC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 建造者模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 抽象建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder1</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartA1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;建造 PartB1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;建造 PartC1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(3) 具体建造者：实现了抽象建造者接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 建造者模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 具体建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;建造 PartB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;建造 PartC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(4) 指挥者：调用建造者中的方法完成复杂对象的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 建造者模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 指挥者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(5) 客户类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 建造者模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 客户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.construct();</span><br><span class="line">        product.show();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Builder builder1 = <span class="keyword">new</span> ConcreteBuilder1();</span><br><span class="line">        Director director1 = <span class="keyword">new</span> Director(builder1);</span><br><span class="line">        Product product1 = director1.construct();</span><br><span class="line">        product1.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210304150813.png" alt="image-20210304150813406"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/posts/48598499/</url>
    <content><![CDATA[<h1 id="工厂模式的定义与特点"><a href="#工厂模式的定义与特点" class="headerlink" title="工厂模式的定义与特点"></a>工厂模式的定义与特点</h1><p>工厂模式根据抽象程度的不同分为三种：<strong>简单工厂模式（也叫静态工厂模式）</strong>、<strong>工厂方法模式</strong>、以及<strong>抽象工厂模式</strong>。工厂模式是编程中经常用到的一种模式</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<h1 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a>工厂模式的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li>
<li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li>
<li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>类的个数容易过多，增加复杂度</li>
<li>增加了系统的抽象性和理解难度</li>
</ul>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul>
<li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时</li>
<li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</li>
</ul>
<h1 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h1><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成</p>
<h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>工厂方法模式的主要角色如下。</p>
<ol>
<li><strong>抽象工厂（Abstract Factory）</strong>：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li><strong>具体工厂（ConcreteFactory）</strong>：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li><strong>抽象产品（Product）</strong>：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li><strong>具体产品（ConcreteProduct）</strong>：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210304143145.png" alt="工厂方法模式的结构图"></p>
<h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><p><strong>(1)  创建抽象工厂</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 工厂模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>(2) 创建具体工厂</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 工厂模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inside Rectangle Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 工厂模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inside Square Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 工厂模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inside Circle Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>（3） 抽象产品</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 工厂模式;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( shapeType== <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shapeType.equals(<span class="string">&quot;Rectangle&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shapeType.equals(<span class="string">&quot;Square&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shapeType.equals(<span class="string">&quot;Circle&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>（4） 具体产品</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 工厂模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">        shapeFactory.getShape(<span class="string">&quot;Circle&quot;</span>).draw();</span><br><span class="line">        shapeFactory.getShape(<span class="string">&quot;Rectangle&quot;</span>).draw();</span><br><span class="line">        shapeFactory.getShape(<span class="string">&quot;Square&quot;</span>).draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210304144247.png" alt="image-20210304144247402"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/posts/9055d217/</url>
    <content><![CDATA[<h2 id="迭代器模式的定义与特点"><a href="#迭代器模式的定义与特点" class="headerlink" title="迭代器模式的定义与特点"></a>迭代器模式的定义与特点</h2><p>迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式。<strong>JDK中有数组等迭代器的实现</strong></p>
<h2 id="迭代器模式的优缺点"><a href="#迭代器模式的优缺点" class="headerlink" title="迭代器模式的优缺点"></a>迭代器模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。</li>
<li>遍历任务交由迭代器完成，这简化了聚合类。</li>
<li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li>
<li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
<li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>增加了类的个数，这在一定程度上增加了系统的复杂性。</p>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol>
<li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li>
<li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li>
<li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li>
<li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li>
</ol>
<h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><p>创建一个叙述导航方法的 <em>Iterator</em> 接口和一个返回迭代器的 <em>Container</em> 接口。实现了 <em>Container</em> 接口的实体类将负责实现 <em>Iterator</em> 接口。</p>
<p><em>IteratorPatternDemo</em>，我们的演示类使用实体类 <em>NamesRepository</em> 来打印 <em>NamesRepository</em> 中存储为集合的 <em>Names</em>。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316165435.png" alt="image-20210316165435461"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameRepository</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> String[] names = &#123;<span class="string">&quot;Robert&quot;</span> , <span class="string">&quot;John&quot;</span> ,<span class="string">&quot;Julie&quot;</span> , <span class="string">&quot;Lora&quot;</span>&#125;;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> NameIterator();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">int</span> index;</span><br><span class="line"> </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(index &lt; names.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())&#123;</span><br><span class="line">            <span class="keyword">return</span> names[index++];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPatternDemo</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      NameRepository namesRepository = <span class="keyword">new</span> NameRepository();</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123;</span><br><span class="line">         String name = (String)iter.next();</span><br><span class="line">         System.out.println(<span class="string">&quot;Name : &quot;</span> + name);</span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316165737.png" alt="image-20210316165737380"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/posts/8acb1976/</url>
    <content><![CDATA[<h2 id="状态模式的定义与特点"><a href="#状态模式的定义与特点" class="headerlink" title="状态模式的定义与特点"></a>状态模式的定义与特点</h2><p>状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<h2 id="状态模式的优缺点"><a href="#状态模式的优缺点" class="headerlink" title="状态模式的优缺点"></a>状态模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li>
<li>将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li>
<li>状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>状态模式的使用必然会增加系统的类与对象的个数。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li>
<li>状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。</li>
</ol>
<h2 id="状态模式的结构与实现"><a href="#状态模式的结构与实现" class="headerlink" title="状态模式的结构与实现"></a>状态模式的结构与实现</h2><h4 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h4><ol>
<li>环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。</li>
<li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。</li>
<li>具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</li>
</ol>
<h3 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h3><p>创建一个 <em>State</em> 接口和实现了 <em>State</em> 接口的实体状态类。<em>Context</em> 是一个带有某个状态的类。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316172712.png" alt="image-20210316172712601"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Player is in start state&quot;</span>);</span><br><span class="line">      context.setState(<span class="keyword">this</span>); </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Start State&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Player is in stop state&quot;</span>);</span><br><span class="line">      context.setState(<span class="keyword">this</span>); </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Stop State&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> State state;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span></span>&#123;</span><br><span class="line">      state = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;     </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Context context = <span class="keyword">new</span> Context();</span><br><span class="line"> </span><br><span class="line">      StartState startState = <span class="keyword">new</span> StartState();</span><br><span class="line">      startState.doAction(context);</span><br><span class="line"> </span><br><span class="line">      System.out.println(context.getState().toString());</span><br><span class="line"> </span><br><span class="line">      StopState stopState = <span class="keyword">new</span> StopState();</span><br><span class="line">      stopState.doAction(context);</span><br><span class="line"> </span><br><span class="line">      System.out.println(context.getState().toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210316172958.png" alt="image-20210316172958002"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/posts/91ad9ce3/</url>
    <content><![CDATA[<h1 id="原型模式的定义与特点"><a href="#原型模式的定义与特点" class="headerlink" title="原型模式的定义与特点"></a>原型模式的定义与特点</h1><p>原型模式（Prototype Pattern）是用于<strong>创建重复的对象，同时又能保证性能</strong>。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。<strong>例如</strong>，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<h1 id="原型模式的优缺点"><a href="#原型模式的优缺点" class="headerlink" title="原型模式的优缺点"></a>原型模式的优缺点</h1><h2 id="原型模式的优点"><a href="#原型模式的优点" class="headerlink" title="原型模式的优点"></a>原型模式的优点</h2><ul>
<li><a href="http://c.biancheng.net/java/">Java</a> 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。</li>
<li>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</li>
</ul>
<h2 id="原型模式的缺点"><a href="#原型模式的缺点" class="headerlink" title="原型模式的缺点"></a>原型模式的缺点</h2><ul>
<li>需要为每一个类都配置一个 clone 方法</li>
<li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。</li>
<li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
</ul>
<h1 id="原型模式的应用场景"><a href="#原型模式的应用场景" class="headerlink" title="原型模式的应用场景"></a>原型模式的应用场景</h1><ul>
<li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li>
<li>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。</li>
<li>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。</li>
<li>系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。</li>
</ul>
<blockquote>
<p>在 Spring 中，原型模式应用的非常广泛，例如 scope=’prototype’、JSON.parseObject() 等都是原型模式的具体应用。</p>
</blockquote>
<h1 id="原型模式的结构与实现"><a href="#原型模式的结构与实现" class="headerlink" title="原型模式的结构与实现"></a>原型模式的结构与实现</h1><h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>原型模式包含以下主要角色。</p>
<ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210304141905.png" alt="原型模式的结构图"></p>
<h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><p>原型模式的克隆分为浅克隆和深克隆。</p>
<ul>
<li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li>
<li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li>
</ul>
<blockquote>
<p>Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。</p>
</blockquote>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>创建一个实现了Cloneable接口的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 原型模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 必须实现Cloneable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">Shape</span>  <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">Clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object clone=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clone=<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建扩展了上面抽象类的实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 原型模式;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">()</span></span>&#123;</span><br><span class="line">        type = <span class="string">&quot;Square&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 原型模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span>  <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        type = <span class="string">&quot;Circle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 原型模式;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">       type = <span class="string">&quot;Rectangle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建一个类，实例化实体类，并把它们存储在一个 <em>Hashtable</em> 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 原型模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hashtable&lt;String, Shape&gt; shapeMap = <span class="keyword">new</span> Hashtable&lt;String, Shape&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String shapeId)</span> </span>&#123;</span><br><span class="line">        Shape cachedShape = shapeMap.get(shapeId);</span><br><span class="line">        <span class="keyword">return</span> (Shape) cachedShape.ShapeClone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每种形状都运行数据库查询，并创建该形状</span></span><br><span class="line">    <span class="comment">// shapeMap.put(shapeKey, shape);</span></span><br><span class="line">    <span class="comment">// 例如，我们要添加三种形状</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        circle.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        shapeMap.put(circle.getId(),circle);</span><br><span class="line"></span><br><span class="line">        Square square = <span class="keyword">new</span> Square();</span><br><span class="line">        square.setId(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        shapeMap.put(square.getId(),square);</span><br><span class="line"></span><br><span class="line">        Rectangle rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        rectangle.setId(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        shapeMap.put(rectangle.getId(),rectangle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>PrototypePatternDemo</em> 使用 <em>ShapeCache</em> 类来获取存储在 <em>Hashtable</em> 中的形状的克隆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 原型模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypePatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeCache.loadCache();</span><br><span class="line"></span><br><span class="line">        Shape clonedShape = ShapeCache.getShape(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape1 : &quot;</span> + clonedShape.getType());</span><br><span class="line"></span><br><span class="line">        Shape clonedShape2 = ShapeCache.getShape(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape2 : &quot;</span> + clonedShape2.getType());</span><br><span class="line"></span><br><span class="line">        Shape clonedShape3 = ShapeCache.getShape(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape3 : &quot;</span> + clonedShape3.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210304120514.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/posts/f1601c3e/</url>
    <content><![CDATA[<h1 id="单例模式的定义与特点"><a href="#单例模式的定义与特点" class="headerlink" title="单例模式的定义与特点"></a>单例模式的定义与特点</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h1 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h1><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>单例模式可以保证内存里只有一个实例，减少了内存的开销。</li>
<li>避免对资源的多重占用（比如写文件操作）。</li>
<li>单例模式设置全局访问点，可以优化和共享资源的访问。</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li>
<li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象</li>
<li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li>
</ol>
<p><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol>
<li>需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。</li>
<li>某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li>
<li>某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。</li>
<li>某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li>
<li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li>
<li>频繁访问数据库或文件的对象。</li>
<li>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。</li>
</ol>
<h1 id="单例模式的结构与实现"><a href="#单例模式的结构与实现" class="headerlink" title="单例模式的结构与实现"></a>单例模式的结构与实现</h1><h2 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h2><p>单例模式的主要角色如下。</p>
<ul>
<li><p>单例类：包含一个实例且能自行创建这个实例的类。</p>
</li>
<li><p>访问类：使用单例的类。</p>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210304140937.png" alt="image-20210304140937556"></p>
</li>
</ul>
<h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>是否 Lazy 初始化：</strong>否</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>缺点</strong>：类加载时就初始化，浪费内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton01 instance = <span class="keyword">new</span> Singleton01();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton01</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h3><p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>否</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton02 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton02</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton02();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="懒汉式，线程安全3"><a href="#懒汉式，线程安全3" class="headerlink" title="懒汉式，线程安全3"></a>懒汉式，线程安全3</h2><p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>缺点：</strong>必须加锁 synchronized 才能保证单例，但加锁会影响效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  懒汉式，线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton03 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton03</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton03 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton03();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="懒汉式（双检锁-双重校验锁（DCL）"><a href="#懒汉式（双检锁-双重校验锁（DCL）" class="headerlink" title="懒汉式（双检锁/双重校验锁（DCL）)"></a>懒汉式（双检锁/双重校验锁（DCL）)</h3><p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>优点：</strong>采用双锁机制，安全且在多线程情况下能保持高性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 懒汉式（双检锁/双重校验锁（DCL）)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton04</span> </span>&#123;</span><br><span class="line">    <span class="comment">//volatile保证了线程间数据的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton04 singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton04</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton04 <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton04.class) &#123;</span><br><span class="line">                <span class="comment">//在此再次检验是为了防止获取锁的过程中，被其他线程实例化</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton04();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton05</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton05 INSTANCE = <span class="keyword">new</span> Singleton05();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton05</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton05 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><strong>是否 Lazy 初始化：</strong>否</p>
<p><strong>是否多线程安全：</strong>是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton06</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式的分类</title>
    <url>/posts/99e6d3f8/</url>
    <content><![CDATA[<h1 id="设计模式的6大设计原则"><a href="#设计模式的6大设计原则" class="headerlink" title="设计模式的6大设计原则"></a>设计模式的6大设计原则</h1><ol>
<li>单一职责原则</li>
<li>里氏替换原则</li>
<li>依赖倒置原则</li>
<li>接口隔离原则</li>
<li>迪米特法则</li>
<li>开闭原则</li>
</ol>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。核心就是控制类的粒度大小、将对象解耦、提高其内聚性</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1、降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</p>
<p>2、提高类的可读性。复杂性降低，自然其可读性会提高。</p>
<p>3、提高系统的可维护性。可读性提高，那自然更容易维护了。</p>
<p>4、变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>继承必须确保超类所拥有的性质在子类中仍然成立。子类可以扩展父类的功能，但不能改变父类原有的功能</p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ol>
<li>克服了继承中重写父类造成的可复用性变差的缺点</li>
<li>保证了动作正确性。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li>
</ol>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><strong>继承，除添加新的方法完成新增功能外</strong>，尽量不要重写父类的方法</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：<font color=red>要面向接口编程，不要面向实现编程</font>。</p>
<h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><ol>
<li>依赖倒置原则可以降低类间的耦合性。</li>
<li>依赖倒置原则可以提高系统的稳定性。</li>
<li>依赖倒置原则可以减少并行开发引起的风险。</li>
<li>依赖倒置原则可以提高代码的可读性和可维护性</li>
</ol>
<h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>每个类尽量提供接口或抽象类，或者两者都具备。</li>
<li>变量的声明类型尽量是接口或者是抽象类。</li>
<li>任何类都不应该从具体类派生。</li>
<li>使用继承时尽量遵循里氏替换原则</li>
</ol>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上</p>
<h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><ol>
<li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li>
<li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li>
<li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li>
<li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li>
<li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li>
</ol>
<h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li>
<li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li>
<li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li>
</ol>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，通过第三方转发调用降低类之间的耦合度，提高模块的相对独立性</p>
<h2 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h2><ol>
<li>降低了类之间的耦合度，提高了模块的相对独立性。</li>
<li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li>
</ol>
<h2 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h2><p><strong>通过第三方转发调用降低类之间的耦合度，提高模块的相对独立性</strong></p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p>
<h2 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h2><ol>
<li>方便测试；测试时只需要对扩展的代码进行测试。</li>
<li>提高代码的可复用性；粒度越小，被复用的可能性就越大。</li>
<li>提高软件的稳定性和延续性，易于扩展和维护。</li>
</ol>
<h2 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h2><p>通过“抽象约束、封装变化”来实现开闭原则。通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类</p>
<h1 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>根据其<strong>目的</strong>（模式是用来做什么的）可分为<strong>创建型</strong>(Creational)，<strong>结构型</strong>(Structural)和<strong>行为型</strong>(Behavioral)三种：</p>
<ul>
<li><strong>创建型模式：</strong>作用于对象的创建，将对象的创建与使用分离。其中囊括了<font color=red>单例、原型、工厂方法、抽象工厂、建造者</font>5 种创建型模式。</li>
<li><strong>结构型模式：</strong>将类或对象按某种布局组成更大的结构，其中以<font color=red>代理、适配器、桥接、装饰、外观、享元、组合</font> 7 种结构型模式为主。</li>
<li><strong>行为型模式：</strong>作用于类或对象之间相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。主要包含了<font color=red>模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器</font>等 11 种行为型模式。</li>
</ul>
<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>根据<strong>范围</strong>（模式主要是用于处理类之间关系还是处理对象之间的关系）可分为<strong>类模式</strong>和<strong>对象模式</strong>两种：</p>
<ul>
<li><strong>类模式：</strong>用于处理类与子类之间的关系，这些关系通过继承来建立，在编译时刻便确定下来了。<font color=red>工厂、（类）适配器、模板方法、解释器均属于该模式</font>。</li>
<li><strong>对象模式：</strong>用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。<font color=red>除了以上 4 种，其他的都是对象模式</font>。</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210304101452.png" alt=""></p>
<h1 id="设计模式的功能"><a href="#设计模式的功能" class="headerlink" title="设计模式的功能"></a>设计模式的功能</h1><ol>
<li><strong>单例（Singleton）模式：</strong>某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li><strong>原型（Prototype）模式：</strong>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li><strong>工厂（Factory Method）模式：</strong>定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li><strong>抽象工厂（AbstractFactory）模式：</strong>提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li><strong>建造者（Builder）模式：</strong>将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
<li><strong>代理（Proxy）模式：</strong>为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li><strong>适配器（Adapter）模式：</strong>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li><strong>桥接（Bridge）模式：</strong>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li><strong>装饰（Decorator）模式：</strong>动态的给对象增加一些职责，即增加其额外的功能。</li>
<li><strong>外观（Facade）模式：</strong>为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li><strong>享元（Flyweight）模式：</strong>运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li><strong>组合（Composite）模式：</strong>将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
<li><strong>模板方法（TemplateMethod）模式：</strong>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li><strong>策略（Strategy）模式：</strong>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li><strong>命令（Command）模式：</strong>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li><strong>职责链（Chain of Responsibility）模式：</strong>把请求从链中的一个对象传到下一个对象，直到请求被响应通过这种方式去除对象之间的耦合。</li>
<li><strong>状态（State）模式：</strong>允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li><strong>观察者（Observer）模式：</strong>多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li><strong>中介者（Mediator）模式：</strong>定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li><strong>迭代器（Iterator）模式：</strong>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li><strong>访问者（Visitor）模式：</strong>在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li><strong>备忘录（Memento）模式：</strong>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li><strong>解释器（Interpreter）模式：</strong>提供如何定义语言的放法，以及对语言句子的解释方法，即解释器。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性协议——Zab算法</title>
    <url>/posts/b369a3b6/</url>
    <content><![CDATA[<h1 id="Zab算法描述"><a href="#Zab算法描述" class="headerlink" title="Zab算法描述"></a>Zab算法描述</h1><p>Zab协议 的全称是 <strong>Zookeeper Atomic Broadcast</strong> （Zookeeper原子广播）。</p>
<p><strong>Zookeeper 是通过 Zab 协议来保证分布式事务的最终一致性</strong>。</p>
<ol>
<li>Zab协议是为分布式协调服务Zookeeper专门设计的一种 <strong>支持崩溃恢复</strong> 的 <strong>原子广播协议</strong> ，是Zookeeper保证数据一致性的核心算法。Zab借鉴了Paxos算法，但又不像Paxos那样，是一种通用的分布式一致性算法。<strong>它是特别为Zookeeper设计的支持崩溃恢复的原子广播协议</strong>。</li>
<li>在Zookeeper中主要依赖Zab协议来实现数据一致性，基于该协议，zk实现了一种主备模型（即Leader和Follower模型）的系统架构来保证集群中各个副本之间数据的一致性。<br> 这里的主备系统架构模型，就是指只有一台客户端（Leader）负责处理外部的写事务请求，然后Leader客户端将数据同步到其他Follower节点。</li>
</ol>
<p>Zookeeper 客户端会随机的链接到 zookeeper 集群中的一个节点，如果是<font color=red>读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交</font>。</p>
<h1 id="Zab-协议的特性："><a href="#Zab-协议的特性：" class="headerlink" title="Zab 协议的特性："></a><strong>Zab 协议的特性</strong>：</h1><p>1）Zab 协议需要确保那些<strong>已经在 Leader 服务器上提交（Commit）的事务最终被所有的服务器提交</strong>。</p>
<p>2）Zab 协议需要确保<strong>丢弃那些只在 Leader 上被提出而没有被提交的事务</strong>。</p>
<h1 id="Zab-协议的作用"><a href="#Zab-协议的作用" class="headerlink" title="Zab 协议的作用"></a>Zab 协议的作用</h1><ol>
<li><p><strong>使用一个单一的主进程（Leader）来接收并处理客户端的事务请求</strong>（也就是写请求），并采用了Zab的原子广播协议，将服务器数据的状态变更以 <strong>事务proposal</strong> （事务提议）的形式广播到所有的副本（Follower）进程上去。</p>
</li>
<li><p><strong>保证一个全局的变更序列被顺序引用</strong>。<br> Zookeeper是一个树形结构，很多操作都要先检查才能确定是否可以执行，比如P1的事务t1可能是创建节点”/a”，t2可能是创建节点”/a/bb”，只有先创建了父节点”/a”，才能创建子节点”/a/b”。</p>
<p> 为了保证这一点，Zab要保证同一个Leader发起的事务要按顺序被apply，同时还要保证只有先前Leader的事务被apply之后，新选举出来的Leader才能再次发起事务。</p>
</li>
<li><p><strong>当主进程出现异常的时候，整个zk集群依旧能正常工作</strong>。</p>
</li>
</ol>
<h2 id="Zab协议原理"><a href="#Zab协议原理" class="headerlink" title="Zab协议原理"></a>Zab协议原理</h2><p>Zab协议要求每个 Leader 都要经历三个阶段：<strong>发现，同步，广播</strong>。</p>
<ul>
<li><strong>发现</strong>：要求zookeeper集群必须选举出一个 Leader 进程，同时 Leader 会维护一个 Follower 可用客户端列表。将来客户端可以和这些 Follower节点进行通信。</li>
<li><strong>同步</strong>：Leader 要负责将本身的数据与 Follower 完成同步，做到多副本存储。这样也是提现了CAP中的高可用和分区容错。Follower将队列中未处理完的请求消费完成后，写入本地事务日志中。</li>
<li><strong>广播</strong>：Leader 可以接受客户端新的事务Proposal请求，将新的Proposal请求广播给所有的 Follower。</li>
</ul>
<h2 id="Zab协议核心"><a href="#Zab协议核心" class="headerlink" title="Zab协议核心"></a>Zab协议核心</h2><p>Zab协议的核心：<strong>定义了事务请求的处理方式</strong></p>
<p>1）所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被叫做 <strong>Leader服务器</strong>。其他剩余的服务器则是 <strong>Follower服务器</strong>。</p>
<p>2）Leader服务器 负责将一个客户端事务请求，转换成一个 <strong>事务Proposal</strong>，并将该 Proposal 分发给集群中所有的 Follower 服务器，也就是向所有 Follower 节点发送数据广播请求（或数据复制）</p>
<p>3）分发之后Leader服务器需要等待所有Follower服务器的反馈（Ack请求），<strong>在Zab协议中，只要超过半数的Follower服务器进行了正确的反馈</strong>后（也就是收到半数以上的Follower的Ack请求），那么 Leader 就会再次向所有的 Follower服务器发送 Commit 消息，要求其将上一个 事务proposal 进行提交。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302165537.png" alt="image-20210302165537904"></p>
<h2 id="Zab协议内容"><a href="#Zab协议内容" class="headerlink" title="Zab协议内容"></a>Zab协议内容</h2><p>Zab 协议包括两种基本的模式：<strong>崩溃恢复</strong> 和 <strong>消息广播</strong></p>
<h3 id="Zab协议内容-1"><a href="#Zab协议内容-1" class="headerlink" title="Zab协议内容"></a>Zab协议内容</h3><h4 id="协议过程"><a href="#协议过程" class="headerlink" title="协议过程"></a>协议过程</h4><p>当整个集群启动过程中，或者当 Leader 服务器出现网络中弄断、崩溃退出或重启等异常时，Zab协议就会 <strong>进入崩溃恢复模式</strong>，选举产生新的Leader。</p>
<p>当选举产生了新的 Leader，同时集群中有过半的机器与该 Leader 服务器完成了状态同步（即数据同步）之后，Zab协议就会退出崩溃恢复模式，<strong>进入消息广播模式</strong>。</p>
<p>这时，如果有一台遵守Zab协议的服务器加入集群，因为此时集群中已经存在一个Leader服务器在广播消息，那么该新加入的服务器自动进入恢复模式：找到Leader服务器，并且完成数据同步。同步完成后，作为新的Follower一起参与到消息广播流程中。</p>
<h4 id="协议状态切换"><a href="#协议状态切换" class="headerlink" title="协议状态切换"></a>协议状态切换</h4><p>当Leader出现崩溃退出或者机器重启，亦或是集群中不存在超过半数的服务器与Leader保存正常通信，Zab就会再一次进入崩溃恢复，发起新一轮Leader选举并实现数据同步。同步完成后又会进入消息广播模式，接收事务请求。</p>
<h4 id="保证消息有序"><a href="#保证消息有序" class="headerlink" title="保证消息有序"></a>保证消息有序</h4><p>在整个消息广播中，Leader会将每一个事务请求转换成对应的 proposal 来进行广播，并且在广播 事务Proposal 之前，Leader服务器会首先为这个事务Proposal分配一个全局单递增的唯一ID，称之为事务ID（即zxid），由于Zab协议需要保证每一个消息的严格的顺序关系，因此必须将每一个proposal按照其zxid的先后顺序进行排序和处理。</p>
<h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><ol>
<li><p>在zookeeper集群中，数据副本的传递策略就是采用消息广播模式。zookeeper中农数据副本的同步方式与二段提交相似，但是却又不同。二段提交要求协调者必须等到所有的参与者全部反馈ACK确认消息后，再发送commit消息。要求所有的参与者要么全部成功，要么全部失败。二段提交会产生严重的阻塞问题。</p>
</li>
<li><p>Zab协议中 Leader 等待 Follower 的ACK反馈消息是指“只要半数以上的Follower成功反馈即可，不需要收到全部Follower反馈”</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210302170013.png" alt="消息广播流程图"></p>
</li>
</ol>
<h4 id="消息广播具体步骤"><a href="#消息广播具体步骤" class="headerlink" title="消息广播具体步骤"></a>消息广播具体步骤</h4><ol>
<li>客户端发起一个写操作请求。</li>
<li>Leader 服务器将客户端的请求转化为事务 Proposal 提案，同时为每个 Proposal 分配一个全局的ID，即zxid。</li>
<li>Leader 服务器为每个 Follower 服务器分配一个单独的队列，然后将需要广播的 Proposal 依次放到队列中取，并且根据 FIFO 策略进行消息发送。</li>
<li>Follower 接收到 Proposal 后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向 Leader 反馈一个 Ack 响应消息。</li>
<li>Leader 接收到超过半数以上 Follower 的 Ack 响应消息后，即认为消息发送成功，可以发送 commit 消息。</li>
<li>Leader 向所有 Follower 广播 commit 消息，同时自身也会完成事务提交。Follower 接收到 commit 消息后，会将上一条事务提交。</li>
</ol>
<p><strong>zookeeper 采用 Zab 协议的核心，就是只要有一台服务器提交了 Proposal，就要确保所有的服务器最终都能正确提交 Proposal。这也是 CAP/BASE 实现最终一致性的一个体现。</strong></p>
<p><strong>Leader 服务器与每一个 Follower 服务器之间都维护了一个单独的 FIFO 消息队列进行收发消息，使用队列消息可以做到异步解耦。 Leader 和 Follower 之间只需要往队列中发消息即可。如果使用同步的方式会引起阻塞，性能要下降很多。</strong></p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p><strong>一旦 Leader 服务器出现崩溃或者由于网络原因导致 Leader 服务器失去了与过半 Follower 的联系，那么就会进入崩溃恢复模式。</strong></p>
<p>在 Zab 协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的 Leader 服务器。因此 Zab 协议需要一个高效且可靠的 Leader 选举算法，从而确保能够快速选举出新的 Leader 。</p>
<p>Leader 选举算法不仅仅需要让 Leader 自己知道自己已经被选举为 Leader ，同时还需要让集群中的所有其他机器也能够快速感知到选举产生的新 Leader 服务器。</p>
<p>崩溃恢复主要包括两部分：<strong>Leader选举</strong> 和 <strong>数据恢复</strong></p>
<h4 id="Zab-协议保证数据一致性"><a href="#Zab-协议保证数据一致性" class="headerlink" title="Zab 协议保证数据一致性"></a>Zab 协议保证数据一致性</h4><p><strong>Zab 协议崩溃恢复要求满足以下两个要求</strong>：</p>
<ol>
<li><p><strong>确保已经被 Leader 提交的 Proposal 必须最终被所有的 Follower 服务器提交</strong>。</p>
</li>
<li><p><strong>确保丢弃已经被 Leader 提出的但是没有被提交的 Proposal</strong>。</p>
</li>
</ol>
<p>根据上述要求</p>
<p>Zab协议需要保证选举出来的Leader需要满足以下条件：</p>
<ol>
<li><p><strong>新选举出来的 Leader 不能包含未提交的 Proposal</strong> 。</p>
<p> 即新选举的 Leader 必须都是已经提交了 Proposal 的 Follower 服务器节点。</p>
</li>
<li><p><strong>新选举的 Leader 节点中含有最大的 zxid</strong> 。<br> 这样做的好处是可以避免 Leader 服务器检查 Proposal 的提交和丢弃工作。</p>
</li>
</ol>
<h4 id="Zab-数据同步"><a href="#Zab-数据同步" class="headerlink" title="Zab 数据同步"></a>Zab 数据同步</h4><ol>
<li>完成 Leader 选举后（新的 Leader 具有最高的zxid），在正式开始工作之前（接收事务请求，然后提出新的 Proposal），Leader 服务器会首先确认事务日志中的所有的 Proposal 是否已经被集群中过半的服务器 Commit。</li>
<li>Leader 服务器需要确保所有的 Follower 服务器能够接收到每一条事务的 Proposal ，并且能将所有已经提交的事务 Proposal 应用到内存数据中。等到 Follower 将所有尚未同步的事务 Proposal 都从 Leader 服务器上同步过啦并且应用到内存数据中以后，Leader 才会把该 Follower 加入到真正可用的 Follower 列表中。</li>
</ol>
<h4 id="Zab-数据同步过程中，如何处理需要丢弃的-Proposal"><a href="#Zab-数据同步过程中，如何处理需要丢弃的-Proposal" class="headerlink" title="Zab 数据同步过程中，如何处理需要丢弃的 Proposal"></a>Zab 数据同步过程中，如何处理需要丢弃的 Proposal</h4><p>在 Zab 的事务编号 zxid 设计中，zxid是一个64位的数字。</p>
<p>其中低32位可以看成一个简单的单增计数器，针对客户端每一个事务请求，Leader 在产生新的 Proposal 事务时，都会对该计数器加1。而<font color=red>高32位则代表了 Leader 周期的 epoch 编号</font>。</p>
<blockquote>
<p>epoch 编号可以理解为当前集群所处的年代，或者周期。每次Leader变更之后都会在 epoch 的基础上加1，这样旧的 Leader 崩溃恢复之后，其他Follower 也不会听它的了，因为 Follower 只服从epoch最高的 Leader 命令。</p>
</blockquote>
<p>每当选举产生一个新的 Leader ，就会从这个 <font color=red>Leader 服务器上取出本地事务日志充最大编号 Proposal 的 zxid，并从 zxid 中解析得到对应的 epoch 编号，然后再对其加1，之后该编号就作为新的 epoch 值，并将低32位数字归零，由0开始重新生成zxid</font>。</p>
<p><strong>Zab 协议通过 epoch 编号来区分 Leader 变化周期</strong>，能够有效避免不同的 Leader 错误的使用了相同的 zxid 编号提出了不一样的 Proposal 的异常情况。</p>
<h1 id="Zab实现原理"><a href="#Zab实现原理" class="headerlink" title="Zab实现原理"></a>Zab实现原理</h1><p><strong>Zab 节点有三种状态</strong>：</p>
<ul>
<li>Following：当前节点是跟随者，服从 Leader 节点的命令。</li>
<li>Leading：当前节点是 Leader，负责协调事务。</li>
<li>Election/Looking：节点处于选举状态，正在寻找 Leader。</li>
</ul>
<p>代码实现中，多了一种状态：Observing 状态<br>这是 Zookeeper 引入 Observer 之后加入的，Observer 不参与选举，是只读节点，跟 Zab 协议没有关系。</p>
<p><strong>节点的持久状态</strong>：</p>
<ul>
<li>history：当前节点接收到事务 Proposal 的Log</li>
<li>acceptedEpoch：Follower 已经接受的 Leader 更改 epoch 的 newEpoch 提议。</li>
<li>currentEpoch：当前所处的 Leader 年代</li>
<li>lastZxid：history 中最近接收到的Proposal 的 zxid（最大zxid）</li>
</ul>
<h2 id="Zab-的四个阶段"><a href="#Zab-的四个阶段" class="headerlink" title="Zab 的四个阶段"></a>Zab 的四个阶段</h2><h3 id="选举阶段（Leader-Election"><a href="#选举阶段（Leader-Election" class="headerlink" title="选举阶段（Leader Election"></a>选举阶段（Leader Election</h3><p>节点在一开始都处于选举节点，只要有一个节点得到超过半数节点的票数，它就可以当选准 Leader，只有到达第三个阶段（也就是同步阶段），这个准 Leader 才会成为真正的 Leader。<strong>Zookeeper 规定所有有效的投票都必须在同一个 轮次 中，每个服务器在开始新一轮投票时，都会对自己维护的 logicalClock 进行自增操作</strong>。</p>
<p>每个服务器在广播自己的选票前，会将自己的投票箱（recvset）清空。该投票箱记录了所受到的选票。</p>
<p>例如：Server_2 投票给 Server_3，Server_3 投票给 Server_1，则Server_1的投票箱为(2,3)、(3,1)、(1,1)。（每个服务器都会默认给自己投票）</p>
<p>前一个数字表示投票者，后一个数字表示被选举者。票箱中只会记录每一个投票者的最后一次投票记录，如果投票者更新自己的选票，则其他服务器收到该新选票后会在自己的票箱中更新该服务器的选票。</p>
<p><strong>这一阶段的目的就是为了选出一个准 Leader ，然后进入下一个阶段。</strong></p>
<p>协议并没有规定详细的选举算法，后面会提到实现中使用的 Fast Leader Election。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302171418.png" alt="选举流程"></p>
<h3 id="发现阶段（Descovery）"><a href="#发现阶段（Descovery）" class="headerlink" title="发现阶段（Descovery）"></a>发现阶段（Descovery）</h3><p>在这个阶段，Followers 和上一轮选举出的准 Leader 进行通信，同步 Followers 最近接收的事务 Proposal 。</p>
<p>一个 Follower 只会连接一个 Leader，如果一个 Follower 节点连接另一个 Follower 节点，则会在尝试连接时被拒绝。被拒绝之后，该节点就会进入 Leader Election阶段。</p>
<p><strong>这个阶段的主要目的是发现当前大多数节点接收的最新 Proposal，并且准 Leader 生成新的 epoch ，让 Followers 接收，更新它们的 acceptedEpoch</strong>。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302171535.png" alt="发现流程"></p>
<h3 id="同步阶段（Synchronization）"><a href="#同步阶段（Synchronization）" class="headerlink" title="同步阶段（Synchronization）"></a>同步阶段（Synchronization）</h3><p><strong>同步阶段主要是利用 Leader 前一阶段获得的最新 Proposal 历史，同步集群中所有的副本</strong>。<br>只有当 quorum（超过半数的节点） 都同步完成，准 Leader 才会成为真正的 Leader。Follower 只会接收 zxid 比自己 lastZxid 大的 Proposal。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302171702.png" alt="同步流程"></p>
<h3 id="广播阶段（Broadcast）"><a href="#广播阶段（Broadcast）" class="headerlink" title="广播阶段（Broadcast）"></a>广播阶段（Broadcast）</h3><p>到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 Leader 可以进行消息广播。同时，如果有新的节点加入，还需要对新节点进行同步。</p>
<p>需要注意的是，Zab 提交事务并不像 2PC 一样需要全部 Follower 都 Ack，只需要得到 quorum（超过半数的节点）的Ack 就可以。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302171740.png" alt="广播流程"></p>
<h1 id="Zab协议实现"><a href="#Zab协议实现" class="headerlink" title="Zab协议实现"></a>Zab协议实现</h1><p>选举阶段使用 java版本实现的是Fast Leader Election算法，实际的实现将<strong>发现和同步阶段合并为 Recovery Phase（恢复阶段）</strong>，所以，Zab 的实现实际上有三个阶段。</p>
<p>Zab协议三个阶段：</p>
<ol>
<li><strong>选举（Fast Leader Election）</strong></li>
<li><strong>恢复（Recovery Phase）</strong></li>
<li><strong>广播（Broadcast Phase）</strong></li>
</ol>
<h2 id="Fast-Leader-Election（快速选举）"><a href="#Fast-Leader-Election（快速选举）" class="headerlink" title="Fast Leader Election（快速选举）"></a>Fast Leader Election（快速选举）</h2><p> FLE 会选举拥有最新Proposal history （lastZxid最大）的节点作为 Leader，这样就省去了发现最新提议的步骤。<strong>这是基于拥有最新提议的节点也拥有最新的提交记录</strong></p>
<h3 id="成为-Leader-的条件："><a href="#成为-Leader-的条件：" class="headerlink" title="成为 Leader 的条件："></a>成为 Leader 的条件：</h3><ol>
<li>选 epoch 最大的</li>
<li>若 epoch 相等，选 zxid 最大的</li>
<li>若 epoch 和 zxid 相等，选择 server_id 最大的（<strong>zoo.cfg中的myid</strong>）</li>
</ol>
<p>节点在选举开始时，都默认投票给自己，当接收其他节点的选票时，会根据上面的 <strong>Leader条件</strong> 判断并且更改自己的选票，然后重新发送选票给其他节点。<strong>当有一个节点的得票超过半数，该节点会设置自己的状态为 Leading ，其他节点会设置自己的状态为 Following</strong>。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302172451.png" alt="选举过程"></p>
<h2 id="Recovery-Phase（恢复阶段）"><a href="#Recovery-Phase（恢复阶段）" class="headerlink" title="Recovery Phase（恢复阶段）"></a>Recovery Phase（恢复阶段）</h2><p>这一阶段 Follower 发送他们的 <strong>lastZxid</strong> 给 Leader，Leader 根据 lastZxid 决定如何同步数据。这里的实现跟前面的 Phase 2 有所不同：Follower 收到 TRUNC 指令会终止L.lastCommitedZxid 之后的 Proposal ，收到 DIFF 指令会接收新的 Proposal。</p>
<blockquote>
<p>history.lastCommitedZxid：最近被提交的 Proposal zxid</p>
<p>history.oldThreshold：被认为已经太旧的已经提交的 Proposal zxid</p>
</blockquote>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302172728.png" alt="恢复阶段"></p>
<h1 id="Zab特殊情况下需要解决的两个问题："><a href="#Zab特殊情况下需要解决的两个问题：" class="headerlink" title="Zab特殊情况下需要解决的两个问题："></a>Zab特殊情况下需要解决的两个问题：</h1><h2 id="已经被处理的事务请求（proposal）不能丢（commit的）"><a href="#已经被处理的事务请求（proposal）不能丢（commit的）" class="headerlink" title="已经被处理的事务请求（proposal）不能丢（commit的）"></a>已经被处理的事务请求（proposal）不能丢（commit的）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>当 leader 收到合法数量 follower 的 ACKs 后，就向各个 follower 广播 COMMIT 命令，同时也会在本地执行 COMMIT 并向连接的客户端返回「成功」。但是如果在各个 follower 在收到COMMIT 命令前 leader 就挂了，导致剩下的服务器并没有执行都这条消息。</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ol>
<li><p>选举拥有 proposal 最大值（即 zxid 最大） 的节点作为新的 leader。</p>
<blockquote>
<p>由于所有提案被 COMMIT 之前必须有<font color=red>合法数量的 follower ACK，即必须有合法数量的服务器的事务日志上有该提案的 proposal</font>，因此，zxid最大也就是数据最新的节点保存了所有被 COMMIT 消息的 proposal 状态。</p>
</blockquote>
</li>
<li><p>新的 leader 将自己事务日志中 proposal 但未 COMMIT 的消息处理。</p>
</li>
<li><p>新的 leader 与 follower 建立先进先出的队列， 先将自身有而 follower 没有的 proposal</p>
<p> 发送给 follower，再将这些 proposal 的 COMMIT 命令发送给 follower，以保证所有的</p>
<p> follower 都保存了所有的 proposal、所有的 follower 都处理了所有的消息</p>
</li>
</ol>
<h2 id="没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？"><a href="#没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？" class="headerlink" title="没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？"></a>没被处理的事务请求（proposal）不能再次出现什么时候会出现事务请求被丢失呢？</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>当 leader 接收到消息请求生成 proposal 后就挂了，其他 follower 并没有收到此 proposal，因此经过恢复模式重新选了 leader 后，这条消息是被跳过的。 此时，之前挂了的 leader 重新启动并注册成了 follower，他保留了被跳过消息的 proposal 状态，与整个系统的状态是不一致的，需要将其删除。</p>
<h3 id="解决方式-1"><a href="#解决方式-1" class="headerlink" title="解决方式"></a>解决方式</h3><p><strong>Zab 通过巧妙的设计 zxid 来实现这一目的。</strong></p>
<p>一个 zxid 是64位，高 32 是纪元（epoch）编号，每经过一次 leader 选举产生一个新的 leader，新 leader 会将 epoch 号 +1。低 32 位是消息计数器，每接收到一条消息这个值 +1，新 leader 选举后这个值重置为 0。</p>
<p>这样设计的好处是旧的 leader 挂了后重启，它不会被选举为 leader，因为此时它的 zxid 肯定小于当前的新 leader。当旧的 leader 作为 follower 接入新的 leader 后，新的 leader 会让它将所有的拥有旧的 epoch 号的未被 COMMIT 的 proposal 清除。</p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
        <category>Zab</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
        <tag>ZAB</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性协议——paxos算法</title>
    <url>/posts/fe45d335/</url>
    <content><![CDATA[<h1 id="paxos目的"><a href="#paxos目的" class="headerlink" title="paxos目的"></a>paxos目的</h1><p>Paxos算法是<font color=red>基于消息传递且具有高度容错特性的一致性算法</font>，是目前公认的解决分布式一致性问题最有效的算法之一，其<font color=red>解决的问题就是在分布式系统中如何就某个值（决议）达成一致</font>。</p>
<p>Paxos算法的前提假设是不存在拜占庭将军问题，即： <font color=red>信道是安全的（信道可靠），发出的信号不会被篡改，因为Paxos算法是基于消息传递的</font>。：如下图所示</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302154508.png" alt="image-20210302154508699"></p>
<h1 id="paxos算法角色划分：三种类型"><a href="#paxos算法角色划分：三种类型" class="headerlink" title="paxos算法角色划分：三种类型"></a>paxos算法角色划分：三种类型</h1><ul>
<li><p>提议者（Proposer）：提出提案；</p>
</li>
<li><p>接受者（Acceptor）：对提案作出裁决；</p>
</li>
<li><p>告知者（Learner）：被告知投票的结果，<strong>不参与投票过程</strong>。</p>
<blockquote>
<p><font color=blue>提案（Proposal）</font>。最终要达成一致的value就在提案里。只要Proposer发的提案被Acceptor接受（半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。只要Acceptor接受了某个提案，Acceptor就任务该提案里的value被选定了。</p>
</blockquote>
<p>  <img src="https://gitee.com/CNRF/image/raw/master/img/20210302155514.png" alt="image-20210302155514766"></p>
</li>
</ul>
<p><strong>优势</strong>：为了避免单点问题：会有一个acceptor集合，proposer向该集合发送提案，acceptor集合中所有成员都有可能接受提案，并且只能批准一个提案，当有半数以上的成员同意，那么就同意批准该提案</p>
<h1 id="paxos算法过程"><a href="#paxos算法过程" class="headerlink" title="paxos算法过程"></a>paxos算法过程</h1><ul>
<li>阶段一（prepare阶段）：</li>
</ul>
<p>(a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。Pareper（N）</p>
<p>(b) 如果一个Acceptor收到一个编号为N的Prepare请求，如果小于它已经响应过的请求，则拒绝，不回应或回复error。若N大于该Acceptor已经响应过的所有Prepare请求的编号（maxN），那么它就会将它已经接受过（已经经过第二阶段accept的提案）的编号最大的提案（如果有的话，如果还没有的accept提案的话返回{pok，null，null}）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案</p>
<ul>
<li>阶段二（accept阶段）：</li>
</ul>
<p>(a) 如果一个Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value（某个acceptor响应的它已经通过的{acceptN，acceptV}），如果响应中不包含任何提案，那么V就由Proposer自己决定。</p>
<p>(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。如果N小于Acceptor以及响应的prepare请求，则拒绝，不回应或回复error（当proposer没有收到过半的回应，那么他会重新进入第一阶段，递增提案号，重新提出prepare请求）。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302154726.png" alt="image-20210302154726554"></p>
<h1 id="paxos优缺点"><a href="#paxos优缺点" class="headerlink" title="paxos优缺点"></a>paxos优缺点</h1><p>优点：paxos算法的优点很明显，按照此方法可以对多个数据值达到一致，收敛较好。</p>
<p>缺点：paxos算法的缺点是会出现活锁问题：考虑到一种极端的情况下，有两个proposer依次提出了一系列编号递增的议案，但是最终paxos无法形成最终的议案。具体场景如下：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302154914.png" alt=""></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302154927.png" alt=""><strong>解决办法</strong>：</p>
<p>通过<strong>选取主Proposer</strong>，就可以保证Paxos算法的活性。选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来，<font color=red>只要主Proposer和过半的Acceptor能够正常进行网络通信，那么肯定会有一个提案被批准（第二阶段的accept），则可以解决死循环导致的活锁问题</font>。</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p><strong>通过选择一个主Proposer，并规定只能由主Proposer才能提出议案，整个paxos算法就可以保持活性。</strong></p>
<h1 id="Paxos算法的过半依据"><a href="#Paxos算法的过半依据" class="headerlink" title="Paxos算法的过半依据"></a>Paxos算法的过半依据</h1><p>在Paxos算法中，采用了“过半”理念，也就是少数服从多数，这使Paxos算法具有很好的容错性</p>
<h2 id="Paxos基于的过半数学原理"><a href="#Paxos基于的过半数学原理" class="headerlink" title="Paxos基于的过半数学原理"></a>Paxos基于的过半数学原理</h2><p>大多数（过半）进程组成的集合为法定集合，<font color=red> 两个法定（过半）集合必然存在非空交集，即至少有一个公共进程，称为法定集合性质</font>。 例如A,B,C,D,F进程组成的全集，法定集合Q1包括进程A,B,C，Q2包括进程B,C,D，那么Q1和Q2的交集必然不在空，C就是Q1，Q2的公共进程。如果要说Paxos最根本的原理是什么，那么就是这个简单性质。也就是说：<font color=red>两个过半的集合必然存在交集，也就是肯定是相等的，也就是肯定达成了一致</font>。</p>
<p>Paxos是基于消息传递的具有高度容错性的分布式一致性算法。<font color=red>Paxos算法引入了过半的概念，解决了2PC，3PC的太过保守的缺点，且使算法具有了很好的容错性，另外Paxos算法支持分布式节点角色之间的轮换，这极大避免了分布式单点的出现，因此Paxos算法既解决了无限等待问题，也解决了脑裂问题，是目前来说最优秀的分布式一致性算法。其中，Zookeeper的ZAB算法和Raft一致性算法都是基于Paxos的</font></p>
<p>参考文档：</p>
<ol>
<li><a href="https://www.zhihu.com/question/19787937">如何浅显易懂地解说 Paxos 的算法？</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95">paxos算法</a></li>
</ol>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
        <category>panxos</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
        <tag>panxos</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper的安装和简单操作</title>
    <url>/posts/b439f21c/</url>
    <content><![CDATA[<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><ol>
<li>系统：CentOS 7</li>
<li>Java环境： JDK8</li>
</ol>
<h1 id="下载及安装"><a href="#下载及安装" class="headerlink" title="下载及安装"></a>下载及安装</h1><p>　zookeeper有单机、伪集群、集群三种部署方式，我使用的zookeeper版本是：zookeeper-3.5.9</p>
<p>下载Zookeeper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;apache.claz.org&#x2F;zookeeper&#x2F;zookeeper-3.5.9&#x2F;apache-zookeeper-3.5.9-bin.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h2><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;解压到指定目录</span><br><span class="line">tar -zxvf apache-zookeeper-3.5.9-bin.tar.gz   -C &#x2F;user&#x2F;soft&#x2F;</span><br></pre></td></tr></table></figure>
<p>解压后目录</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301110436.png" alt="image-20210301110435970"></p>
<p>进入conf目录，创建一个zookeeper的配置文件zoo.cfg，可复制conf/zoo_sample.cfg作为配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<h3 id="配置文件说明："><a href="#配置文件说明：" class="headerlink" title="配置文件说明："></a>配置文件说明：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line"># tickTime：CS通信心跳数</span><br><span class="line"># Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。tickTime以毫秒为单位。</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"></span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">#initLimit：LF初始通信时限</span><br><span class="line"># 集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量）。</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"></span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line"># syncLimit：LF同步通信时限</span><br><span class="line"># 集群中的follower服务器与leader服务器之间请求和应答之间能容忍的最多心跳数（tickTime*syncLimit ）。</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># dataDir：数据文件目录</span><br><span class="line"># Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;apache-zookeeper-3.6.2-bin&#x2F;data</span><br><span class="line"></span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">#clientPort：客户端连接端口</span><br><span class="line">#客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"></span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#最大连接数</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#保留数量3</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"></span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#清理时间间隔1小时</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br><span class="line"></span><br><span class="line">## Metrics Providers</span><br><span class="line">#</span><br><span class="line"># https:&#x2F;&#x2F;prometheus.io Metrics Exporter</span><br><span class="line">#metricsProvider.className&#x3D;org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span><br><span class="line">#metricsProvider.httpPort&#x3D;7000</span><br><span class="line">#metricsProvider.exportJvmInfo&#x3D;true</span><br><span class="line"></span><br><span class="line"> # 服务器名称与地址：集群信息（服务器编号，服务器地址，LF通信端口，选举端口）</span><br><span class="line"># 这个配置项的书写格式比较特殊，规则如下：</span><br><span class="line"># server.N&#x3D;YYY:A:B   </span><br><span class="line"># 其中N表示服务器编号，YYY表示服务器的IP地址，A为LF通信端口，表示该服务器与集群中的leader交换的信息的端口。B为选举端口，表示选举新leader时服务器间相互通信的端口（当leader挂掉时，其余服务器会相互通信，选择出新的leader）。一般来说，集群中每个服务器的A端口都是一样，每个服务器的B端口也是一样。但是当所采用的为伪集群时，IP地址都一样，只能时A端口和B端口不一样。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="启动及停止服务"><a href="#启动及停止服务" class="headerlink" title="启动及停止服务"></a>启动及停止服务</h3><p>可以不修改zoo.cfg，默认配置就行，进去zookeeper安装目录，启动ZooKeeper</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动命令：</span></span><br><span class="line">./bin/zkServer.sh start</span><br><span class="line"><span class="comment">#在前端启动，可看启动日志</span></span><br><span class="line">./bin/zkServer.sh start-foreground</span><br><span class="line"><span class="comment">#停止命令：</span></span><br><span class="line">./bin/zkServer.sh stop　　</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启命令：</span></span><br><span class="line">./bin/zkServer.sh restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#状态查看命令：</span></span><br><span class="line">./bin/zkServer.sh status</span><br></pre></td></tr></table></figure>
<h2 id="伪集群模式"><a href="#伪集群模式" class="headerlink" title="伪集群模式"></a>伪集群模式</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在同一台主机上，通过复制得到三个zookeeper实例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp -r  /usr/soft/zookeeper/Zookeeper   /usr/soft/zookeeper/Zookeeper2</span><br></pre></td></tr></table></figure>
<h3 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h3><p>zookeeper1配置文件conf/zoo.cfg修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper1&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper1&#x2F;logs</span><br><span class="line">clientPort&#x3D;12181</span><br><span class="line"></span><br><span class="line">server.1&#x3D;127.0.0.1:12888:13888</span><br><span class="line">server.2&#x3D;127.0.0.1:14888:15888</span><br><span class="line">server.3&#x3D;127.0.0.1:16888:17888</span><br></pre></td></tr></table></figure>
<p>注：server.1中的数字1为<strong>服务器的ID</strong>，需要与<strong>myid文件中的id一致</strong>，下一步将配置myid</p>
<p>zookeeper1的data/myid配置，使用如下命令（即新建一个文件data/myid，在其中添加内容为：1）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1&#x27;</span> &gt; data/myid</span><br></pre></td></tr></table></figure>
<p>zookeeper2配置文件conf/zoo.cfg修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper2&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper2&#x2F;logs</span><br><span class="line">clientPort&#x3D;12182</span><br><span class="line"></span><br><span class="line">server.1&#x3D;127.0.0.1:12888:13888</span><br><span class="line">server.2&#x3D;127.0.0.1:14888:15888</span><br><span class="line">server.3&#x3D;127.0.0.1:16888:17888</span><br></pre></td></tr></table></figure>
<p>zookeeper2的data/myid配置，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;2&#39; &gt; data&#x2F;myid</span><br></pre></td></tr></table></figure>
<p>zookeeper3配置文件conf/zoo.cfg修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper3&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper3&#x2F;logs</span><br><span class="line">clientPort&#x3D;12183</span><br><span class="line"></span><br><span class="line">server.1&#x3D;127.0.0.1:12888:13888</span><br><span class="line">server.2&#x3D;127.0.0.1:14888:15888</span><br><span class="line">server.3&#x3D;127.0.0.1:16888:17888</span><br></pre></td></tr></table></figure>
<p>zookeeper3的data/myid配置，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;3&#39; &gt; data&#x2F;myid</span><br></pre></td></tr></table></figure>
<p>分别启动三个zookeeper节点</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301134558.png" alt="image-20210301134558405"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301134626.png" alt="image-20210301134626147"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301134728.png" alt="image-20210301134728171"></p>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>参考伪集群模式</p>
<p>　　　　1、在三台机器上分别部署1个ZooKeeper实例</p>
<p>　　　　2、zookeeper配置文件conf/zoo.cfg，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper1&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;soft&#x2F;zookeeper&#x2F;zookeeper1&#x2F;logs</span><br><span class="line">clientPort&#x3D;12181</span><br><span class="line"></span><br><span class="line">server.1&#x3D;127.0.0.1:12888:13888</span><br><span class="line">&#x2F;&#x2F;修改为2，3节点的ip</span><br><span class="line">server.2&#x3D;127.0.0.1:14888:15888</span><br><span class="line">server.3&#x3D;127.0.0.1:16888:17888</span><br></pre></td></tr></table></figure>
<p>3、zookeeper的data/myid配置，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 echo &#39;1&#39; &gt; data&#x2F;myid</span><br></pre></td></tr></table></figure>
<p>zookeeper1 对应的是 1，zookeeper2 对应的是 2，zookeeper3 对应的是 3</p>
<p>　　4、分别启动三个zookeeper节点，即完成对ZooKeeper集群的安装</p>
<h1 id="Zookeeper简单操作"><a href="#Zookeeper简单操作" class="headerlink" title="Zookeeper简单操作"></a>Zookeeper简单操作</h1><p>a、使用客户端连接ZooKeeper服务</p>
<p>　命令：<code>./bin/zkCli.sh -server 127.0.0.1:12181</code></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301140944.png" alt="image-20210301140944047"></p>
<p>b、使用 ls 命令来查看当前 ZooKeeper 中所包含的内容：<br>命令：<font color=blue>ls /</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301141124.png" alt="image-20210301141124292"></p>
<p>c 、创建节点</p>
<p>命令 ：<font color=blue>create /zk myData</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301141402.png" alt="image-20210301141402229"></p>
<p>d、获取节点‘zk’</p>
<p>命令：<font color=blue>get /zk</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301141449.png" alt="image-20210301141449291"></p>
<p>e、删除znode节点“ zk </p>
<p>命令：<font color=blue>delete /zk</font></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210301141725.png" alt="image-20210301141725018"></p>
<p>f、退出客户端</p>
<p>命令：<font color=blue>quit</font></p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性理论，CAP，BASE理论</title>
    <url>/posts/6afaddd1/</url>
    <content><![CDATA[<h1 id="分布式的问题"><a href="#分布式的问题" class="headerlink" title="分布式的问题"></a>分布式的问题</h1><p>分布式因为<strong>网络的不确定性</strong>，<strong>节点故障等情况</strong>，会带来各种复杂的问题。我们在学习分布式的相关理论时，一定要明确这样一个<strong>道理</strong>，就是：网络不可靠，网络分区以及节点宕机是常态，另外网络带宽资源是及其珍贵的，我们<font color=red>必须在网络不可靠、分区以及节点宕机的前提下，构建高性能、高可用的分布式系统</font>。</p>
<h2 id="分布式环境的问题"><a href="#分布式环境的问题" class="headerlink" title="分布式环境的问题"></a>分布式环境的问题</h2><ol>
<li><strong>通信异常</strong>：从集中式向分布式演变过程中，必然会引入网络因素，而由于网络本身的不可靠性，因此也引入了额外的问题。<strong>分布式系统需要在各个节点之间进行网络通信，因此当网络通信设备故障就会导致无法顺利完成一次网络通信，就算各节点的网络通信正常，但是消息丢失和消息延时也是非常普遍的事情</strong>。</li>
<li><strong>网络分区（脑裂）</strong>：网络发生异常情况导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点，只有部分节点能够正常通行，而另一些节点则不能。我们称这种情况叫做网络分区（脑裂），当网络分区出现时，<strong>分布式系统会出现多个局部小集群（多个小集群可能又会产生多个master节点），所以分布式系统要求这些小集群要能独立完成原本需要整个分布式系统才能完成的功能</strong>，这就对分布式一致性提出了非常大的挑战。</li>
<li><strong>节点故障</strong>：节点宕机是分布式环境中的常态，每个节点都有可能会出现宕机或僵死的情况，并且每天都在发生。</li>
<li><strong>三态</strong>：由于网络不可靠的原因，因此<strong>分布式系统的每一次请求，都存在特有的“三态”概念，即：成功，失败与超时</strong>。在集中式单机部署中，由于没有网络因素，所以程序的每一次调用都能得到“成功”或者“失败”的响应，但是在分布式系统中，网络不可靠，可能就会出现超时的情况。<strong>可能在消息发送时丢失或者在响应过程中丢失，当出现超时情况时，网络通信的发起方是无法确定当前请求是否被成功处理的，所以这也是分布式事务的难点</strong>。</li>
</ol>
<h1 id="分布式数据一致性问题"><a href="#分布式数据一致性问题" class="headerlink" title="分布式数据一致性问题"></a>分布式数据一致性问题</h1><p>在分布式系统中，<strong>节点宕机是常态</strong>，为了高可用性，我们一般会部署多台服务器，势必就会存在<strong>数据的复制问题</strong>，分布式系统对于数据的复制需求一般来自于以下两个原因：</p>
<blockquote>
<ul>
<li>高可用：将数据复制到分布式部署的多台机器中，可以消除单点故障，防止系统由于某台（些）机器宕机导致的不可用。</li>
<li>性能：通过负载均衡技术，能够让分布在不同地方的数据副本全都对外提供服务。有效提高系统性能。</li>
</ul>
</blockquote>
<p><strong>在分布式系统引入复制机制后，不同的数据节点之间由于网络延时等原因很容易产生数据不一致的情况</strong>。复制机制的目的是为了保证数据的一致性。但是数据复制面临的主要难题也是如何保证多个副本之间的数据一致性。其中，常见的就是主从数据库之间的复制延时问题。</p>
<blockquote>
<p>Zookeeper就是分布式一致性问题的工业解决方案，paxos是理论算法，其中zab，raft和众多开源算法是对paxos的工业级实现。Zookeeper使用zab来保证其自身系统的高可用与数据一致性的。</p>
</blockquote>
<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p>
<p>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</p>
<p>可用性（A）：保证每个请求不管成功或者失败都有响应。</p>
<p>分区容忍性（P）：系统中任意信息的丢失或失败不会影响系统的继续运作。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210302163013.png" alt="image-20210302163013412"></p>
<p>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足</p>
<h2 id="一致性与可用性的决择编辑"><a href="#一致性与可用性的决择编辑" class="headerlink" title="一致性与可用性的决择编辑"></a>一致性与可用性的决择编辑</h2><p>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以<font color=red>分区容忍性是我们必须需要实现的</font>。所以我们<font color=red>只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点</font>。</p>
<p>CAP三个特性只能满足其中两个，那么取舍的策略就共有三种：</p>
<p><strong><font color=red>CA without P</font>：</strong>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。<strong>传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</strong></p>
<p><strong><font color=red>CP without A </font>：</strong>如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，<strong>最典型的就是分布式数据库，如Redis、HBase等</strong>。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p>
<p> <strong><font color=red>AP wihtout C</font>：</strong>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，<font color=red>其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）</font></p>
<h2 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h2><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</p>
<ul>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</li>
<li>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ul>
<p>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据听不的过程存在延时。</p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>最终一致性强调的是<font color=red>系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态</font>。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
        <category>分布式</category>
        <category>CAP</category>
        <category>BASE理论</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>分布式</tag>
        <tag>CAP</tag>
        <tag>BASE理论</tag>
      </tags>
  </entry>
  <entry>
    <title>修复点击目录无法跳转</title>
    <url>/posts/14f8dec7/</url>
    <content><![CDATA[<p>在 themes/next/source/js/util.js 中增加两行代码，删除两行代码。保存，hexo clean &amp; hexo g &amp; hexo s 即可解决。（如果还是不行就删除浏览器缓存重试）</p>
<p><a href="https://github.com/theme-next/hexo-theme-next/pull/1540/files">中文目录层级无法跳转</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210225115114.png" alt="image-20210225115114883"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">registerSidebarTOC: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> navItems = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.post-toc li&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> sections = [...navItems].map(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> link = element.querySelector(<span class="string">&#x27;a.nav-link&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(<span class="built_in">decodeURI</span>(link.getAttribute(<span class="string">&#x27;href&#x27;</span>)).replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    <span class="comment">// TOC item animation navigate.</span></span><br><span class="line">    link.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">      <span class="comment">// var target = document.getElementById(event.currentTarget.getAttribute(&#x27;href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;));</span></span><br><span class="line">      <span class="keyword">var</span> offset = target.getBoundingClientRect().top + <span class="built_in">window</span>.scrollY;</span><br><span class="line">      <span class="built_in">window</span>.anime(&#123;</span><br><span class="line">        targets  : <span class="built_in">document</span>.scrollingElement,</span><br><span class="line">        duration : <span class="number">500</span>,</span><br><span class="line">        easing   : <span class="string">&#x27;linear&#x27;</span>,</span><br><span class="line">        scrollTop: offset + <span class="number">10</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">    <span class="comment">// return document.getElementById(link.getAttribute(&#x27;href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;));</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客优化Next7主题优化</title>
    <url>/posts/33ffdf26/</url>
    <content><![CDATA[<h1 id="设置站点名等"><a href="#设置站点名等" class="headerlink" title="设置站点名等"></a>设置站点名等</h1><p>打开<strong>根目录下的<code>_config.yml</code></strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">三才生的个人笔记</span>   <span class="comment">#标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">三才生的个人笔记</span>  <span class="comment">#标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">三才生的个人笔记</span> <span class="comment">#标题</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">CNRF</span>     <span class="comment">#作者名称</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>  <span class="comment">#设置简体中文</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">UTC</span>	<span class="comment">#设置时区</span></span><br></pre></td></tr></table></figure>
<h1 id="选择scheme"><a href="#选择scheme" class="headerlink" title="选择scheme"></a>选择scheme</h1><p>在主目录的\source_data\next.yml中，,查找<code>scheme</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<h1 id="设置菜单及对应页面"><a href="#设置菜单及对应页面" class="headerlink" title="设置菜单及对应页面"></a>设置菜单及对应页面</h1><p>在主目录的\source_data\next.yml中，查找<code>menu</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">heartbeat</span></span><br></pre></td></tr></table></figure>
<p>去掉<code>#</code>注释即可显示对应的菜单项，也可自定义新的菜单项。 <code>||</code>之前的值是目标链接，之后的是分类页面的图标，图标名称来自于FontAwesome icon。若没有配置图标，默认会使用问号图标。</p>
<p>新添加的菜单需要翻译对应的中文<br>打开<code>hexo/theme/next/languages/zh-CN.yml</code>，在menu下自定义，如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">资源</span></span><br></pre></td></tr></table></figure>
<p>配置新增的菜单</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;commonweal&quot;</span><br></pre></td></tr></table></figure>
<p>在<strong>主目录下source</strong>新建404.html</p>
<blockquote>
<p><strong>Hexo 默认会渲染所有的 HTML 和 Markdown 文件</strong>。</p>
</blockquote>
<p>因此我们可以简单地在文件开头加上 <code>layout: false</code> 一行来避免渲染：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+layout: false</span><br><span class="line">+---</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>404<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">homePageUrl</span>=<span class="string">&quot;/&quot;</span> <span class="attr">homePageName</span>=<span class="string">&quot;返回&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="设定站点建立时间"><a href="#设定站点建立时间" class="headerlink" title="设定站点建立时间"></a>设定站点建立时间</h1><p>打开<strong><code>themes/next/</code>下的<code>_config.yml</code></strong>，查找<code>since</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup.</span></span><br><span class="line">  <span class="comment"># If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2015</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>如果不设置，默认显示当前年份</strong>。</p>
<h1 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h1><p>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>avatar</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar111.png</span>  <span class="comment"># 设置头像资源的位置</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span>            <span class="comment"># 开启圆形头像</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1</span>               <span class="comment"># 不透明的比例：0就是完全透明</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span>           <span class="comment"># 不开启旋转</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224210106.png" alt="image-20210224210106776"></p>
<p><code>avatar</code>的值是<strong>图片的链接地址</strong>(完整的URI 或者 站内的相对地址皆可)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>地址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>完整的URI</td>
<td><a href="http://example.com/avatar.png">http://example.com/avatar.png</a></td>
</tr>
<tr>
<td>站点内地址</td>
<td>图片放至<code>themes/next/source/images/</code>配置为：<code>avatar: /images/图片名</code></td>
</tr>
<tr>
<td>站点内地址</td>
<td>图片放至<strong>根目录下</strong><code>source/uploads/</code>(初始无uploads文件夹，自行创建)目录下配置为：<code>avatar: /uploads/图片名</code></td>
</tr>
</tbody>
</table>
</div>
<h1 id="网站图标设置"><a href="#网站图标设置" class="headerlink" title="网站图标设置"></a>网站图标设置</h1><ul>
<li><p>图标素材网站：<a href="https://www.iconfont.cn/">iconfont</a>；<a href="https://www.easyicon.net/">easyicon</a></p>
</li>
<li><p>下载16x16以及32x32大小的<strong>PNG格式图标</strong>，置于<code>/themes/next/source/images/</code>下</p>
</li>
<li><p>打开<strong><code>source/_data</code>下的<code>next.yml</code></strong>，查找<code>favicon</code></p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>
<p>  修改small和medium的路径为下载的图标路径</p>
</li>
</ul>
<h1 id="配置hexo本地搜索"><a href="#配置hexo本地搜索" class="headerlink" title="配置hexo本地搜索"></a>配置hexo本地搜索</h1><h2 id="本地搜索的原理"><a href="#本地搜索的原理" class="headerlink" title="本地搜索的原理"></a>本地搜索的原理</h2><p>对于动态网站来说，可以通过 php 实现。但是，Hexo 博客是静态网站，用不了 php。</p>
<p>NexT 主题已经实现这个功能，它用了 Hexo 的拓展包 <code>hexo-generator-searchdb</code>，预先生成了一个文本库 <code>search.xml</code>，然后传到了网站里面。在本地搜索的时候，NexT 直接用 javascript 调用了这个文件，从而实现了静态网站的本地搜索。</p>
<h2 id="设置过程"><a href="#设置过程" class="headerlink" title="设置过程"></a>设置过程</h2><p>安装插件:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save #安装 hexo-generator-search</span><br><span class="line">npm install hexo-generator-searchdb --save #安装 hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>然后我们修改站点配置<code>_config.yml</code> 文件，添加如下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<ul>
<li>path：索引文件的路径，相对于站点根目录</li>
<li>field：搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面</li>
<li>limit：限制搜索的条目数</li>
</ul>
<p>然后修改主题配置文件next.yml`：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="配置-hexo-站点的-footer-信息"><a href="#配置-hexo-站点的-footer-信息" class="headerlink" title="配置 hexo 站点的 footer 信息"></a>配置 hexo 站点的 footer 信息</h1><p>底部 <code>footer</code> 可以开关显示 hexo 信息、theme 信息、建站时间等个性化配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span>        <span class="comment"># 建站开始时间</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span>       <span class="comment"># 设置 建站初始时间和至今时间中间的图标，默认是一个&#x27;小人像&#x27;，更改user为heart可以变成一个心</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span> <span class="comment"># 更改图标的颜色，红色为&#x27;#ff0000&#x27;</span></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>     <span class="comment"># 开启hexo驱动</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span>    <span class="comment"># 开启hexo版本号</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>     <span class="comment"># 开启主题驱动</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span>    <span class="comment"># 开启主题版本号</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">Hosted</span> <span class="string">by</span> <span class="string">&lt;a</span> <span class="string">target=&quot;_blank&quot;</span> <span class="string">rel=&quot;external</span> <span class="string">nofollow&quot;</span> <span class="string">href=&quot;https://pages.coding.me&quot;&gt;&lt;b&gt;Coding</span> <span class="string">Pages&lt;/b&gt;&lt;/a&gt;</span> <span class="comment"># 这里的底部标识是为了添加coding page服务时的版权声明 打开注释就可以看到底部有一个 hosted by coding pages</span></span><br></pre></td></tr></table></figure>
<h1 id="首页文章不展示全文显示摘要"><a href="#首页文章不展示全文显示摘要" class="headerlink" title="首页文章不展示全文显示摘要"></a>首页文章不展示全文显示摘要</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">true</span>      <span class="comment"># 点击阅读全文后是否跳到&lt;!--more--&gt;标记处,设为false时点击阅读全文可以从头阅读</span></span><br><span class="line"></span><br><span class="line"><span class="attr">save_scroll:</span> <span class="literal">false</span>        <span class="comment"># 自动保存每篇文章或页面上一次滚动的地方</span></span><br><span class="line"></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span> <span class="comment"># 自动在首页对文章进行摘要描述作为前言文本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">auto_excerpt:</span>   <span class="comment"># 是否自动截取摘要</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># 设置为true则自动截取150字当做首页摘要</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span>   <span class="comment"># 自动截取的字数</span></span><br></pre></td></tr></table></figure>
<p>注意需要在md文件前面加<strong>yaml front matter</strong>中相关元素</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">centos安装redis</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-01 23:47:44</span> </span><br><span class="line"><span class="attr">categories:</span> <span class="string">&quot;redis&quot;</span> </span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line">     <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">标签二</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;centos7 安装redis&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="首页文章属性"><a href="#首页文章属性" class="headerlink" title="首页文章属性"></a>首页文章属性</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">false</span>    <span class="comment"># 设为true 可以一行显示，文章的所有属性</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span>    <span class="comment"># 显示创建时间</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>     <span class="comment"># 显示修改的时间</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span> <span class="comment"># 设true时，如果创建时间和修改时间一样则显示一个时间</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span>    <span class="comment"># 显示分类信息</span></span><br></pre></td></tr></table></figure>
<h1 id="页面阅读统计"><a href="#页面阅读统计" class="headerlink" title="页面阅读统计"></a>页面阅读统计</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>              <span class="comment"># 设true 开启</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>       <span class="comment"># 总阅读人数（uv数）</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span>  <span class="comment"># 阅读总人数的图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>          <span class="comment"># 总阅读次数（pv数）</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span>      <span class="comment"># 阅读总次数的图标</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>           <span class="comment"># 开启内容阅读次数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span>       <span class="comment"># 内容页阅读数的图标</span></span><br></pre></td></tr></table></figure>
<h1 id="字数统计、阅读时长"><a href="#字数统计、阅读时长" class="headerlink" title="字数统计、阅读时长"></a>字数统计、阅读时长</h1><p>首先安装插件：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-<span class="built_in">time</span> --save #运行一次会报错导致配置不生效</span><br><span class="line">npm install hexo-symbols-count-<span class="built_in">time</span> --save</span><br></pre></td></tr></table></figure>
<p>主题配置文件<code>_config.yml</code> 修改如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>  <span class="comment"># false会显示一行</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>  <span class="comment"># 显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span> <span class="comment"># 底部footer是否显示字数统计属性文字</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>                <span class="comment"># 计算字数的一个设置,没设置过</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>              <span class="comment"># 一分钟阅读的字数</span></span><br></pre></td></tr></table></figure>
<p>站点配置文件<code>next.yml</code> 新增如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"> <span class="comment">#文章内是否显示</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line"> <span class="comment"># 网页底部是否显示</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="内容页里的代码块新增复制按钮"><a href="#内容页里的代码块新增复制按钮" class="headerlink" title="内容页里的代码块新增复制按钮"></a>内容页里的代码块新增复制按钮</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>      <span class="comment"># 增加复制按钮的开关</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">false</span> <span class="comment"># 点击复制完后是否显示 复制成功 结果提示</span></span><br></pre></td></tr></table></figure>
<h1 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h1><p>鼠标的点击红心特效<br>在/themes/next/source/js/src下新建文件clicklove.js ，接着把下面的代码拷贝粘贴到 clicklove.js 文件中：7.8 next没有src文件夹，先建一个src文件夹</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">&quot;left:&quot;</span>+d[e].x+<span class="string">&quot;px;top:&quot;</span>+d[e].y+<span class="string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="string">&quot;,&quot;</span>+d[e].scale+<span class="string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">&quot;function&quot;</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;div&quot;</span>);a.className=<span class="string">&quot;heart&quot;</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX-<span class="number">5</span>,<span class="attr">y</span>:e.clientY-<span class="number">5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;style&quot;</span>);a.type=<span class="string">&quot;text/css&quot;</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">&quot;rgb(&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;)&quot;</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">setTimeout</span>(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在\themes\next\layout_layout.swig文件末尾添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/src/clicklove.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224214118.png" alt="image-20210224214118864"></p>
<h1 id="添加网页顶部进度加载条"><a href="#添加网页顶部进度加载条" class="headerlink" title="添加网页顶部进度加载条"></a>添加网页顶部进度加载条</h1><p>在主目录下载安装Progress module，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-pace source&#x2F;lib&#x2F;pace</span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="comment">#theme: minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">pace-theme-minimal</span></span><br></pre></td></tr></table></figure>
<h1 id="Footer-页脚设置"><a href="#Footer-页脚设置" class="headerlink" title="Footer / 页脚设置"></a>Footer / 页脚设置</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2015</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="comment">## 图标的一个动画效果，类似于心跳</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="comment"># 图标颜色，可格局需要自行修改</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Powered by Hexo 字样，不喜欢可以设置为 false</span></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 主题字样，不喜欢可以 false</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Beian ICP and gongan information for Chinese users. See: http://www.beian.miit.gov.cn, http://www.beian.gov.cn</span></span><br><span class="line">  <span class="comment"># 备案信息，如果网站有备案号，可以在这里填写备案号</span></span><br><span class="line">  <span class="attr">beian:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">icp:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Creative-Commons-文章版权"><a href="#Creative-Commons-文章版权" class="headerlink" title="Creative Commons / 文章版权"></a>Creative Commons / 文章版权</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span></span><br><span class="line"><span class="comment"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>
<p>在文章 .md 文件中的上部，添加 copyright: true。</p>
<h1 id="开启文章目录"><a href="#开启文章目录" class="headerlink" title="开启文章目录"></a>开启文章目录</h1><p>修改主题配置文件<strong>next.ym</strong>l</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Table of Contents in the Sidebar</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front-matter.</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="GitHub-Fork-Me"><a href="#GitHub-Fork-Me" class="headerlink" title="GitHub Fork Me"></a>GitHub Fork Me</h1><p>修改主题配置文件<strong>next.ym</strong>l</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/CNRF</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="bookmark"><a href="#bookmark" class="headerlink" title="bookmark"></a>bookmark</h1><p>Bookmark是一个插件，允许用户保存他们的阅读进度。用户只需单击页面左上角的书签图标即可保存滚动位置。当他们下次访问您的博客时，他们可以自动恢复每个页面的最后滚动位置。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bookmark:</span>	</span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize the color of the bookmark.	</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#222&quot;</span>	</span><br><span class="line">  <span class="comment"># If auto, save the reading progress when closing the page or clicking the bookmark-icon.	</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.	</span></span><br><span class="line">  <span class="attr">save:</span> <span class="string">auto</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="添加lazyload"><a href="#添加lazyload" class="headerlink" title="添加lazyload"></a>添加lazyload</h1><p>对于图片进行延迟加载，访问到图片位置时才去请求图片资源，这样可以提高博客的访问速度，节省流量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-jquery-lazyload source&#x2F;lib&#x2F;jquery_lazyload</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="显示当前浏览进度"><a href="#显示当前浏览进度" class="headerlink" title="显示当前浏览进度"></a>显示当前浏览进度</h1><p>修改主题配置文件<strong>next.ym</strong>l</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Scroll percent label in b2t button.# # 是否显示页面浏览百分比</span></span><br><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224220253.png" alt="image-20210224220253001"></p>
<h1 id="支持数学公式"><a href="#支持数学公式" class="headerlink" title="支持数学公式"></a>支持数学公式</h1><p>可能在一些情况下我们需要写一个公式，makdown是支持的，next也支持。</p>
<p>Next 主题提供了两个渲染引擎，分别是 mathjax 和katex，后者相对前者来说渲染速度更快，而且不需要 JavaScript 的额外支持，但后者支持的功能现在还不如前者丰富，具体的对比可以看官方文档：<a href="https://theme-next.org/docs/third-party-services/math-equations。">https://theme-next.org/docs/third-party-services/math-equations。</a></p>
<p>这里选择 mathjax ,通过修改配置即可启用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm uninstall hexo-renderer-marked --save</span><br><span class="line">sudo npm install hexo-renderer-kramed --save</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>注意：使用的时候需要在 <strong>文章开头加上mathjax: true</strong></p>
<h1 id="添加音乐和视频"><a href="#添加音乐和视频" class="headerlink" title="添加音乐和视频"></a>添加音乐和视频</h1><h2 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h2><p>打开网易云，找到你想要添加的歌曲或者歌单，点生成<code>外链播放器</code> 然后复制代码</p>
<p>将代码放到…<code>/themes/hexo-theme-next/layout/_macro/sidebar.swig</code>文件下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--新增163播放器--&gt;</span><br><span class="line">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;298 height&#x3D;52 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;0&amp;id&#x3D;756579097&amp;auto&#x3D;0&amp;height&#x3D;32&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210225094310.png" alt="image-20210225094310438"></p>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>1）直接用 HTML 的标签，写法如下：</p>
<p>复制<br>Your browser does not support the video tag.<br>2）用插件，可支持弹幕，首先在站点文件夹根目录安装插件：</p>
<p>复制<br>npm install hexo-tag-dplayer —save<br>然后文章中的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% dplayer “url&#x3D;https:&#x2F;&#x2F;什么什么什么.mp4” “https:&#x2F;&#x2F;封面图.jpg” “api&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer&#x2F;” “id&#x3D;” “loop&#x3D;false” %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% dplayer &quot;url&#x3D;https:&#x2F;&#x2F;moeplayer.b0.upaiyun.com&#x2F;dplayer&#x2F;hikarunara.mp4&quot; &quot;api&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer3&#x2F;&quot; &quot;addition&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer3&#x2F;v2&#x2F;bilibili?aid&#x3D;120040&quot; &quot;pic&#x3D;https:&#x2F;&#x2F;moeplayer.b0.upaiyun.com&#x2F;dplayer&#x2F;hikarunara.jpg&quot; &quot;id&#x3D;9E2E3368B56CDBB4&quot; &quot;loop&#x3D;yes&quot; &quot;theme&#x3D;#FADFA3&quot; &quot;autoplay&#x3D;false&quot; &quot;token&#x3D;tokendemo&quot; %&#125;  </span><br><span class="line">&#123;% dplayer &#39;url&#x3D;some.mp4&#39; &quot;id&#x3D;someid&quot; &quot;api&#x3D;https:&#x2F;&#x2F;api.prprpr.me&#x2F;dplayer&#x2F;&quot; &quot;addition&#x3D;&#x2F;some.json&quot; &#39;code&#x3D;player.on(&quot;loadstart&quot;,function()&#123;console.log(&quot;loadstart&quot;)&#125;)&#39; &quot;autoplay&quot; %&#125;</span><br></pre></td></tr></table></figure>
<p>要使用弹幕，必须有api和id两项，并且若使用的是官方的 api 地址（即上面的），id 的值不能与这个列表的值一样。id 的值自己随便取，唯一要求就是前面这点。如果唯一要求难倒了你，可以使用这个工具将一段与众不同的文字?生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。</p>
<p>要使用弹幕，必须有api和id两项，并且若使用的是官方的 api 地址（即上面的），id 的值不能与这个列表的值一样。id 的值自己随便取，唯一要求就是前面这点。如果唯一要求难倒了你，可以使用这个工具将一段与众不同的文字?生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。</p>
<p>当然，这个插件的功能还有很多，可以去 README 和这插件的「母亲」Dplayer 的官方文档看看。</p>
<h1 id="文章末尾统一添加“本文结束”标记"><a href="#文章末尾统一添加“本文结束”标记" class="headerlink" title="文章末尾统一添加“本文结束”标记"></a>文章末尾统一添加“本文结束”标记</h1><p>修改主题配置文件<strong>next.ym</strong>l</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">postBodyEnd:</span> <span class="string">source/_data/post-body-end.swig</span></span><br></pre></td></tr></table></figure>
<p>在路径 /source/_data 下创建/修改 post-body-end.swig文件，并添加以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">&quot;text-align:center;color: #ccc;font-size:14px;&quot;</span>&gt;-------------本文结束&lt;i class=<span class="string">&quot;fa fa-paw&quot;</span>&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h1 id="主题及标题栏背景图"><a href="#主题及标题栏背景图" class="headerlink" title="主题及标题栏背景图"></a>主题及标题栏背景图</h1><p>首先主题配置文件取消注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: <span class="built_in">source</span>/_data/styles.styl</span><br></pre></td></tr></table></figure>
<p>在主目录source/_data创建/修改 <strong>styles.styl</strong>文件，并添加以下内容</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  background: url(https://source.unsplash.com/random/1600x900?wallpapers);//自己喜欢的图片地址</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>:fixed; <span class="comment">//不重复</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;      <span class="comment">//填充</span></span><br><span class="line">  <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//博客内容透明化</span></span><br><span class="line"><span class="comment">//文章内容的透明度设置</span></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单栏的透明度设置</span></span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索框（local-search）的透明度设置</span></span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="修改文章底部的-号的标签，改为图标"><a href="#修改文章底部的-号的标签，改为图标" class="headerlink" title="修改文章底部的#号的标签，改为图标"></a>修改文章底部的#号的标签，改为图标</h1><p>修改模板<code>/themes/next/layout/_macro/post.swig</code></p>
<p>搜索 rel=”tag”，修改此行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;a href&#x3D;&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel&#x3D;&quot;tag&quot;&gt;&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">替换为</span><br><span class="line"> &lt;a href&#x3D;&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel&#x3D;&quot;tag&quot;&gt;&lt;i class&#x3D;&quot;fa fa-tag&quot;&gt;&lt;&#x2F;i&gt; &#123;&#123; tag.name &#125;&#125;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<h1 id="修改文章链接"><a href="#修改文章链接" class="headerlink" title="修改文章链接"></a>修改文章链接</h1><p>在做次优化之前，hexo-next文章链接默认的生成规则是：<code>:year/:month/:day/:title</code>，是按照年、月、日、标题来生成的。<br>比如：<code>https://zxiaoxuan.github.io/2019/08/12/hello-world/</code> 这样，如果文章标题是中文的话，URL链接是也会是中文，</p>
<p><strong>安装插件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行此命令可能会不成功，提示你缺少相应的依赖，比如babel-eslint、mini-css-extract-plugin、webpack-cli…<br>使用npm命令安装即可，比如npm install eslint@4.x babel-eslint@8 —save-dev</p>
</blockquote>
<p>修改根目录站点配置文件<code>config.yml</code>，改为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">	<span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">	<span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>生成的链接将会是这样的(官方样例)：<br><strong>四种可供选择</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;66c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;65535.html</span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;8ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;1690090958.html</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>
<p>生成完后，原<code>md</code>文件的<code>Front-matter</code> 内会增加<code>abbrlink</code> 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址。</p>
<h1 id="设置tag界面彩色标签"><a href="#设置tag界面彩色标签" class="headerlink" title="设置tag界面彩色标签"></a>设置tag界面彩色标签</h1><p>在<code>/themes/next/layout/</code>目录下，新增<code>tag-color.swig</code>文件，加入下方代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">     <span class="keyword">var</span> alltags = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;tag-cloud-tags&#x27;</span>);</span><br><span class="line">     <span class="keyword">var</span> tags = alltags[<span class="number">0</span>].getElementsByTagName(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = tags.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">       <span class="keyword">var</span> r=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">75</span>+<span class="number">130</span>);</span><br><span class="line">       <span class="keyword">var</span> g=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">75</span>+<span class="number">100</span>);</span><br><span class="line">       <span class="keyword">var</span> b=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">75</span>+<span class="number">80</span>);</span><br><span class="line">       tags[i].style.background = <span class="string">&quot;rgb(&quot;</span>+r+<span class="string">&quot;,&quot;</span>+g+<span class="string">&quot;,&quot;</span>+b+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .tag-cloud-tags&#123;</span><br><span class="line">    <span class="comment">/*font-family: Helvetica, Tahoma, Arial;*/</span></span><br><span class="line">    <span class="comment">/*font-weight: 100;*/</span></span><br><span class="line">    text-align: center;</span><br><span class="line">    counter-reset: tags;</span><br><span class="line">  &#125;</span><br><span class="line">  .tag-cloud-tags a&#123;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    margin: 8px 5px 0px 0px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .tag-cloud-tags a:hover&#123;</span><br><span class="line">     box-shadow: 0px 5px 15px 0px rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.4</span>);</span><br><span class="line">     transform: scale(<span class="number">1.1</span>);</span><br><span class="line">     <span class="comment">/*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*/</span></span><br><span class="line">     transition-duration: <span class="number">0.</span>15s;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在/themes/next/layout/page.swig/中引入tag-color.swig：</p>
<p>在下方加上 <code>&#123;% include 'tag-color.swig' %&#125;</code> 代码</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224235234.png" alt="image-20210224235234310"></p>
<h6 id="把标签放到首页"><a href="#把标签放到首页" class="headerlink" title="把标签放到首页"></a>把标签放到首页</h6><p>在路径：<code>/themes/next/layout/index.swig</code> 中<code>&#123;% block content %&#125;</code>下面添加下方代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;tag-cloud&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;tag-cloud-tags&quot; id&#x3D;&quot;tags&quot;&gt;</span><br><span class="line">	&#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &#39;#fff&#39;, end_color: &#39;#fff&#39;&#125;) &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&#123;% include &#39;tag-color.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224235556.png" alt="image-20210224235556099"></p>
<h1 id="归档页面增加月份归档"><a href="#归档页面增加月份归档" class="headerlink" title="归档页面增加月份归档"></a>归档页面增加月份归档</h1><p>在==themes/next/source/css/_common/components/post/post-collapse.styl==新增代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置也月份样式</span></span><br><span class="line">.collection-month &#123; <span class="comment">//属性不一定是这个名字，具体和你在swig文件中为其配置的class值有关，照着它来</span></span><br><span class="line">  font-size: $font-size-largest;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  margin: 60px <span class="number">0</span>;</span><br><span class="line">  position: relative;</span><br><span class="line"></span><br><span class="line">  &amp;::before &#123;</span><br><span class="line">    background: $grey;</span><br><span class="line">    border-radius: <span class="number">50</span>%;</span><br><span class="line">    content: <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    height: 8px;</span><br><span class="line">    left: <span class="number">0</span>;</span><br><span class="line">    margin-left: -4px;</span><br><span class="line">    margin-top: -4px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">50</span>%;</span><br><span class="line">    width: 8px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在==themes/next/layout/_macro/post-collapse.swig==中新增代码，位置如图</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">===========================================</span><br><span class="line">     &#123;%- set current_month = <span class="string">&#x27;0&#x27;</span> %&#125;</span><br><span class="line">===========================================</span><br><span class="line"> &#123;%- set month = date(post.date, <span class="string">&#x27;MMM&#x27;</span>) %&#125;</span><br><span class="line">  &#123;%- <span class="keyword">if</span> month !== current_month %&#125;</span><br><span class="line">    &#123;%- set current_month = month %&#125;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;collection-month&quot;</span>&gt;</span><br><span class="line">      &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;collection-header&quot;</span>&gt;&#123;&#123; current_month &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210226093409.png" alt="image-20210226093408957"></p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署第三方主题next 7.8版本</title>
    <url>/posts/d23fb963/</url>
    <content><![CDATA[<h1 id="next-7-8-主题安装"><a href="#next-7-8-主题安装" class="headerlink" title="next 7.8 主题安装"></a>next 7.8 主题安装</h1><p><a href="https://github.com/theme-next/hexo-theme-next/archive/v7.8.0.zip">7.8.0版本下载连接</a></p>
<ol>
<li><p>将下载好的主题文件解压到hexo主目录下的themes文件夹下</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224204119.png" alt="image-20210224204118992"></p>
</li>
<li><p>在主目录的source下新建<strong>_data</strong>目录，将<strong>第三方主题</strong>中的<strong>_config.yml</strong>文件复制到该目录下重命名为next.yml,并修改文件中<strong>override为true</strong></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224203110.png" alt="image-20210224203110673"></p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">override:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主目录的<strong>_config.yml</strong>文件，启用主题</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224203236.png" alt="image-20210224203236580"></p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成next主题开启的界面</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224203417.png" alt=""></p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo new page home</span><br><span class="line">hexo new page archives</span><br><span class="line">hexo new page about</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page commonweal</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>win10的typora配置gitee云图床</title>
    <url>/posts/fd71e1c8/</url>
    <content><![CDATA[<h1 id="相关准备准备"><a href="#相关准备准备" class="headerlink" title="相关准备准备"></a>相关准备准备</h1><ul>
<li><a href="https://www.typora.io/">Typora</a></li>
<li><a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a></li>
<li>gitee/github账号</li>
</ul>
<h1 id="gitee-github相关配置"><a href="#gitee-github相关配置" class="headerlink" title="gitee/github相关配置"></a>gitee/github相关配置</h1><ol>
<li><p>新建仓库（<strong>一定要是公开的，不然md到时候无法访问</strong>）</p>
</li>
<li><p>生成Token ，<strong>保存Token</strong></p>
<p> 在自已的用户中心生成私人令牌</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224175635.png" alt="image-20210224175635044"></p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224175714.png" alt="image-20210224175714200"></p>
</li>
</ol>
<h1 id="PicGO相关配置"><a href="#PicGO相关配置" class="headerlink" title="PicGO相关配置"></a>PicGO相关配置</h1><h2 id="GitHub设置"><a href="#GitHub设置" class="headerlink" title="GitHub设置"></a>GitHub设置</h2><p><a href="https://blog.csdn.net/yefcion/article/details/88412025">原文地址</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224180016.png" alt="image-20210224180016463"></p>
<ul>
<li>仓库名 即你的仓库名</li>
<li>分支名 默认 <code>master</code></li>
<li>Token 就是刚刚复制的那一串字符</li>
<li>存储路径 这个可以填也可以不填，填了的话图片就上传到 git 中 <code>data</code> 这个文件夹</li>
<li>域名 <code>https://raw.githubusercontent.com/yefcion/cloudimg/master</code>这个要改一下 格式 <code>https://raw.githubusercontent.com/[username]/[仓库名]/master</code></li>
</ul>
<h2 id="Gitee设置"><a href="#Gitee设置" class="headerlink" title="Gitee设置"></a>Gitee设置</h2><ol>
<li><p>下载插件gitee-uploader</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224180247.png" alt="image-20210224180247392"></p>
</li>
<li><p>设置Gitee并设置为默认图床（Github是外网，可能会慢，故选择gitee为默认）</p>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224195106.png" alt="image-20210224195106781"></p>
</li>
</ol>
<h2 id="PicGO设置"><a href="#PicGO设置" class="headerlink" title="PicGO设置"></a>PicGO设置</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224195211.png" alt="image-20210224195211867"></p>
<h2 id="Typora设置"><a href="#Typora设置" class="headerlink" title="Typora设置"></a>Typora设置</h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224195433.png" alt="image-20210224195433511"></p>
]]></content>
      <categories>
        <category>Typora</category>
        <category>Gitee</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Gitee</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>win10的搭建hexo博客</title>
    <url>/posts/1bab7c20/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p><strong>安装前准备</strong></p>
<ul>
<li>git</li>
<li>Nodejs</li>
</ul>
<h1 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h1><ol>
<li><p>首先配置npm的<strong>淘宝源</strong>,安装完成后可通过npm info hexo查看是否配置淘宝源成功</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装hexo</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定安装的hexo目录</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo init test</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> test     </span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试安装是否成功</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean      #清除缓存</span><br><span class="line">hexo g      #生成静态网页</span><br><span class="line">hexo s      #启动本地服务</span><br></pre></td></tr></table></figure>
<p> <img src="https://gitee.com/CNRF/image/raw/master/img/20210224200606.png" alt="image-20210224200605821"></p>
</li>
</ol>
<h1 id="Gtihub相关配置"><a href="#Gtihub相关配置" class="headerlink" title="Gtihub相关配置"></a>Gtihub相关配置</h1><p>New repository创建新仓库，仓库名应该为：<strong>用户名</strong>.<a href="https://link.zhihu.com/?target=http%3A//github.io">http://github.io</a> 这个<strong>用户名</strong>使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210224200752.png" alt="image-20210224200752872"></p>
<h1 id="hexo配置远程部署"><a href="#hexo配置远程部署" class="headerlink" title="hexo配置远程部署"></a>hexo配置远程部署</h1><p>修改根目录下的<strong>_config.yml</strong> 文件中配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/CNRF/CNRF.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<p>使用相关命令进行部署</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d  # 第一次部署会提示输入github的账号和密码</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>redis入门</title>
    <url>/posts/eca8b4a8/</url>
    <content><![CDATA[<h4 id="1-redis相关介绍"><a href="#1-redis相关介绍" class="headerlink" title="1.redis相关介绍"></a>1.redis相关介绍</h4><p><a href="http://redis.cn/">redis中文网</a></p>
<h5 id="1-1-redis的介绍"><a href="#1-1-redis的介绍" class="headerlink" title="1.1 redis的介绍"></a>1.1 redis的介绍</h5><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113311.png" alt="image-20210211203040301"></p>
<h5 id="1-2-redis和memcached的区别"><a href="#1-2-redis和memcached的区别" class="headerlink" title="1.2  .redis和memcached的区别"></a>1.2  .redis和memcached的区别</h5><p>redis和memcached相比本质是解耦，用大数据说法是计算向数据移动</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113409.png" alt="image-20210218095611832"></p>
<h5 id="1-3-liunx下常见的redis命令"><a href="#1-3-liunx下常见的redis命令" class="headerlink" title="1.3 . liunx下常见的redis命令"></a>1.3 . liunx下常见的redis命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#连接redis</span><br><span class="line">redis-cli</span><br><span class="line">#连接redis是6379端口的8号库 指定库(不同库数据不可见)</span><br><span class="line">redis-cli -p 6379 -n 8</span><br><span class="line">#连接redis后使用help进行查询</span><br><span class="line">help </span><br></pre></td></tr></table></figure>
<h4 id="2-redis相关数据的操作常见命令"><a href="#2-redis相关数据的操作常见命令" class="headerlink" title="2.redis相关数据的操作常见命令"></a>2.redis相关数据的操作常见命令</h4><p>在redis客户端中使用help命令进行相关查询相关命令</p>
<h5 id="2-1-Strings类型"><a href="#2-1-Strings类型" class="headerlink" title="2.1 Strings类型"></a>2.1 Strings类型</h5><p><a href="https://redis.io/commands#string">Strings 数据操作相关文档</a></p>
<h6 id="2-1-1-查看string类型帮助命令"><a href="#2-1-1-查看string类型帮助命令" class="headerlink" title="2.1.1 查看string类型帮助命令"></a>2.1.1 查看string类型帮助命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help @string</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113419.png" alt="image-20210219155031906"></p>
<h6 id="2-1-2-string数据类型及相关的应用场景"><a href="#2-1-2-string数据类型及相关的应用场景" class="headerlink" title="2.1.2  string数据类型及相关的应用场景"></a>2.1.2  string数据类型及相关的应用场景</h6><ol>
<li><p>字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set设置key的value</span><br><span class="line">set k1 ooxx nx  （带nx，xx可用在分布式锁中）</span><br><span class="line">set k1 ooxx xx</span><br><span class="line">#mset批量设置</span><br><span class="line">mset k3 k3mest k4 k4mest</span><br><span class="line">#get获取key的value</span><br><span class="line">get k1</span><br><span class="line">#mget批量获取</span><br><span class="line">mget k3 k4</span><br><span class="line">#APPEND在字符串后面追加</span><br><span class="line">append k1 &quot; world&quot;</span><br><span class="line">#GETRANGE获取指定范围数据</span><br><span class="line">getrange k1 5 10</span><br><span class="line">#strlen获取字符串长度</span><br><span class="line">strlen k1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113426.png" alt="image-20210219155108071"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113517.png" alt="image-20210219160021217"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113555.png" alt="image-20210219160343269"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113600.png" alt="image-20210219160751857"></p>
</li>
<li><p>数值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">incr  将value的整数型+1</span><br><span class="line">incrby 将value的整数型加指定数</span><br><span class="line">decr </span><br><span class="line">descby</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong> ： 抢购，秒杀，详情页，点赞，评论规避并发下，对数据库的事务操作完全由redis内存操作代替，避免因数据库事务导致响应时间超时，<strong>但在银行等金融涉及金额不要放在redis中进行相关计算</strong></p>
</li>
<li><p>bitmap</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setbit  &#x2F;&#x2F;设置bit数值</span><br><span class="line">bitcount  </span><br><span class="line">bitpos</span><br><span class="line">bitop</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>应用场景</strong> ：</p>
<pre><code>1. 统计用户登陆天数

    方案：用户id为key，设计长度为9bit的数据即可存储用户当年所有登陆天数数据，当天登陆为1，即可统计指定时间段的相关数据

2. 统计当天所有用户登陆情况

    方案：日期为Key，设计一个合适长度的数据存储，每一位对应一位客户，登陆则为1，统计时直接进行二进制与运算，则可以去重，统计那些用户登陆
</code></pre><h5 id="2-2-Lists类型"><a href="#2-2-Lists类型" class="headerlink" title="2.2  Lists类型"></a>2.2  Lists类型</h5><h6 id="2-2-1-Lists常见命令"><a href="#2-2-1-Lists常见命令" class="headerlink" title="2.2.1 Lists常见命令"></a>2.2.1 Lists常见命令</h6><p><a href="https://redis.io/commands#list">Lists数据相关操作命令</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#lpush 存放顺序为f e d c b a</span><br><span class="line">lpush k1 a b c d e f</span><br><span class="line">#rpush 存放顺序为a b c d e f</span><br><span class="line">rpush k2 a b c d e f</span><br><span class="line">#取数据 lpop</span><br><span class="line">lpop k1 </span><br><span class="line">#lrange按照范围取</span><br><span class="line">lrange k1 0 -1（取全部）</span><br><span class="line">#lindex</span><br><span class="line">#lset</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113620.png" alt="image-20210219205233457"></p>
<h6 id="2-2-2应用场景"><a href="#2-2-2应用场景" class="headerlink" title="2.2.2应用场景"></a>2.2.2应用场景</h6><ol>
<li>使用lpush模拟栈，后进先出</li>
<li>使用rpush模拟队列，先进先出（买票排队问题）</li>
<li>lindex模拟数组，直接根据下标取相关数据</li>
<li>blpop模拟阻塞单播队列（blpop会让对应key有则弹出value，没有会阻塞等待key有值，并且只会弹出一次，当多个客户端同时对一个key使用blpop则可以实现阻塞单播）</li>
</ol>
<h5 id="2-3-hashes类型"><a href="#2-3-hashes类型" class="headerlink" title="2.3 hashes类型"></a>2.3 hashes类型</h5><p>类似java中的hashmap（key，hashmap（key，value））。这里面第一个key是hashes的key，hashmap（key，value）才是value</p>
<h6 id="2-3-1-hashes常见命令"><a href="#2-3-1-hashes常见命令" class="headerlink" title="2.3.1 hashes常见命令"></a>2.3.1 hashes常见命令</h6><p><a href="https://redis.io/commands#hash">hashes常见的命令</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdel</span><br><span class="line">hget</span><br><span class="line">hset</span><br><span class="line">hlen</span><br><span class="line">hincrbyfloat</span><br></pre></td></tr></table></figure>
<h6 id="2-3-2-应用场景："><a href="#2-3-2-应用场景：" class="headerlink" title="2.3.2 应用场景："></a>2.3.2 应用场景：</h6><ol>
<li>对员工薪水进行统计</li>
</ol>
<h5 id="2-4-sets数据类型"><a href="#2-4-sets数据类型" class="headerlink" title="2.4 sets数据类型"></a>2.4 sets数据类型</h5><p>Redis Set 是 String 的无序排列。<code>SADD</code> 指令把新的元素添加到 set 中。对 set 也可做一些其他的操作，比如测试一个给定的元素是否存在，对不同 set 取交集，并集或差，等等。</p>
<h6 id="2-4-1常见命令"><a href="#2-4-1常见命令" class="headerlink" title="2.4.1常见命令"></a>2.4.1常见命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sadd &#x2F;&#x2F;添加元素</span><br><span class="line">sadd myset 1 2 3</span><br><span class="line">smembers &#x2F;&#x2F;读取集合元素</span><br><span class="line">smembers myset</span><br><span class="line">sismember &#x2F;&#x2F;判断元素存在</span><br><span class="line">sismember myset 3 &#x2F;&#x2F;存在返回1，不存在为0</span><br><span class="line"> SINTER  &#x2F;&#x2F;获取多个集合的交集</span><br><span class="line"> SUNIONSTORE  &#x2F;&#x2F;多个集合取并集</span><br></pre></td></tr></table></figure>
<h6 id="2-4-2-应用场景"><a href="#2-4-2-应用场景" class="headerlink" title="2.4.2 应用场景"></a>2.4.2 应用场景</h6><ol>
<li><p>公平抽奖(随机事件) ：  SRANDMEMBER key count（用户作为value）</p>
<p>​                        正数：取出一个去重的结果集（不能超过已有集）</p>
<p>​                        负数：取出一个带重复的结果集，一定满足你要的数量如果：</p>
<p>​                        0，不返回</p>
</li>
</ol>
<h5 id="2-5-sorted-sets数据类型"><a href="#2-5-sorted-sets数据类型" class="headerlink" title="2.5 sorted sets数据类型"></a>2.5 sorted sets数据类型</h5><h6 id="2-5-1-常见命令"><a href="#2-5-1-常见命令" class="headerlink" title="2.5.1 常见命令"></a>2.5.1 常见命令</h6><p><a href="https://redis.io/commands#sorted_set">sorted sets常见命令</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zadd</span><br><span class="line">zmenmber</span><br><span class="line">zinter</span><br><span class="line">zscore &#x2F;&#x2F;按照什么排序</span><br></pre></td></tr></table></figure>
<h6 id="2-5-2-排序底层实现"><a href="#2-5-2-排序底层实现" class="headerlink" title="2.5.2 排序底层实现"></a>2.5.2 排序底层实现</h6><p>通过Skip list（跳跃表）实现增删查改</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113634.png" alt="image-20210220102659707"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>安装redis出现的问题</title>
    <url>/posts/5e07a887/</url>
    <content><![CDATA[<p><strong>操作系统为centOs7  redis为6.0.8版本</strong></p>
<h3 id="1-当Make命令提示无cc环境时需要进行安装Gcc安装包重新安装，同时需要执行make-distclean清理相关文件，再执行make命令"><a href="#1-当Make命令提示无cc环境时需要进行安装Gcc安装包重新安装，同时需要执行make-distclean清理相关文件，再执行make命令" class="headerlink" title="1.当Make命令提示无cc环境时需要进行安装Gcc安装包重新安装，同时需要执行make distclean清理相关文件，再执行make命令"></a>1.当Make命令提示无cc环境时需要进行安装Gcc安装包重新安装，同时需要执行make distclean清理相关文件，再执行make命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一般错误为gcc套装错误</span><br><span class="line">yum install cpp</span><br><span class="line">yum install binutils</span><br><span class="line">yum install glibc</span><br><span class="line">yum install glibc-kernheaders</span><br><span class="line">yum install glibc-common</span><br><span class="line">yum install glibc-devel</span><br><span class="line">yum install gcc</span><br><span class="line">yum install make</span><br><span class="line">&#x2F;&#x2F;清理错误文件</span><br><span class="line">make distclean</span><br><span class="line">&#x2F;&#x2F;重新安装</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/m0_37952284/article/details/109012324">server.c:5307:31: 错误:‘struct redisServer’没有名为‘server_xxx’的成员</a></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113217.png" alt="image-20201103103148896"></p>
<ol>
<li><h3 id="下载了redis版本6-0-6，正常解压，Centos用的7-6，make安装时报错"><a href="#下载了redis版本6-0-6，正常解压，Centos用的7-6，make安装时报错" class="headerlink" title="下载了redis版本6.0.6，正常解压，Centos用的7.6，make安装时报错:"></a>下载了redis版本6.0.6，正常解压，Centos用的7.6，make安装时报错:</h3></li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113232.png" alt="image-20201103104749570"></p>
<p>原因是redies用了c语言编写，centos7.6应该也有以下版本，默认安装的gcc4.8.5版本较低，需要在5.3以上版本，现更换为9.3，先查看当前版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>
<p>开始更换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>重连shell</strong>(不重连gcc版本不变)，重新make，即成功了</p>
<h3 id="3-安装Redis-6-0-6-install-server-sh报错"><a href="#3-安装Redis-6-0-6-install-server-sh报错" class="headerlink" title="3.安装Redis 6.0.6 ./install_server.sh报错"></a>3.安装Redis 6.0.6 ./install_server.sh报错</h3><p>产生原因:gcc9版本校验更加严格导致</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113249.png" alt="image-20201103111330639"></p>
<p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi .&#x2F;install_server.sh</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113254.png" alt="image-20201103111506170"></p>
<p><strong>注释掉代码</strong>重新运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#bail if this system is managed by systemd</span><br><span class="line">#_pid_1_exe&#x3D;&quot;$(readlink -f &#x2F;proc&#x2F;1&#x2F;exe)&quot;</span><br><span class="line">#if [ &quot;$&#123;_pid_1_exe##*&#x2F;&#125;&quot; &#x3D; systemd ]</span><br><span class="line">#then</span><br><span class="line">#       echo &quot;This systems seems to use systemd.&quot;</span><br><span class="line">#       echo &quot;Please take a look at the provided example service unit files in this directory, and adapt and install them. Sorry!&quot;</span><br><span class="line">#       exit 1</span><br><span class="line">#fi</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装redis</title>
    <url>/posts/725846d4/</url>
    <content><![CDATA[<p><strong>操作系统为centOS7  redis为6.0.8版本</strong></p>
<ol>
<li>安装wget命令 </li>
</ol>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure>
<p>   <img src="https://gitee.com/CNRF/image/raw/master/img/20210223112933.png" alt="image-20201026172631943"></p>
<ol>
<li><p>安装GCC包（redis是c语言编写，liunx需要安装相关软件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223112947.png" alt="image-20201026172608587"></p>
</li>
<li><p>在指定目录获取安装包（或者下载之后移动到指定目录  ）</p>
<p><a href="https://redis.io/download">https://redis.io/download</a>  获取相关版本连接，这里下载6.0版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-6.0.8.tar.gz</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113024.png" alt="image-20201026172901823"></p>
</li>
<li><p>解压gz包（下载的是源码）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xf redis-6.0.8.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据解压包中文件的REDME.md文档进行相关操作（重要：安装其他软件同理）</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113031.png" alt="image-20201103102727621"></p>
</li>
<li><p>使用make相关命令进行安装程序</p>
</li>
<li><p>安装可执行到指定目录（分离源码）</p>
<p>查看/home/redis-6.0.8/INSTALL，根据文档安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install PREFIX&#x3D;&#x2F;home&#x2F;redis6</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册redis为服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;执行vi &#x2F;etc&#x2F;profile命令，在文件最后新增内容</span><br><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line">&#x2F;&#x2F;REDIS_HOME的路径为第七步的安装路径</span><br><span class="line">export REDIS_HOME&#x3D;&#x2F;home&#x2F;redis6</span><br><span class="line">export PATH&#x3D;$PATH:$REDIS_HOME&#x2F;bin</span><br><span class="line">&#x2F;&#x2F;使配置文件生效</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">&#x2F;&#x2F;验证是否添加成功</span><br><span class="line">echo $PATH</span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">&#x2F;home&#x2F;redis-6.0.8&#x2F;utils&#x2F;install_server.sh脚本注册为服务</span><br><span class="line">.&#x2F;install_server.sh</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113126.png" alt="image-20201103103148896"></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113145.png" alt="image-20201103112714896">   </p>
<ol>
<li><p>修改配置文件，安装需求修改相关配置</p>
<p>redis常见配置参见<a href="https://blog.csdn.net/suprezheng/article/details/90679790">https://blog.csdn.net/suprezheng/article/details/90679790</a></p>
</li>
<li><p>将redis_6379(根据生成的配置文件名称)设置为开启</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;init.d</span><br><span class="line">  #init.d没有redis_6379文件的可以在源文件中找到redis.conf文件进行修改</span><br><span class="line">  chkconfig --add redis_6379</span><br><span class="line">  chkconfig redis_6379 on</span><br><span class="line">  #查看开机自启的列表</span><br><span class="line">  chkconfig --list</span><br><span class="line">  #重启redis</span><br><span class="line">  service redis_6379 restart</span><br><span class="line">  #手动启用</span><br><span class="line">  redis-server &#x2F;etc&#x2F;redis&#x2F;6379.conf</span><br><span class="line">  chkconfig --list的参数意义</span><br><span class="line">  1表示：单用户模式</span><br><span class="line">  2表示：无网络连接的多用户命令行模式</span><br><span class="line">  3表示：有网络连接的多用户命令行模式</span><br><span class="line">  4表示：不可用</span><br><span class="line">  5表示：带图形界面的多用户模式</span><br><span class="line">  6表示：重新启动</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPoolExecutor源码解析</title>
    <url>/posts/ca94e89b/</url>
    <content><![CDATA[<h1 id="ThreadPoolExecutor源码解析"><a href="#ThreadPoolExecutor源码解析" class="headerlink" title="ThreadPoolExecutor源码解析"></a>ThreadPoolExecutor源码解析</h1><h3 id="1、常用变量的解释"><a href="#1、常用变量的解释" class="headerlink" title="1、常用变量的解释"></a>1、常用变量的解释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. `ctl`，可以看做一个int类型的数字，高3位表示线程池状态，低29位表示worker数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 2. `COUNT_BITS`，`Integer.SIZE`为32，所以`COUNT_BITS`为29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 3. `CAPACITY`，线程池允许的最大线程数。1左移29位，然后减1，即为 2^29 - 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">// 4. 线程池有5种状态，按大小排序如下：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 5. `runStateOf()`，获取线程池状态，通过按位与操作，低29位将全部变成0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 6. `workerCountOf()`，获取线程池worker数量，通过按位与操作，高3位将全部变成0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 7. `ctlOf()`，根据线程池状态和线程池worker数量，生成ctl值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don&#x27;t require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 8. `runStateLessThan()`，线程池状态小于xx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9. `runStateAtLeast()`，线程池状态大于等于xx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 空指针校验</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="comment">// 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中</span></span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、提交执行task的过程"><a href="#3、提交执行task的过程" class="headerlink" title="3、提交执行task的过程"></a>3、提交执行task的过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// worker数量比核心线程数小，直接创建worker执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// worker数量超过核心线程数，任务直接进入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作。</span></span><br><span class="line">        <span class="comment">// 这儿为什么需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 这儿为什么需要判断0值，主要是在线程池构造方法中，核心线程数允许为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务。</span></span><br><span class="line">    <span class="comment">// 这儿有3点需要注意：</span></span><br><span class="line">    <span class="comment">// 1. 线程池不是运行状态时，addWorker内部会判断线程池状态</span></span><br><span class="line">    <span class="comment">// 2. addWorker第2个参数表示是否创建核心线程</span></span><br><span class="line">    <span class="comment">// 3. addWorker返回false，则说明任务执行失败，需要执行reject操作</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、addworker源码解析"><a href="#4、addworker源码解析" class="headerlink" title="4、addworker源码解析"></a>4、addworker源码解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 外层自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个条件写得比较难懂，我对其进行了调整，和下面的条件等价</span></span><br><span class="line">        <span class="comment">// (rs &gt; SHUTDOWN) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; firstTask != null) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于SHUTDOWN时，直接返回false</span></span><br><span class="line">        <span class="comment">// 2. 线程池状态等于SHUTDOWN，且firstTask不为null，直接返回false</span></span><br><span class="line">        <span class="comment">// 3. 线程池状态等于SHUTDOWN，且队列为空，直接返回false</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// worker数量超过容量，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 使用CAS的方式增加worker数量。</span></span><br><span class="line">            <span class="comment">// 若增加成功，则直接跳出外层循环进入到第二部分</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 线程池状态发生变化，对外层循环进行自旋</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 其他情况，直接内层循环进行自旋即可</span></span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// worker的添加必须是串行的，因此需要加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">// 这儿需要重新检查线程池状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// worker已经调用过了start()方法，则不再创建worker</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// worker创建并添加到workers成功</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 更新`largestPoolSize`变量</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动worker线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// worker线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown相关操作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、线程池worker任务单元"><a href="#5、线程池worker任务单元" class="headerlink" title="5、线程池worker任务单元"></a>5、线程池worker任务单元</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 这儿是Worker的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6、核心线程执行逻辑-runworker"><a href="#6、核心线程执行逻辑-runworker" class="headerlink" title="6、核心线程执行逻辑-runworker"></a>6、核心线程执行逻辑-runworker</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 调用unlock()是为了让外部可以中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 这个变量用于判断是否进入过自旋（while循环）</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这儿是自旋</span></span><br><span class="line">        <span class="comment">// 1. 如果firstTask不为null，则执行firstTask；</span></span><br><span class="line">        <span class="comment">// 2. 如果firstTask为null，则调用getTask()从队列获取任务。</span></span><br><span class="line">        <span class="comment">// 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这儿对worker进行加锁，是为了达到下面的目的</span></span><br><span class="line">            <span class="comment">// 1. 降低锁范围，提升性能</span></span><br><span class="line">            <span class="comment">// 2. 保证每个worker执行的任务是串行的</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 如果线程池正在停止，则对当前线程进行中断操作</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="comment">// 执行任务，且在执行前后通过`beforeExecute()`和`afterExecute()`来扩展其功能。</span></span><br><span class="line">            <span class="comment">// 这两个方法在当前类里面为空实现。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 帮助gc</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 已完成任务数加一 </span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋操作被退出，说明线程池正在结束</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/posts/de7c53fe/</url>
    <content><![CDATA[<h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a><strong>Executor框架</strong></h3><p>线程池就是<strong>线程的集合</strong>，线程池集中管理线程，以实现线程的重用，降低资源消耗，提高响应速度等。线程用于执行异步任务，单个的线程既是工作单元也是执行机制，从JDK1.5开始，为了把工作单元与执行机制分离开，Executor框架诞生了，他是一个用于统一创建与运行的接口。<strong>Executor框架实现的就是线程池的功能</strong></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114336.png" alt="img"></p>
<p>说明：</p>
<ul>
<li><strong>Executor</strong> 执行器接口，该接口定义执行Runnable任务的方式。</li>
<li><strong>ExecutorService</strong> 该接口定义提供对Executor的服务。</li>
<li><strong>ScheduledExecutorService</strong> 定时调度接口。</li>
<li><strong>AbstractExecutorService</strong> 执行框架抽象类。</li>
<li><strong>ThreadPoolExecutor</strong> JDK中线程池的具体实现。</li>
<li><strong>Executors</strong> 线程池工厂类。</li>
</ul>
<h3 id="ThreadPoolExecutor（线程池类）"><a href="#ThreadPoolExecutor（线程池类）" class="headerlink" title="ThreadPoolExecutor（线程池类）"></a>ThreadPoolExecutor（<strong>线程池类</strong>）</h3><p>线程池是一个复杂的任务调度工具，它涉及到任务、线程池等的生命周期问题。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                         TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                         RejectedExecutionHandler handler)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程池的七个参数"><a href="#线程池的七个参数" class="headerlink" title="线程池的七个参数"></a>线程池的七个参数</h4><ul>
<li><p>corePoolSize：核心线程数。</p>
</li>
<li><p>maximumPoolSize：最大线程数。</p>
</li>
<li><p>keepAliveTime：线程存活时间。当线程数大于core数，那么超过该时间的线程将会被终结。</p>
</li>
<li><p>unit：keepAliveTime的单位。java.util.concurrent.TimeUnit类存在静态静态属性： NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS</p>
</li>
<li><p>workQueue：Runnable的阻塞队列。若线程池已经被占满，则该队列用于存放无法再放入线程池中的Runnable。</p>
</li>
<li>threadFactory:创建一个新线程时使用的工厂，可以用来设定线程名、是否为守护线程等等</li>
<li>handler：拒绝策略</li>
</ul>
<h4 id="五种线程池"><a href="#五种线程池" class="headerlink" title="五种线程池"></a>五种线程池</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   ExecutorService threadPool = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//有缓冲的线程池，线程数 JVM 控制，线程太多会导致CUP一直进行切换，阻塞队列使用的是SynchronousQueue(容量为0),不希望任务堆积</span></span><br><span class="line">   threadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//固定大小的线程池，核心线程数和最大线程数保持一致，希望以恒定的处理速度使用线程</span></span><br><span class="line">   threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//可创建最大线程为int最大值，线程太多会导致CPU频繁切换</span></span><br><span class="line">   threadPool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//单线程的线程池，只有一个线程在工作，队列长度为int最大值，可能会堆积大量请求</span></span><br><span class="line">   threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//默认线程池，可控制参数比较多 </span></span><br><span class="line">   threadPool = <span class="keyword">new</span> ThreadPoolExecutor();</span><br><span class="line"><span class="comment">// 基于工作窃取算法，其中任务可以生成其他较小的任务，这些任务将添加到并行处理线程的队列中。如果一个线程完成了工作并且无事可做，则可以从另一线程的队列中“窃取”工作</span></span><br><span class="line">   threadPool = Executors.newWorkStealingPool();</span><br></pre></td></tr></table></figure>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">null</span>;</span><br><span class="line">workQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);<span class="comment">//基于数组的先进先出队列，有界</span></span><br><span class="line">workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();<span class="comment">//基于链表的先进先出队列，无界</span></span><br><span class="line">workQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();<span class="comment">//无缓冲的等待队列，无界</span></span><br></pre></td></tr></table></figure>
<h4 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h4><blockquote>
<p>阿里出品的规范不建议使用这些拒绝策略，建议自定义策略（可保存到redis，kafaka或日志文件等中）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RejectedExecutionHandler rejected = <span class="keyword">null</span>;</span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy();<span class="comment">//默认，队列满了丢任务抛出异常</span></span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy();<span class="comment">//队列满了丢任务不异常</span></span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy();<span class="comment">//将最早进入队列的任务删，之后再尝试加入队列</span></span><br><span class="line">rejected = <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy();<span class="comment">//如果添加到线程池失败，那么主线程会自己去执行该任务</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的容器</title>
    <url>/posts/5c0b6c7e/</url>
    <content><![CDATA[<h1 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h1><p>Collection</p>
<ul>
<li><p>List</p>
<ul>
<li>Vector</li>
<li>ArrayList</li>
<li>LinkList</li>
<li>CopyOnWriteList</li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li><p>HashSet</p>
<ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li><p>SortedSet</p>
<ul>
<li>TreeSet</li>
</ul>
</li>
<li>EnumSet</li>
<li>CopyOnwriteArraySet</li>
<li>ConcurrentSkipListSet</li>
</ul>
</li>
<li><p>Queue（JDK1.5新增，对多线程友好，多线程优先使用）</p>
<ul>
<li><p>阻塞队列（BlockingQueue）</p>
<ul>
<li><p>TransferQueue</p>
</li>
<li><p>PriorityBlockingQueue</p>
</li>
<li><p>ArrayBlockingQueue</p>
</li>
<li><p>LinkedBlockingQueue</p>
</li>
<li><p>SynchonousQueue</p>
</li>
<li><p>DelayQueue</p>
</li>
</ul>
</li>
<li>非阻塞队列<ul>
<li>Deque（双端队列，两边都可以进出）</li>
<li>ConcurrentLinkedQueue</li>
<li>priorityQueue</li>
</ul>
</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li>HashTable<ul>
<li>HashMap</li>
<li>LinkHashMap</li>
<li>ConcurrentHashMap</li>
</ul>
</li>
<li>TreeMap</li>
<li>ConcurrentSkipListMap</li>
<li>WeakHashMap</li>
<li>IdentityHashMap</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114233.gif" alt="img"></p>
<h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>​    List是用于存放多个元素，能够维护元素的次序，并且允许元素的重复</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ArrayList是最常用的List实现类，内部是通过<strong>数组</strong>实现的，它允许对元素进行<strong>快速随机访问</strong>。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有<strong>数组的数据复制到新的存储空间</strong>中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它<strong>适合随机查找和遍历</strong>，<strong>不适合插入和删除</strong></p>
<ul>
<li>继承了AbstractList,此类提供 List 接口的骨干实现，以最大限度地减少实现”随机访问”数据存储（如数组）支持的该接口所需的工作.对于连续的访问数据（如链表），应优先使用 AbstractSequentialList，而不是此类。</li>
<li>实现了List接口,意味着ArrayList元素是有序的,可以重复的,<strong>可以有null元素</strong>的集合.</li>
<li>实现了RandomAccess接口标识着其支持随机快速访问,实际上,我们查看RandomAccess源码可以看到,其实里面什么都没有定义.因为ArrayList底层是数组,那么随机快速访问是理所当然的,访问速度O(1)。</li>
<li>实现了Cloneable接口,标识着可以它可以被复制.注意,ArrayList里面的clone()复制其实是浅复制。</li>
<li>实现了Serializable 标识着集合可被序列化</li>
</ul>
<h3 id="ArrayList的属性"><a href="#ArrayList的属性" class="headerlink" title="ArrayList的属性"></a>ArrayList的属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//JDK1.8版本</span></span><br><span class="line">    <span class="comment">//序列化ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="comment">//默认的数组大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 一个空对象，如果使用默认构造函数创建，则默认对象内容默认是该值 </span></span><br><span class="line">    <span class="comment">//如果使用的是默认的构造函数创建的对象，则返回DEFAULTCAPACITY_EMPTY_ELEMENTDATA；如果是用户在指定容量的大小为0的时候返回的，则返回的是EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 当前数据对象存放地方，当前对象不参与序列化(主要是关键字transient起作用的)  </span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    <span class="comment">//当前数组长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//数组最大程度为2^32-8为2147483639</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList的相关方法"><a href="#ArrayList的相关方法" class="headerlink" title="ArrayList的相关方法"></a>ArrayList的相关方法</h3><h4 id="ArrayList的构造方法"><a href="#ArrayList的构造方法" class="headerlink" title="ArrayList的构造方法"></a>ArrayList的构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造 </span></span><br><span class="line"><span class="comment">//创建的时候elementData长度为0.当进行第一次add之后，会变成默认的长度10</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="comment">//传入参数，则代表指定ArrayList的初始数组长度，传入参数如果是大于等于0，则使用用户的参数初始化，如果用户传入的参数小于0，则抛出异常</span></span><br><span class="line"><span class="comment">//当</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+  </span><br><span class="line">                                           initialCapacity);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//将Collection&lt;T&gt; c 中保存的数据，首先转换成数组形式（toArray（）方法），然后判断当前数组长度是否为0，为 0 则只想默认数组（EMPTY_ELEMENTDATA）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：此时我们创建的ArrayList对象中的elementData中的长度是0，size是0,<strong>当进行第一次add的时候，elementData将会变成默认的长度：10.</strong></p>
<ul>
<li>ArrayList（）：指向 <strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong>，当列表使用的时候，才会进行初始化，会通过判断是不是 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 这个对象而设置数组默认大小。</li>
<li>ArrayList(int initialCapacity)：当 initialCapacity &gt;0 的时候，设置该长度。如果 initialCapacity =0，则指向 <strong>EMPTY_ELEMENTDATA</strong> 在使用的时候，并不会设置默认数组长度 。</li>
<li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA 与 EMPTY_ELEMENTDATA 的本质区别就在于，会不会设置默认的数组长度</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//ArrayList的size方法获取的是list中的元素个数</span></span><br><span class="line"> <span class="comment">//通过反射获取list的长度</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListCapacity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getArrayListCapacity</span><span class="params">(ArrayList&lt;?&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        Class&lt;ArrayList&gt; arrayListClass = ArrayList.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取 elementData 字段</span></span><br><span class="line">            Field field = arrayListClass.getDeclaredField(<span class="string">&quot;elementData&quot;</span>);</span><br><span class="line">            <span class="comment">//开始访问权限</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//把示例传入get，获取实例字段elementData的值</span></span><br><span class="line">            Object[] objects = (Object[])field.get(arrayList);</span><br><span class="line">            <span class="comment">//返回当前ArrayList实例的容量值</span></span><br><span class="line">            <span class="keyword">return</span> objects.length;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-3-2-ArrayList的方法"><a href="#2-1-3-2-ArrayList的方法" class="headerlink" title="2.1.3.2 ArrayList的方法"></a>2.1.3.2 ArrayList的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新增元素</span></span><br><span class="line">add(E element)</span><br><span class="line">add(<span class="keyword">int</span> i , E element)</span><br><span class="line">addAll(Collection)</span><br><span class="line">addAll(<span class="keyword">int</span> index，Collection)</span><br><span class="line"><span class="comment">//移除元素</span></span><br><span class="line">remove（<span class="keyword">int</span> i）<span class="comment">//移除指定位置元素</span></span><br><span class="line">remove（E element）<span class="comment">//移除数组中第一个与element相同的元素</span></span><br><span class="line">removeRange（<span class="keyword">int</span> start,<span class="keyword">int</span> end）<span class="comment">//移除指定范围的元素</span></span><br><span class="line">clear()<span class="comment">//清除所有元素</span></span><br><span class="line">removeAll(Collection c)<span class="comment">//移除数组中所有和c中有交集的元素</span></span><br><span class="line">size() ;<span class="comment">//获取数组的元素个数（非数组长度）</span></span><br><span class="line">set();<span class="comment">//设置数组中指定位置元素值</span></span><br><span class="line">get(<span class="keyword">int</span> index);  <span class="comment">//index -- 该元素返回的索引值</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-4-ArrayList的扩容机制"><a href="#2-1-4-ArrayList的扩容机制" class="headerlink" title="2.1.4 ArrayList的扩容机制"></a>2.1.4 ArrayList的扩容机制</h3><h5 id="扩容步骤"><a href="#扩容步骤" class="headerlink" title="扩容步骤"></a>扩容步骤</h5><p>​     总的来说就是分两步：</p>
<p>1、扩容</p>
<p>​      把原来的数组复制到另一个内存空间更大的数组中</p>
<p> 2、添加元素</p>
<p>​        把新元素添加到扩容以后的数组中，扩容长度未原数组的1.5倍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//右移运算符(提高效率)   原来长度的一半 再加上原长度也就是每次扩容是原来的1.5倍</span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = minCapacity;</span><br><span class="line">      <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">      <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">      elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-5-实现ArrayList线程安全方式"><a href="#2-1-5-实现ArrayList线程安全方式" class="headerlink" title="2.1.5 实现ArrayList线程安全方式"></a>2.1.5 实现ArrayList线程安全方式</h3><ol>
<li>添加Synchronize关键字（Vector容器）</li>
<li>使用Collections的Collections.<strong>synchronizedList</strong>(new ArrayList&lt;&gt;());方法</li>
<li><strong>CopyOnWriteArrayList（详情见下）</strong></li>
</ol>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它<strong>支持线程的同步</strong>，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。<strong>Vector每次请求其大小的双倍空间</strong></p>
<h2 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h2><p>LinkedList是一个<strong>双向循环链表</strong>的，在<strong>添加和删除元素时具有比ArrayList更好的性能</strong>。但在get与set方面弱于ArrayList。<strong>线程非安全</strong>，可以用<strong>Collections的synchronizedList</strong>中相关方法实现线程安全</p>
<h2 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h2><p>CopyOnWriteArrayList这是一个ArrayList的<strong>线程安全的变体</strong>，其原理大概可以通俗的理解为:初始化的时候只有一个容器，很常一段时间，这个容器数据、数量等没有发生变化的时候，大家(多个线程)，都是读取(假设这段时间里只发生读取的操作)同一个容器中的数据，所以这样大家读到的数据都是唯一、一致、安全的，但是后来有人往里面增加了一个数据，这个时候<strong>CopyOnWriteArrayList 底层实现添加的原理是先copy出一个容器</strong>(可以简称副本)，<strong>再往新的容器里添加这个新的数据，最后把新的容器的引用地址赋值给了之前那个旧的的容器地址，但是在添加这个数据的期间，其他线程如果要去读取数据，仍然是读取到旧的容器里的数据，这样只能保证数据一致性，但不能保证数据的实时性，并且内存占用多</strong></p>
<h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p>Set接口的特点是<strong>无序(没有下标) 集合中的元素不重复</strong>，Set判断两个对象相同不是使用==运算符，而是根据<strong>equals</strong>方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul>
<li>它存储唯一元素并允许空值（只能有一个NULL值）</li>
<li>它由HashMap支持</li>
<li>它不保持插入顺序</li>
<li>它不是线程安全的</li>
</ul>
<p><strong>HashSet底层声明了一个HashMap，HashSet做了一层包装，操作HashSet里的元素时其实是在操作HashMap里的元素</strong></p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>   LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用<strong>链表</strong>维护元素的次序。这样使得元素看起 来像是以插入顺 序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>   LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p>
<h3 id="SortedSet（接口）"><a href="#SortedSet（接口）" class="headerlink" title="SortedSet（接口）"></a>SortedSet（接口）</h3><p>SortedSet 是一个有序的接口,集合内元素有2种排序规则,一种是Comparable(自然排序) 另一则是Comparator(比较器排序),</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p><strong>TreeSet底层也是声明了一个TreeMap，操作TreeSet里的元素其实是操作TreeMap里的元素</strong></p>
<p>TreeSet是SortedSet接口的<strong>唯一实现类</strong>，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，<strong>自然排序</strong> 和<strong>定制排序</strong>，其中自然排序为默认的排序方式。向 TreeSet中加入的应该是同一个类的对象。</p>
<p>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0</p>
<h3 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h3><p><strong>EnumSet 是一个专为枚举设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或隐式地指定</strong></p>
<ol>
<li>EnumSet的集合元素也是<strong>有序</strong>的，EnumSet以枚举值在Enum类内的定义顺序来决定集合元素的顺序。</li>
<li>EnumSet在内部以位向量的形式存储，这种存储形式非常紧凑、高效,因此EnumSet对象占用内存很小，而且运行效率很好。尤其是进行批量操作（如调用containsAll()和retainAll()方法）时，如果其参数也是EnumSet集合，则该批量操作的执行速度也非常快。</li>
<li>EnumSet集合不允许加入null元素，如果试图插入null元素，EnumSet将抛出NullPointerException异常。</li>
<li>EnumSet类没有暴露任何构造器来创建该类的实例，程序应该通过它提供的类方法来创建EnumSet对象。</li>
<li>如果只是想判断EnumSet是否包含null元素或试图删除null元素都不会抛出异常，只是删除操作将返回false，因为没有任何null元素被删除。</li>
</ol>
<p><strong>方法介绍：</strong></p>
<ul>
<li><strong>EnumSet allOf(Class elementType)</strong>: 创建一个包含指定枚举类里所有枚举值的EnumSet集合。</li>
<li><strong>EnumSet complementOf(EnumSet e)</strong>: 创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合，新EnumSet集合包含原EnumSet集合所不包含的、此类枚举类剩下的枚举值（即新EnumSet集合和原EnumSet集合的集合元素加起来是该枚举类的所有枚举值）。</li>
<li><strong>EnumSet copyOf(Collection c)</strong>: 使用一个普通集合来创建EnumSet集合。</li>
<li><strong>EnumSet copyOf(EnumSet e)</strong>: 创建一个指定EnumSet具有相同元素类型、相同集合元素的EnumSet集合。</li>
<li><strong>EnumSet noneOf(Class elementType)</strong>: 创建一个元素类型为指定枚举类型的空EnumSet。</li>
<li><strong>EnumSet of(E first,E…rest)</strong>: 创建一个包含一个或多个枚举值的EnumSet集合，传入的多个枚举值必须属于同一个枚举类。</li>
<li><strong>EnumSet range(E from,E to)</strong>: 创建一个包含从from枚举值到to枚举值范围内所有枚举值的EnumSet集合。</li>
</ul>
<h3 id="CopyOnwriteArraySet"><a href="#CopyOnwriteArraySet" class="headerlink" title="CopyOnwriteArraySet"></a>CopyOnwriteArraySet</h3><p>类似于<strong>CopyOnWriteArrayList</strong>，只是复制的容器有所不同</p>
<h3 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h3><p>ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。<br>ConcurrentSkipListSet和TreeSet，它们虽然都是有序的集合。但是，第一，它们的线程安全机制不同，TreeSet是非线程安全的，而ConcurrentSkipListSet是线程安全的。第二，ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114252.jpg" alt="ConcurrentSkipListSet的数据结构"></p>
<p><strong>说明</strong>：<br>(01) ConcurrentSkipListSet继承于AbstractSet。因此，它本质上是一个集合。<br>(02) ConcurrentSkipListSet实现了NavigableSet接口。因此，ConcurrentSkipListSet是一个有序的集合。<br>(03) ConcurrentSkipListSet是通过<strong>ConcurrentSkipListMap</strong>实现的。它包含一个ConcurrentNavigableMap对象m，而m对象实际上是ConcurrentNavigableMap的实现类ConcurrentSkipListMap的实例。ConcurrentSkipListMap中的元素是key-value键值对；而ConcurrentSkipListSet是集合，它只用到了ConcurrentSkipListMap中的key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个新的空 set，该 set 按照元素的自然顺序对其进行排序。</span></span><br><span class="line">ConcurrentSkipListSet()</span><br><span class="line"><span class="comment">// 构造一个包含指定 collection 中元素的新 set，这个新 set 按照元素的自然顺序对其进行排序。</span></span><br><span class="line">ConcurrentSkipListSet(Collection&lt;? extends E&gt; c)</span><br><span class="line"><span class="comment">// 构造一个新的空 set，该 set 按照指定的比较器对其元素进行排序。</span></span><br><span class="line">ConcurrentSkipListSet(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span><br><span class="line"><span class="comment">// 构造一个新 set，该 set 所包含的元素与指定的有序 set 包含的元素相同，使用的顺序也相同。</span></span><br><span class="line">ConcurrentSkipListSet(SortedSet&lt;E&gt; s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果此 set 中不包含指定元素，则添加指定元素。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">ceiling</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此 set 中移除所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 ConcurrentSkipListSet 实例的浅表副本。</span></span></span><br><span class="line"><span class="function">ConcurrentSkipListSet&lt;E&gt; <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。</span></span></span><br><span class="line"><span class="function">Comparator&lt;? <span class="keyword">super</span> E&gt; <span class="title">comparator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 包含指定的元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回在此 set 的元素上以降序进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中所包含元素的逆序视图。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比较指定对象与此 set 的相等性。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中当前第一个（最低）元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">floor</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素严格小于 toElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素小于（或等于，如果 inclusive 为 true）toElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">higher</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 不包含任何元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回在此 set 的元素上以升序进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中当前最后一个（最高）元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">last</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">lower</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 中存在指定的元素，则将其移除。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此 set 中移除包含在指定 collection 中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中的元素数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive, E toElement, <span class="keyword">boolean</span> toInclusive)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素大于等于 fromElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p><strong>Queue（JDK1.5新增，对多线程友好，多线程优先使用，线程安全（底层有CAS操作等等进行同步））</strong></p>
<p>队列是一种特殊的线性表，是一种先进先出（FIFO）的数据结构。它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114258.png" alt="队列的继承关系"></p>
<h2 id="阻塞队列（BlockingQueue）"><a href="#阻塞队列（BlockingQueue）" class="headerlink" title="阻塞队列（BlockingQueue）"></a>阻塞队列（BlockingQueue）</h2><p>BlockingQueue即阻塞队列，它是基于<strong>ReentrantLock</strong>实现相关过程，依据它的基本原理，我们可以实现Web中的长连接聊天功能，当然其最常用的还是用于实现生产者与消费者模式，大致如下图所示</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114301.png" alt="img"></p>
<blockquote>
<p>在Java中，BlockingQueue是一个接口，它的实现类有<strong>ArrayBlockingQueue</strong>、<strong>DelayQueue</strong>、 <strong>LinkedBlockingDeque</strong>、<strong>PriorityBlockingQueue</strong>、<strong>SynchronousQueue</strong>、<strong>TransferQueue</strong>等，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的。</p>
</blockquote>
<p><code>BlockingQueue</code> 方法以四种形式出现，对于不能立即满足但可能在将来某一时刻可以满足的操作，这四种形式的处理方式不同：第一种是抛出一个异常，第二种是返回一个特殊值（<code>null</code> 或 <code>false</code>，具体取决于操作），第三种是在操作可以成功前，无限期地阻塞当前线程，第四种是在放弃前只在给定的最大时间限制内阻塞。下表中总结了这些方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td><code>add(e)</code></td>
<td><code>offer(e)</code></td>
<td><code>put(e)</code></td>
<td><code>offer(e, time, unit)</code></td>
</tr>
<tr>
<td>移除</td>
<td><code>remove()</code></td>
<td><code>poll()</code></td>
<td><code>take()</code></td>
<td><code>poll(time, unit)</code></td>
</tr>
<tr>
<td>检查</td>
<td><code>element()</code></td>
<td><code>peek()</code></td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
</div>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue和LinkedList一样，内部基于<strong>链表</strong>来存放元素。LinkedBlockingQueue如果不指定容量，默认为<code>Integer.MAX_VALUE</code>，也就是<strong>无界队列</strong>。所以为了<strong>避免队列过大造成机器负载或者内存爆满</strong>的情况出现，我们在使用的时候建议手动传一个队列的大小。</p>
<p>LinkedBlockingQueue内部由<strong>单链表实现</strong>，只能从head取元素，从tail添加元素。添加元素和获取元素都有独立的锁，也就是说<strong>LinkedBlockingQueue是读写分离的</strong>，读写操作可以并行执行。LinkedBlockingQueue采用可重入锁(<strong>ReentrantLock)</strong>来保证在并发情况下的线程安全。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点类，用于存储数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 阻塞队列的大小，默认为Integer.MAX_VALUE */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前阻塞队列中的元素个数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列的头结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列的尾节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 获取并移除元素时使用的锁，如take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** notEmpty条件对象，当队列没有数据时用于挂起执行删除的线程 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 添加元素时使用的锁如 put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** notFull条件对象，当队列数据已满时用于挂起执行添加的线程 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>LinkedBlockingQueue队列中的数据都将被封装成Node节点，添加的链表队列中，其中head和last分别指向队列的头结点和尾结点</li>
<li>LinkedBlockingQueue内部分别使用了takeLock 和 putLock 对并发进行控制，也就是说，添加和删除操作并不是互斥操作，可以同时进行，这样也就可以大大提高吞吐量。</li>
<li>LinkedBlockingQueue对每一个lock锁都提供了一个Condition用来挂起和唤醒其他线程。</li>
</ol>
</blockquote>
<p>LinkedBlockingQueue常用操作</p>
<h5 id="取数据"><a href="#取数据" class="headerlink" title="取数据"></a>取数据</h5><p><strong>take()：首选。当队列为空时阻塞</strong></p>
<p>poll()：弹出队顶元素，队列为空时，返回空</p>
<p>peek()：和poll烈性，返回队队顶元素，但顶元素不弹出。队列为空时返回null</p>
<p>remove(Object o)：移除某个元素，队列为空时抛出异常。成功移除返回true</p>
<h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><p><strong>put()：首选。队满是阻塞</strong></p>
<p>offer()：队满时返回false</p>
<h5 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h5><p><strong>size()方法会遍历整个队列，时间复杂度为O(n),所以最好选用isEmtpy</strong></p>
<h5 id="put元素原理"><a href="#put元素原理" class="headerlink" title="put元素原理"></a>put元素原理</h5><p>基本过程：</p>
<p>1.判断元素是否为null，为null抛出异常</p>
<p>2.加锁(可中断锁<strong>ReentrantLock</strong>实现)</p>
<p>3.判断队列长度是否到达容量，如果到达一直等待</p>
<p>4.如果没有队满，enqueue()在队尾加入元素</p>
<p>5.队列长度加1，此时如果队列还没有满，调用signal唤醒其他堵塞队列</p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue是一个<strong>阻塞式的队列</strong>，继承自AbstractBlockingQueue,间接的实现了Queue接口和Collection接口。底层以数组的形式保存数据(实际上可看作一个循环数组)。常用的操作包括 add，offer，put，remove，poll，take，peek。</p>
<p>ArrayBlockingQueue 进队操作采用了加锁的方式保证并发安全。源代码里面有一个 <strong>while</strong>() 判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e); <span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="comment">// 一直阻塞，知道队列非满时，被唤醒</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e); <span class="comment">// 进队</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">        <span class="comment">// 阻塞，知道队列不满</span></span><br><span class="line">        <span class="comment">// 或者超时时间已过，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码分析，我们可以发现下面的规律：</p>
<ul>
<li>阻塞调用方式 put(e)或 offer(e, timeout, unit)</li>
<li>阻塞调用时，唤醒条件为超时或者队列非满（因此，要求在出队时，要发起一个唤醒操作）</li>
<li>进队成功之后，执行notEmpty.signal()唤起被阻塞的出队线程</li>
</ul>
<p>出队的源码类似。ArrayBlockingQueue 队列我们可以在创建线程池时进行使用。</p>
<blockquote>
<p>在进行某项业务存储操作时，建议采用<strong>offer</strong>进行添加，可及时获取boolean进行判断，如用put要考虑阻塞情况（队列的出队操作慢于进队操作），资源占用</p>
</blockquote>
<h3 id="SynchonousQueue"><a href="#SynchonousQueue" class="headerlink" title="SynchonousQueue"></a>SynchonousQueue</h3><p>SynchronousQueue 是一个很奇怪的队列，感觉都不能叫队列，因为内部没有数据的存储空间，队列不能peek，因为不存在元素，任何入队的线程都会阻塞，直到有线程来出队，也就是这个队列是一组操作，入队和出队要一起离开，出队也是一样，必须等入队，必须结伴而行；队列支持公平和非公平的模式(指的是队列匹配线程的顺序)，<strong>公平模式的数据结构是队列</strong>（FIFO），<strong>非公平模式使用的是栈</strong>（LIFO）。</p>
<h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114309.png" alt="image-20200831164258224"></p>
<h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 出队入队都是这一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// npu数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPUS = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时时间的自旋次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimedSpins = (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有超时的自旋次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxUntimedSpins = maxTimedSpins * <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<h5 id="TransferStack-非公平的实现，主要方法"><a href="#TransferStack-非公平的实现，主要方法" class="headerlink" title="TransferStack 非公平的实现，主要方法"></a>TransferStack 非公平的实现，主要方法</h5><p>TransferStack 继承 Transferer</p>
<p>注意：<strong>这几个状态很重要，因为继承了Transferer，所以出队和入队都是使用的transfer方法，状态是用来区分的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/** 0表示消费者 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST    = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 1表示数据的生产者 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA       = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** 2 表示数据正在匹配 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> SNode next;        <span class="comment">// 下一个节点</span></span><br><span class="line">        <span class="keyword">volatile</span> SNode match;       <span class="comment">// 匹配的节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// 等待的线程</span></span><br><span class="line">        Object item;                <span class="comment">// 数据</span></span><br><span class="line">        <span class="keyword">int</span> mode;                   <span class="comment">// 模式 0 ， 1 ， 2</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 头结点 */</span></span><br><span class="line"><span class="keyword">volatile</span> SNode head;</span><br></pre></td></tr></table></figure>
<h5 id="TransferQueue-公平实现，主要成员"><a href="#TransferQueue-公平实现，主要成员" class="headerlink" title="TransferQueue 公平实现，主要成员"></a>TransferQueue 公平实现，主要成员</h5><p>TransferQueue 继承 Transferer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">          <span class="keyword">volatile</span> QNode next;          <span class="comment">// next 节点</span></span><br><span class="line">          <span class="keyword">volatile</span> Object item;         <span class="comment">// 数据项</span></span><br><span class="line">          <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// 等待线程</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> isData;         <span class="comment">// 区分生产和消费</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 头结点 */</span></span><br><span class="line">      <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">      <span class="comment">/** 尾节点 */</span></span><br><span class="line">      <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SynchronousQueue 的实现还是很复杂的，我们可以发现虽然是个阻塞队列，可是没有使用锁；这个队列适合传递的场景，队列没有存储元素的队列，出队和入队必须结伴而行。</p>
<p>详细的源码解析可看  <a href="https://blog.51cto.com/14220760/2416470">https://blog.51cto.com/14220760/2416470</a></p>
</blockquote>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue是一个支持优先级的无<strong>界阻塞队列</strong>，直到系统资源耗尽。<strong>默认情况下元素采用自然顺序升序排列</strong>。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。但需要注意的是不能保证同优先级元素的顺序。PriorityBlockingQueue也是基于最小二叉堆实现，使用基于<strong>CAS实现的自旋锁</strong>来控制队列的<strong>动态扩容</strong>，保证了扩容操作不会阻塞take操作的执行<strong>PriorityBlockingQueue有四个构造方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的构造方法，该方法会调用this(DEFAULT_INITIAL_CAPACITY, null)，即默认的容量是11</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 根据initialCapacity来设置队列的初始容量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 根据initialCapacity来设置队列的初始容量，并根据comparator对象来对数据进行排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 根据集合来创建队列</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>源码解析可看<a href="https://zhuanlan.zhihu.com/p/63801130">https://zhuanlan.zhihu.com/p/63801130</a> </p>
</blockquote>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue是线程安全的，DelayQueue的特点就是插入Queue中的数据可以按照自定义的delay时间进行排序。只有delay时间小于0的元素才能够被取出</p>
<p>DelayQueue的底层存储是一个PriorityQueue，PriorityQueue是一个可排序的Queue，其中的元素必须实现Comparable方法。而getDelay方法则用来判断排序后的元素是否可以从Queue中取出</p>
<blockquote>
<p>源码解析可看 <a href="https://zhuanlan.zhihu.com/p/138368078">https://zhuanlan.zhihu.com/p/138368078</a></p>
</blockquote>
<h3 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从类的源码可以看到TransferQueue同时也是一个阻塞队列，它具备<strong>阻塞队列的所有特性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 如果可能，立即将元素转移给等待的消费者。 </span></span><br><span class="line">    <span class="comment">// 更确切地说，如果存在消费者已经等待接收它（在 take 或 timed poll（long，TimeUnit）poll）中，则立即传送指定的元素，否则返回 false。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素转移给消费者，如果需要的话等待。 </span></span><br><span class="line">    <span class="comment">// 更准确地说，如果存在一个消费者已经等待接收它（在 take 或timed poll（long，TimeUnit）poll）中，则立即传送指定的元素，否则等待直到元素由消费者接收。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面方法的基础上设置超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果至少有一位消费者在等待，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasWaitingConsumer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回等待消费者人数的估计值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWaitingConsumerCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>transfer</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xfer(e, <span class="keyword">true</span>, SYNC, <span class="number">0</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.interrupted(); <span class="comment">// failure possible only due to interrupt</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>tryTransfer</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> xfer(e, <span class="keyword">true</span>, NOW, <span class="number">0</span>) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-1-xfer-方法分析"><a href="#1-6-1-xfer-方法分析" class="headerlink" title="1.6.1 xfer 方法分析"></a>1.6.1 xfer 方法分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">xfer</span><span class="params">(E e, <span class="keyword">boolean</span> haveData, <span class="keyword">int</span> how, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="keyword">null</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node s = <span class="keyword">null</span>;                        <span class="comment">// the node to append, if needed</span></span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                            <span class="comment">// restart on append race</span></span><br><span class="line">        <span class="comment">// 从  head 开始</span></span><br><span class="line">        <span class="keyword">for</span> (Node h = head, p = h; p != <span class="keyword">null</span>;) &#123; <span class="comment">// find &amp; match first node</span></span><br><span class="line">            <span class="comment">// head 的类型。</span></span><br><span class="line">            <span class="keyword">boolean</span> isData = p.isData;</span><br><span class="line">            <span class="comment">// head 的数据</span></span><br><span class="line">            Object item = p.item;</span><br><span class="line">            <span class="comment">// item != null 有 2 种情况,一是 put 操作, 二是 take 的 itme 被修改了(匹配成功)</span></span><br><span class="line">            <span class="comment">// (itme != null) == isData 要么表示 p 是一个 put 操作, 要么表示 p 是一个还没匹配成功的 take 操作</span></span><br><span class="line">            <span class="keyword">if</span> (item != p &amp;&amp; (item != <span class="keyword">null</span>) == isData) &#123; </span><br><span class="line">                <span class="comment">// 如果当前操作和 head 操作相同，就没有匹配上，结束循环，进入下面的 if 块。</span></span><br><span class="line">                <span class="keyword">if</span> (isData == haveData)   <span class="comment">// can&#x27;t match</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果操作不同,匹配成功, 尝试替换 item 成功,</span></span><br><span class="line">                <span class="keyword">if</span> (p.casItem(item, e)) &#123; <span class="comment">// match</span></span><br><span class="line">                    <span class="comment">// 更新 head</span></span><br><span class="line">                    <span class="keyword">for</span> (Node q = p; q != h;) &#123;</span><br><span class="line">                        Node n = q.next;  <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">                        <span class="keyword">if</span> (head == h &amp;&amp; casHead(h, n == <span class="keyword">null</span> ? q : n)) &#123;</span><br><span class="line">                            h.forgetNext();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;                 <span class="comment">// advance and retry</span></span><br><span class="line">                        <span class="keyword">if</span> ((h = head)   == <span class="keyword">null</span> ||</span><br><span class="line">                            (q = h.next) == <span class="keyword">null</span> || !q.isMatched())</span><br><span class="line">                            <span class="keyword">break</span>;        <span class="comment">// unless slack &lt; 2</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 唤醒原 head 线程.</span></span><br><span class="line">                    LockSupport.unpark(p.waiter);</span><br><span class="line">                    <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找下一个</span></span><br><span class="line">            Node n = p.next;</span><br><span class="line">            p = (p != n) ? n : (h = head); <span class="comment">// Use head if p offlist</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果这个操作不是立刻就返回的类型    </span></span><br><span class="line">        <span class="keyword">if</span> (how != NOW) &#123;                 <span class="comment">// No matches available</span></span><br><span class="line">            <span class="comment">// 且是第一次进入这里</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 创建一个 node</span></span><br><span class="line">                s = <span class="keyword">new</span> Node(e, haveData);</span><br><span class="line">            <span class="comment">// 尝试将 node 追加对队列尾部，并返回他的上一个节点。</span></span><br><span class="line">            Node pred = tryAppend(s, haveData);</span><br><span class="line">            <span class="comment">// 如果返回的是 null, 表示不能追加到 tail 节点,因为 tail 节点的模式和当前模式相反.</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 重来</span></span><br><span class="line">                <span class="keyword">continue</span> retry;           <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">            <span class="comment">// 如果不是异步操作(即立刻返回结果)</span></span><br><span class="line">            <span class="keyword">if</span> (how != ASYNC)</span><br><span class="line">                <span class="comment">// 阻塞等待匹配值</span></span><br><span class="line">                <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e; <span class="comment">// not waiting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑如下:<br>                        找到 <code>head</code> 节点,如果 <code>head</code> 节点是匹配的操作,就直接赋值,如果不是,添加到队列中。</p>
<p>​                注意：队列中永远只有一种类型的操作,要么是 <code>put</code> 类型, 要么是 <code>take</code> 类型.</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114320.png" alt="img"></p>
<p>相比较 <code>SynchronousQueue</code> 多了一个可以存储的队列，相比较 <code>LinkedBlockingQueue</code> 多了直接传递元素，少了用锁来同步。</p>
<p>性能更高，用处更大</p>
<h4 id="1-6-2-总结"><a href="#1-6-2-总结" class="headerlink" title="1.6.2  总结"></a>1.6.2  总结</h4><p><code>LinkedTransferQueue</code>是 <code>SynchronousQueue</code> 和 <code>LinkedBlockingQueue</code> 的合体，性能比 <code>LinkedBlockingQueue</code> 更高（没有锁操作），比 <code>SynchronousQueue</code>能存储更多的元素。</p>
<p>当 <code>put</code> 时，如果有等待的线程，就直接将元素 “交给” 等待者， 否则直接进入队列。</p>
<p><code>put</code>和 <code>transfer</code> 方法的区别是，put 是立即返回的， transfer 是阻塞等待消费者拿到数据才返回。<code>transfer</code>方法和 <code>SynchronousQueue</code>的 put 方法类似。</p>
<h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><h3 id="Deque（双端队列，两边都可以进出）"><a href="#Deque（双端队列，两边都可以进出）" class="headerlink" title="Deque（双端队列，两边都可以进出）"></a>Deque（双端队列，两边都可以进出）</h3><p>deque容器为一个给定<strong>类型</strong>的元素进行<strong>线性处理</strong>，像向量一样，<strong>能够快速地随机访问任一个元素</strong>，并且能够<strong>高效地插入和删除容器的尾部元素</strong>。但它又与vector不同，<strong>deque支持高效插入和删除容器的头部元素</strong>，因此也叫做<strong>双端队列</strong>。deque类常用的函数如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line">deque():创建一个空deque</span><br><span class="line"></span><br><span class="line">deque(<span class="keyword">int</span> nSize):创建一个deque,元素个数为nSize</span><br><span class="line"></span><br><span class="line">deque(<span class="keyword">int</span> nSize,<span class="keyword">const</span> T&amp; t):创建一个deque,元素个数为nSize,且值均为t</span><br><span class="line"></span><br><span class="line">deque(<span class="keyword">const</span> deque &amp;):复制构造函数</span><br><span class="line"></span><br><span class="line"><span class="comment">//  增加函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span>:双端队列头部增加一个元素X</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span>:双端队列尾部增加一个元素x</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="keyword">const</span> T&amp; x)</span>:双端队列中某一元素前增加一个元素x</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator it,<span class="keyword">int</span> n,<span class="keyword">const</span> T&amp; x)</span>:双端队列中某一元素前增加n个相同的元素x</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator it,const_iterator first,const_iteratorlast)</span>:双端队列中某一元素前插入另一个相同类型向量的[forst,last)间的数据</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 删除函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Iterator <span class="title">erase</span><span class="params">(iterator it)</span>:删除双端队列中的某一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span>:删除双端队列中[first,last）中的元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span>:删除双端队列中最前一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span>:删除双端队列中最后一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>:删除所有的元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 遍历函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">reference <span class="title">at</span><span class="params">(<span class="keyword">int</span> pos)</span>:返回pos位置元素的引用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span>:返回首元素的引用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span>:返回尾元素的引用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span>:返回向量头指针，指向第一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span>:返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span>:反向迭代器，指向最后一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span>:反向迭代器，指向第一个元素的前一个元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bool <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span>:向量是否为空，若<span class="keyword">true</span>,则向量中无元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 大小函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Int <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span>:返回向量中元素的个数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span>:返回最大可允许的双端对了元素数量值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 其他函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(deque&amp;)</span>:交换两个同类型向量的数据</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">const</span> T&amp; x)</span>:向量中第n个元素的值设置为x</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>详细分析  <a href="https://blog.csdn.net/u011630575/article/details/79923132">https://blog.csdn.net/u011630575/article/details/79923132</a></p>
</blockquote>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue是一个基于<strong>链接节点的无界线程安全队列</strong>，它采用<strong>先进先出的规则对节点进行排序</strong>，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现</p>
<p>ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列</p>
<p> <strong>总结</strong></p>
<p>ConcurrentLinkedQueue 的非阻塞算法实现可概括为下面 5 点：</p>
<ul>
<li>使用 CAS 原子指令来处理对数据的并发访问，这是非阻塞算法得以实现的基础。</li>
<li>head/tail 并非总是指向队列的头 / 尾节点，也就是说允许队列处于不一致状态。 这个特性把入队 / 出队时，原本需要一起原子化执行的两个步骤分离开来，从而缩小了入队 / 出队时需要原子化更新值的范围到唯一变量。这是非阻塞算法得以实现的关键。</li>
<li>由于队列有时会处于不一致状态。为此，ConcurrentLinkedQueue 使用<a href="https://www.ibm.com/developerworks/cn/java/j-lo-concurrent/index.html">三个不变式</a>来维护非阻塞算法的正确性。</li>
<li>以批处理方式来更新 head/tail，从整体上减少入队 / 出队操作的开销。</li>
<li>为了有利于垃圾收集，队列使用特有的 head 更新机制；为了确保从已删除节点向后遍历，可到达所有的非删除节点，队列使用了特有的向后推进策略。</li>
</ul>
<blockquote>
<p>详细分析   <a href="https://blog.csdn.net/qq_38293564/article/details/80798310">https://blog.csdn.net/qq_38293564/article/details/80798310</a></p>
</blockquote>
<h3 id="priorityQueue"><a href="#priorityQueue" class="headerlink" title="priorityQueue"></a>priorityQueue</h3><p>PriorityQueue 一个基于优先级的<strong>无界优先级队列</strong>。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。该队列不允许使用 null 元素也不允许插入不可比较的对象(没有实现Comparable接口的对象)。<br> PriorityQueue 队列的头指排序规则最小那哥元素。如果多个元素都是最小值则随机选一个。<br> PriorityQueue 是一个无界队列，但是初始的容量(实际是一个Object[])，随着不断向优先级队列添加元素，其容量会自动扩容，无需指定容量增加策略的细节</p>
<ol>
<li>PriorityQueue是一种无界的，线程不安全的队列</li>
<li>PriorityQueue是一种通过数组实现的，并拥有优先级的队列</li>
<li>PriorityQueue存储的元素要求必须是可比较的对象， 如果不是就必须明确指定比较器</li>
</ol>
<blockquote>
<p>详细分析    <a href="https://www.jianshu.com/p/f1fd9b82cb72">https://www.jianshu.com/p/f1fd9b82cb72</a></p>
</blockquote>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map用于保存具有映射关系的数据，Map集合里保存着两组值，一组用于保存Map的ley，另一组保存着Map的value</p>
<p><strong>Map中的常用方法</strong>：</p>
<ul>
<li><code>void clear()</code>:删除该Map对象中所有键值对；</li>
<li><code>boolean containsKey(Object key)</code>:查询Map中是否包含指定的key值；</li>
<li><code>boolean containsValue(Object value)</code>:查询Map中是否包含一个或多个value;</li>
<li><code>Set entrySet()</code>:返回map中包含的键值对所组成的Set集合，每个集合都是Map.Entry对象。</li>
<li><code>Object get()</code>：返回指定key对应的value，如果不包含key则返回null；</li>
<li><code>boolean isEmpty()</code>:查询该Map是否为空；</li>
<li><code>Set keySet()</code>:返回Map中所有key组成的集合；</li>
<li><code>Collection values()</code>:返回该Map里所有value组成的Collection。</li>
<li><code>Object put(Object key,Object value)</code>:添加一个键值对，如果集合中的key重复，则覆盖原来的键值对；</li>
<li><code>void putAll(Map m)</code>:将Map中的键值对复制到本Map中；</li>
<li><code>Object remove(Object key)</code>:删除指定的key对应的键值对，并返回被删除键值对的value，如果不存在，则返回null；</li>
<li><code>boolean remove(Object key,Object value)</code>:删除指定键值对，删除成功返回true；</li>
<li><code>int size()</code>:返回该Map里的键值对个数</li>
</ul>
<p><strong>内部类Entry</strong></p>
<p>Map中包括一个内部类Entry,该类封装一个键值对，常用方法：</p>
<ul>
<li><code>Object getKey()</code>:返回该Entry里包含的key值；</li>
<li><code>Object getvalue()</code>:返回该Entry里包含的value值；</li>
<li><code>Object setValue(V value)</code>:设置该Entry里包含的value值，并设置新的value值。</li>
</ul>
<p><strong>Map的遍历四种方法</strong></p>
<p>在java中所有的map都实现了Map接口，因此所有的Map（如HashMap, TreeMap, LinkedHashMap, Hashtable等）都可以用以下的方式去遍历。</p>
<p>方法一：在for循环中使用entries实现Map的遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 最常见也是大多数情况下用的最多的，一般在键值对都需要使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Map &lt;String,String&gt;map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;熊大&quot;</span>, <span class="string">&quot;棕色&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;熊二&quot;</span>, <span class="string">&quot;黄色&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    String mapKey = entry.getKey();</span><br><span class="line">    String mapValue = entry.getValue();</span><br><span class="line">    System.out.println(mapKey+<span class="string">&quot;:&quot;</span>+mapValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：在for循环中遍历key或者values，一般适用于只需要map中的key或者value时使用，在性能上比使用entrySet较好；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map &lt;String,String&gt;map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;熊大&quot;</span>, <span class="string">&quot;棕色&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;熊二&quot;</span>, <span class="string">&quot;黄色&quot;</span>);</span><br><span class="line"><span class="comment">//key</span></span><br><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value</span></span><br><span class="line"><span class="keyword">for</span>(String value : map.values())&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三：通过Iterator遍历；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(entries.hasNext())&#123;</span><br><span class="line">    Entry&lt;String, String&gt; entry = entries.next();</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法四：通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    String value = map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HashTable和HashMap"><a href="#HashTable和HashMap" class="headerlink" title="HashTable和HashMap"></a>HashTable和HashMap</h2><h3 id="HashMap的工作原理"><a href="#HashMap的工作原理" class="headerlink" title="HashMap的工作原理"></a>HashMap的工作原理</h3><p>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。<strong>HashMap最多只允许一条记录的键为null</strong>，允许多条记录的值为null</p>
<p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p>
<h3 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h3><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p>
<ol>
<li>HashMap几乎可以等价于Hashtable，除了<strong>HashMap是非synchronized的，并可以接受null</strong>(HashMap可以接受为null的键值(key)和值(value)，而<strong>Hashtable不能接受null的key</strong>)。</li>
<li>HashMap是非synchronized，而Hashtable是synchronized，这意味着<strong>Hashtable是线程安全的</strong>，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，<strong>HashMap不是线程安全的</strong>。Java 5提供了<strong>ConcurrentHashMap</strong>，<strong>它是HashTable的替代</strong>，比HashTable的扩展性更好。</li>
<li>另一个区别是<strong>HashMap的迭代器(Iterator)是fail-fast迭代器</strong>，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li>
<li>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</li>
<li>HashMap不能保证随着时间的推移Map中的元素次序是不变的。</li>
</ol>
<h3 id="解决Hsah冲突的方法"><a href="#解决Hsah冲突的方法" class="headerlink" title="解决Hsah冲突的方法"></a>解决Hsah冲突的方法</h3><p>HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用<strong>开放地址法和链地址法</strong>等来解决问题，Java中HashMap采用了<strong>链地址法</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/21673805">https://zhuanlan.zhihu.com/p/21673805</a></p>
<p>HashMap就是使用<strong>哈希表来存储</strong>的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，<strong>Java中HashMap采用了链地址法</strong>。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上</p>
<p>例如程序执行下面代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">map.put(&quot;美团&quot;,&quot;小美&quot;);</span><br></pre></td></tr></table></figure>
<p>系统将调用”美团”这个key的hashCode()方法得到其<strong>hashCode</strong> 值（该方法适用于每个Java对象），然后再<strong>通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞</strong>。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>
<h3 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h3><p><a href="https://zhuanlan.zhihu.com/p/92481037">https://zhuanlan.zhihu.com/p/92481037</a></p>
<p>初始化大小为16，扩展因子为0.75（泊松分布）</p>
<h3 id="LinkHashMap"><a href="#LinkHashMap" class="headerlink" title="LinkHashMap"></a>LinkHashMap</h3><p>LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。（转list的时候可以按照顺序转化）</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><a href="https://zhuanlan.zhihu.com/p/35668936">https://zhuanlan.zhihu.com/p/35668936</a></p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p><a href="https://zhuanlan.zhihu.com/p/35598760">https://zhuanlan.zhihu.com/p/35598760</a></p>
<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p><a href="https://zhuanlan.zhihu.com/p/138021927">https://zhuanlan.zhihu.com/p/138021927</a></p>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p><a href="https://zhuanlan.zhihu.com/p/24887482">https://zhuanlan.zhihu.com/p/24887482</a></p>
<h2 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h2><p><a href="https://zhuanlan.zhihu.com/p/125093062">https://zhuanlan.zhihu.com/p/125093062</a></p>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程的强软弱虚四种引用</title>
    <url>/posts/d6b7922e/</url>
    <content><![CDATA[<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>spring的声明式事务会使用到，保证当前线程中数据库连接是同一个连接</p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>只要一对象有强引用，垃圾回收机制不会回收</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>在内存不够用时，会优先回收只有软引用的内存空间，主要是做缓存用</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>只要是触发垃圾回收机制进行回收，只具有弱引用的对象就会被回收</p>
<ul>
<li>tomcat中就是使用的弱应用</li>
<li>ThreadLocal也是使用弱应用</li>
</ul>
<p>weakhashmap</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>主要是管理堆外内存的，主要是给写jvm的使用</p>
<p>主要检测队列配合使用，虚引用API无法get到值，主要是通知对象已经被回收，去清理堆外的内存</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">引用类型</th>
<th style="text-align:left">被垃圾回收时间</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">强引用</td>
<td style="text-align:left">从来不会</td>
<td>对象的一般状态</td>
<td>JVM停止运行时终止</td>
</tr>
<tr>
<td style="text-align:left">软引用</td>
<td style="text-align:left">当内存不足时</td>
<td>对象缓存</td>
<td>内存不足时终止</td>
</tr>
<tr>
<td style="text-align:left">弱引用</td>
<td style="text-align:left">正常垃圾回收时</td>
<td>对象缓存</td>
<td>垃圾回收后终止</td>
</tr>
<tr>
<td style="text-align:left">虚引用</td>
<td style="text-align:left">正常垃圾回收时</td>
<td>跟踪对象的垃圾回收</td>
<td>垃圾回收后终止</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程的AQS</title>
    <url>/posts/1008f972/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>AbstractQueuedSynchronizer抽象队列同步器简称AQS，它是实现同步器的基础组件，juc下面Lock的实现以及一些并发工具类就是通过AQS来实现的，这里我们通过AQS的类图先看一下大概，下面我们总结一下AQS的实现原理。先看看AQS的类图。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114112.png" alt="img"></p>
<p> <strong>(1)</strong>AQS是一个通过内置的<strong>FIFO</strong>双向队列来完成线程的排队工作(内部通过结点head和tail记录队首和队尾元素，元素的结点类型为Node类型，后面我们会看到Node的具体构造)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*等待队列的队首结点(懒加载，这里体现为竞争失败的情况下，加入同步队列的线程执行到enq方法的时候会创</span></span><br><span class="line"><span class="comment">建一个Head结点)。该结点只能被setHead方法修改。并且结点的waitStatus不能为CANCELLED*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">/**等待队列的尾节点，也是懒加载的。（enq方法）。只在加入新的阻塞结点的情况下修改*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>
<p> <strong>(2)</strong>其中<strong>Node</strong>中的thread用来存放进入AQS队列中的线程引用，Node结点内部的SHARED表示标记线程是因为获取共享资源失败被阻塞添加到队列中的；Node中的EXCLUSIVE表示线程因为获取独占资源失败被阻塞添加到队列中的。waitStatus表示当前线程的等待状态</p>
<p> ①CANCELLED=1：表示线程因为中断或者等待超时，需要从等待队列中取消等待；</p>
<p> ②SIGNAL=-1：当前线程thread1占有锁，队列中的head(仅仅代表头结点，里面没有存放线程引用)的后继结点node1处于等待状态，如果已占有锁的线程thread1释放锁或被CANCEL之后就会通知这个结点node1去获取锁执行。</p>
<p> ③CONDITION=-2：表示结点在等待队列中(这里指的是等待在某个lock的condition上，关于Condition的原理下面会写到)，当持有锁的线程调用了Condition的signal()方法之后，结点会从该condition的等待队列转移到该lock的同步队列上，去竞争lock。(注意：这里的同步队列就是我们说的AQS维护的FIFO队列，等待队列则是每个condition关联的队列)</p>
<p> ④PROPAGTE=-3：表示下一次共享状态获取将会传递给后继结点获取这个共享同步状态。</p>
<p><strong>(3)</strong>AQS中维持了一个单一的volatile修饰的状态信息state(AQS通过Unsafe的相关方法，以原子性的方式由线程去获取这个state)。AQS提供了getState()、setState()、compareAndSetState()函数修改值(实际上调用的是unsafe的compareAndSwapInt方法)。下面是AQS中的部分成员变量以及更新state的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这就是我们刚刚说到的head结点，懒加载的（只有竞争失败需要构建同步队列的时候，才会创建这个head），如果头节点存在，它的waitStatus不能为CANCELLED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">//当前同步队列尾节点的引用，也是懒加载的，只有调用enq方法的时候会添加一个新的wait node</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="comment">//AQS核心：同步状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>(4)</strong>AQS的设计师基于<strong>模板方法</strong>模式的。使用时候需要继承同步器并重写指定的方法，并且通常将子类推荐为定义同步组件的静态内部类，子类重写这些方法之后，AQS工作时使用的是提供的模板方法，在这些模板方法中调用子类重写的方法。其中子类可以重写的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//独占式的获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;	<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();&#125;</span><br><span class="line"><span class="comment">//独占式的释放同步状态，等待获取同步状态的线程可以有机会获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;	<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();&#125;</span><br><span class="line"><span class="comment">//共享式的获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();&#125;</span><br><span class="line"><span class="comment">//尝试将状态设置为以共享模式释放同步状态。 该方法总是由执行释放的线程调用。 </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(); &#125;</span><br><span class="line"><span class="comment">//当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">isHeldExclusively</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;	<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(5)</strong>AQS的内部类<strong>ConditionObject</strong>是通过结合锁实现线程同步，ConditionObject可以直接访问AQS的变量(state、queue)，ConditionObject是个条件变量 ，每个ConditionObject对应一个队列用来存放线程调用condition条件变量的await方法之后被阻塞的线程。</p>
<h3 id="非公平锁的加锁流程"><a href="#非公平锁的加锁流程" class="headerlink" title="非公平锁的加锁流程"></a>非公平锁的加锁流程</h3><p>AQS会把所有的请求线程构成一个<strong>CLH队列</strong>，当一个线程执行完毕（lock.unlock()）时会激活自己的后继节点，但正在执行的线程并不在队列中，而那些等待执行的线程全部处于阻塞状态(park())。如下图所示。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114118.png" alt="img"></p>
<p> <strong>(1)</strong>假设这个时候在初始情况下，还没有多任务来请求竞争这个state，这时候如果第一个线程thread1调用了lock方法请求获得锁，首先会通过CAS的方式将state更新为1，表示自己thread1获得了锁，并将独占锁的线程持有者设置为thread1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">//setExclusiveOwnerThread是AbstractOwnableSynchronizer的方法，AQS继承了AbstractOwnableSynchronizer</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>(2)</strong>这个时候有另一个线程thread2来尝试或者锁，同样也调用lock方法，尝试通过CAS的方式将state更新为1，但是由于之前已经有线程持有了state，所以thread2这一步CAS失败（前面的thread1已经获取state并且没有释放），就会调用acquire(1)方法（该方法是AQS提供的模板方法，它会调用子类的tryAcquire方法）。非公平锁的实现中，AQS的模板方法acquire(1)就会调用NofairSync的tryAcquire方法，而tryAcquire方法又调用的Sync的nonfairTryAcquire方法，所以我们看看nonfairTryAcquire的流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NofairSync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//（1）获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//（2）获得当前同步状态state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//（3）如果state==0，表示没有线程获取</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//（3-1）那么就尝试以CAS的方式更新state的值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//（3-2）如果更新成功，就设置当前独占模式下同步状态的持有者为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="comment">//（3-3）获得成功之后，返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（4）这里是重入锁的逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">//（4-1）判断当前占有state的线程就是当前来再次获取state的线程之后，就计算重入后的state</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">//（4-2）这里是风险处理</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">//（4-3）通过setState无条件的设置state的值，（因为这里也只有一个线程操作state的值，即</span></span><br><span class="line">        <span class="comment">//已经获取到的线程，所以没有进行CAS操作）</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（5）没有获得state，也不是重入，就返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结来说就是：</p>
<p>1、获取当前将要去获取锁的线程thread2。</p>
<p>2、获取当前AQS的state的值。如果此时state的值是0，那么我们就通过CAS操作获取锁，然后设置AQS的线程占有者为thread2。很明显，在当前的这个执行情况下，state的值是1不是0，因为我们的thread1还没有释放锁。所以CAS失败，后面第3步的重入逻辑也不会进行</p>
<p>3、如果当前将要去获取锁的线程等于此时AQS的exclusiveOwnerThread的线程，则此时将state的值加1，这是重入锁的实现方式。</p>
<p>4、最终thread2执行到这里会返回false。</p>
<p> <strong>(3)</strong>上面的thread2加锁失败，返回false。那么根据开始我们讲到的AQS概述就应该将thread2构造为一个Node结点加入同步队列中。因为NofairSync的tryAcquire方法是由AQS的模板方法acquire()来调用的，那么我们看看该方法的源码以及执行流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(1)tryAcquire，这里thread2执行返回了false，那么就会执行addWaiter将当前线程构造为一个结点加入同步队列中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 那么我们就看一下addWaiter方法的执行流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1)将当前线程以及阻塞原因(是因为SHARED模式获取state失败还是EXCLUSIVE获取失败)构造为Node结点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//(2)这一步是快速将当前线程插入队列尾部</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//(2-1)将构造后的node结点的前驱结点设置为tail</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//(2-2)以CAS的方式设置当前的node结点为tail结点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">//(2-3)CAS设置成功，就将原来的tail的next结点设置为当前的node结点。这样这个双向队</span></span><br><span class="line">            <span class="comment">//列就更新完成了</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(3)执行到这里，说明要么当前队列为null，要么存在多个线程竞争失败都去将自己设置为tail结点，</span></span><br><span class="line">    <span class="comment">//那么就会有线程在上面（2-2）的CAS设置中失败，就会到这里调用enq方法</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 那么总结一下add Waiter方法</p>
<p> 1、将当前将要去获取锁的线程也就是thread2和独占模式封装为一个node对象。</p>
<p> 2、尝试快速的将当前线程构造的node结点添加作为tail结点(这里就是直接获取当前tail，然后将node的前驱结点设置为tail)，并且以CAS的方式将node设置为tail结点(CAS成功后将原tail的next设置为node，然后这个队列更新成功)。</p>
<p> 3、如果2设置失败，就进入enq方法。</p>
<p> 在刚刚的thread1和thread2的环境下，开始时候线程阻塞队列是空的(因为thread1获取了锁，thread2也是刚刚来请求锁，所以线程阻塞队列里面是空的)。很明显，这个时候队列的尾部tail节点也是null，那么将直接进入到enq方法。所以我们看看enq方法的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//(4)还是先获取当前队列的tail结点</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//(5)如果tail为null，表示当前同步队列为null，就必须初始化这个同步队列的head和tail（建</span></span><br><span class="line">        <span class="comment">//立一个哨兵结点）</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">//（5-1）初始情况下，多个线程竞争失败，在检查的时候都发现没有哨兵结点，所以需要CAS的</span></span><br><span class="line">            <span class="comment">//设置哨兵结点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//(6)tail不为null</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//(6-1)直接将当前结点的前驱结点设置为tail结点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">//(6-2)前驱结点设置完毕之后，还需要以CAS的方式将自己设置为tail结点，如果设置失败，</span></span><br><span class="line">            <span class="comment">//就会重新进入循环判断一遍</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> enq方法内部是一个自旋循环，第一次循环默认情况如下图所示</p>
<p> 1、首先代码块（4）处将t指向了tail，判断得到t==null，如图(1)所示；</p>
<p> 2、于是需要新建一个哨兵结点作为整个同步队列的头节点(代码块5-1处执行)</p>
<p> 3、完了之后如图(2)所示。这样第一次循环执行完毕。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114125.png" alt="img"></p>
<p> 第二次循环整体执行如下图所示。</p>
<p> 1、还是先获取当前tail结点然后将t指向tail结点。如下图的(3)</p>
<p> 2、然后判断得到当前t!=null，所以enq方法中进入代码块(6).</p>
<p> 3、在(6-1)代码块中将node的前驱结点设置为原来队列的tail结点，如下图的(4)所示。</p>
<p> 4、设置完前驱结点之后，代码块(6-2)会以CAS的方式将当前的node结点设置为tail结点,如果设置成功，就会是下图(5)所示。更新完tail结点之后，需要保证双向队列的，所以将原来的指向哨兵结点的t的next结点指向node结点，如下图(6)所示。最后返回</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114131.png" alt="img"></p>
<p> 总结来说，即使在多线程情况下，enq方法还是能够保证每个线程结点会被安全的添加到同步队列中，因为enq通过CAS方式将结点添加到同步队列之后才会返回，否则就会不断尝试添加(这样实际上就是在并发情况下，把向同步队列添加Node变得串行化了)</p>
<p> <strong>(4)</strong>在上面AQS的模板方法中，acquire()方法还有一步acquireQueued，这个方法的主要作用就是在同步队列中嗅探到自己的前驱结点，如果前驱结点是头节点的话就会尝试取获取同步状态，否则会先设置自己的waitStatus为-1，然后调用LockSupport的方法park自己。具体的实现如下面代码所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//在这样一个循环中尝试tryAcquire同步状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//(1)如果前驱结点是头节点，就尝试取获取同步状态，这里的tryAcquire方法相当于还是调</span></span><br><span class="line">            <span class="comment">//用NofairSync的tryAcquire方法，在上面已经说过</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//如果前驱结点是头节点并且tryAcquire返回true，那么就重新设置头节点为node</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">//将原来的头节点的next设置为null，交由GC去回收它</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//(2)如果不是头节点,或者虽然前驱结点是头节点但是尝试获取同步状态失败就会将node结点</span></span><br><span class="line">            <span class="comment">//的waitStatus设置为-1(SIGNAL),并且park自己，等待前驱结点的唤醒。至于唤醒的细节</span></span><br><span class="line">            <span class="comment">//下面会说到</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在上面的代码中我们可以看出，这个方法也是一个自旋循环，继续按照刚刚的thread1和thread2这个情况分析。在enq方法执行完之后，同步队列的情况大概如下所示。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114138.png" alt="img"></p>
<p>当前的node结点的前驱结点为head，所以会调用tryAcquire()方法去获得同步状态。但是由于state被thread1占有，所以tryAcquire失败。这里就是执行acquireQueued方法的代码块(2)了。代码块(2)中首先调用了shouldParkAfterFailedAcquire方法，该方法会将同步队列中node结点的前驱结点的waitStatus为CANCELLED的线程移除，并将当前调用该方法的线程所属结点自己和他的前驱结点的waitStatus设置为-1(SIGNAL)，然后返回。具体方法实现如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//（1）获取前驱结点的waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//（2）如果前驱结点的waitStatus为SINGNAL，就直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//前驱结点的状态为SIGNAL，那么该结点就能够安全的调用park方法阻塞自己了。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//（3）这里就是将所有的前驱结点状态为CANCELLED的都移除</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//CAS操作将这个前驱节点设置成SIGHNAL。</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 所以shouldParkAfterFailedAcquire方法执行完毕，现在的同步队列情况大概就是这样子，即哨兵结点的waitStatus值变为-1。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114141.png" alt="img"></p>
<p>上面的执行完毕返回到acquireQueued方法的时候，在acquireQueued方法中就会进行第二次循环了，但是还是获取state失败，而当再次进入shouldParkAfterFailedAcquire方法的时候，当前结点node的前驱结点head的waitStatus已经为-1(SIGNAL)了，就会返回true，然后acquireQueued方法中就会接着执行parkAndCheckInterrupt将自己park阻塞挂起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>(5)</strong>我们梳理一下整个方法调用的流程，假设现在又有一个thread3线程竞争这个state，那么这个方法调用的流程是什么样的呢。</p>
<p> ①首先肯定是调用<strong>ReentrantLock.lock()</strong>方法去尝试加锁;</p>
<p> ②因为是非公平锁，所以就会转到调用<strong>NoFairSync.lock()</strong>方法;</p>
<p> ③在NoFairSync.lock()方法中，会首先尝试设置state的值，因为已经被占有那么肯定就是失败的。这时候就会调用AQS的模板方法<strong>AQS.acquire(1)</strong>。</p>
<p> ④在AQS的模板方法acquire(1)中，实际首先会调用的是子类的tryAcquire()方法，而在非公平锁的实现中即<strong>Sync.nofairTryAcquire()</strong>方法。</p>
<p> ⑤显然tryAcquire()会返回false，所以acquire()继续执行，即调用<strong>AQS.addWaiter()</strong>，就会将当前线程构造称为一个Node结点,初始状况下waitStatus为0。</p>
<p> ⑥在addWaiter方法中，会首先尝试直接将构建的node结点以CAS的方式(存在多个线程尝试将自己设置为tail)设置为tail结点，如果设置成功就直接返回，失败的话就会进入一个自旋循环的过程。即调用<strong>enq()</strong>方法。最终保证自己成功被添加到同步队列中。</p>
<p> ⑦加入同步队列之后，就需要将自己挂起或者嗅探自己的前驱结点是否为头结点以便尝试获取同步状态。即调用<strong>acquireQueued()</strong>方法。</p>
<p> ⑧在这里thread3的前驱结点不是head结点，所以就直接调用<strong>shouldParkAfterFailedAcquire()</strong>方法，该方法首先会将刚刚的thread2线程结点中的waitStatue的值改变为-1(初始的时候是没有改变这个waitStatus的，每个新节点的添加就会改变前驱结点的waitStatus值)。</p>
<p> ⑨thread2所在结点的waitStatus改变后，shouldParkAfterFailedAcquire方法会返回false。所以之后还会在acquireQueued中进行第二次循环。并再次调用shouldParkAfterFailedAcquire方法，然后返回true。最终调用<strong>parkAndCheckInterrupt()</strong>将自己挂起。</p>
<p> 每个线程去竞争这个同步状态失败的话大概就会经历上面的这些过程。假设现在thread3经历上面这些过程之后也进入同步队列，那么整个同步队列大概就是下面这样了.</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114215.png" alt="image-20210223114214953"></p>
<p> 将上面的流程整理一下大概就是下面这个图</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114151.png" alt="img"></p>
<h3 id="非公平锁的释放流程"><a href="#非公平锁的释放流程" class="headerlink" title="非公平锁的释放流程"></a>非公平锁的释放流程</h3><p>上面说一ReentrantLock为例到了怎样去获得非公平锁，那么thread1获取锁，执行完释放锁的流程是怎样的呢。首先肯定是在finally中调用ReentrantLock.unlock()方法，所以我们就从这个方法开始看起。</p>
<p> <strong>(1)</strong>从下面的unlock方法中我们可以看出，实际上是调用AQS的release()方法，其中传递的参数为1，表示每一次调用unlock方法都是释放所获得的一次state。重入的情况下会多次调用unlock方法，也保证了lock和unlock是成对的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>); <span class="comment">//这里ReentrantLock的unlock方法调用了AQS的release方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里调用了子类的tryRelease方法，即ReentrantLock的内部类Sync的tryRelease方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>(2)</strong>上面看到release方法首先会调用ReentrantLock的内部类Sync的tryRelease方法。而通过下面代码的分析，大概知道tryRelease做了这些事情。</p>
<p> ①获取当前AQS的state，并减去1；</p>
<p> ②判断当前线程是否等于AQS的exclusiveOwnerThread，如果不是，就抛IllegalMonitorStateException异常，这就保证了加锁和释放锁必须是同一个线程；</p>
<p> ③如果(state-1)的结果不为0，说明锁被重入了，需要多次unlock，这也是lock和unlock成对的原因；</p>
<p> ④如果(state-1)等于0，我们就将AQS的ExclusiveOwnerThread设置为null；</p>
<p> ⑤如果上述操作成功了，也就是tryRelase方法返回了true；返回false表示需要多次unlock。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//（1）获取当前的state，然后减1，得到要更新的state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">//（2）判断当前调用的线程是不是持有锁的线程，如果不是抛出IllegalMonitorStateException</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//（3）判断更新后的state是不是0</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//（3-1）将当前锁持者设为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（4）设置当前state=c=getState()-releases</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="comment">//（5）只有state==0，才会返回true</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>(3)</strong>那么当tryRelease返回true之后，就会执行release方法中if语句块中的内容。从上面我们看到，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">//（1）获取当前队列的头节点head</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">//（2）判断头节点不为null，并且头结点的waitStatus不为0(CACCELLED)</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//（3-1）调用下面的方法唤醒同步队列head结点的后继结点中的线程</span></span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>(4)</strong>在获取锁的流程分析中，我们知道当前同步队列如下所示，所以判断得到head!=null并且head的waitStatus=-1。所以会执行unparkSuccessor方法，传递的参数为指向head的一个引用h.那下面我们就看看unparkSuccessor方法中处理了什么事情。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114221.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//（1）获得node的waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">//（2）判断waitStatus是否小于0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//（2-1）如果waitStatus小于0需要将其以CAS的方式设置为0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（2）获得s的后继结点，这里即head的后继结点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//（3）判断后继结点是否已经被移除，或者其waitStatus==CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//（3-1）如果s！=null，但是其waitStatus=CANCELLED需要将其设置为null</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//（3-2）会从尾部结点开始寻找，找到离head最近的不为null并且node.waitStatus的结点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（4）node.next!=null或者找到的一个离head最近的结点不为null</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//（4-1）唤醒这个结点中的线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 从上面的代码实现中可以总结，unparkSuccessor主要做了两件事情:</p>
<p> ①获取head节点的waitStatus，如果小于0，就通过CAS操作将head节点的waitStatus修改为0</p>
<p> ②寻找head节点的下一个节点，如果这个节点的waitStatus小于0，就唤醒这个节点，否则遍历下去，找到第一个waitStatus&lt;=0的节点，并唤醒。</p>
<p> <strong>(5)</strong>下面我们应该分析的是释放掉state之后，唤醒同步队列中的结点之后程序又是是怎样执行的。按照上面的同步队列示意图，那么下面会执行这些</p>
<p> <strong>①</strong>thread1(获取到锁的线程)调用unlock方法之后，最终执行到unparkSuccessor方法会唤醒thread2结点。<strong>所以thread2被unpark</strong>。</p>
<p> <strong>②</strong>再回想一下，当时thread2是在调用acquireQueued方法之后的parkAndCheckInterrupt里面被park阻塞挂起了，所以thread2被唤醒之后<strong>继续执行acquireQueued方法中的for循环</strong>（到这里可以往前回忆看一下acquireQueued方法中的for循环做了哪些事情）；</p>
<p> <strong>③</strong>for循环中做的第一件事情就是<strong>查看自己的前驱结点是不是头结点</strong>（按照上面的同步队列情况是满足的）；</p>
<p> <strong>④</strong>前驱结点是head结点，就会<strong>调用tryAcquire方法尝试获取state</strong>，因为thread1已经释放了state，即state=0，所以thread2调用tryAcquire方法时候，以<strong>CAS的方式去将state从0更新为1是成功的</strong>，所以这个时候<strong>thread2就获取到了锁</strong></p>
<p> <strong>⑤</strong>thread2获取state成功，就会从acquireQueued方法中退出。注意这时候的acquireQueued返回值为false，所以在AQS的模板方法的acquire中会直接从if条件退出，最后执行自己锁住的代码块中的程序。</p>
<h3 id="varhandle"><a href="#varhandle" class="headerlink" title="varhandle"></a>varhandle</h3><p>jdk1.9新增的，可以实现原子性操作</p>
<p>原文地址：<a href="https://www.cnblogs.com/fsmly/p/11274572.html#_labelTop">https://www.cnblogs.com/fsmly/p/11274572.html#_labelTop</a></p>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程常见的同步机制</title>
    <url>/posts/e8a097d2/</url>
    <content><![CDATA[<h3 id="ReentrantLock（可重入锁）"><a href="#ReentrantLock（可重入锁）" class="headerlink" title="ReentrantLock（可重入锁）"></a>ReentrantLock（可重入锁）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>​    ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，<strong>支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞</strong>。在java关键字synchronized隐式支持重入性，synchronized通过获取自增，释放自减的方式实现重入。与此同时，ReentrantLock还支持<strong>公平锁和非公平锁</strong>两种方式。那么，要想完完全全的弄懂ReentrantLock的话，主要也就是ReentrantLock同步语义的学习：<strong>1. 重入性的实现原理；2. 公平锁和非公平锁</strong></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>ReentrantLock常常对比着synchronized来分析</p>
<p>ReentrantLock常常对比着synchronized来分析，我们先对比着来看然后再一点一点分析。</p>
<p>（1）synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活。ReentrantLock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。</p>
<p>（2）synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。（<strong>ReentrantLock等lock方法一定要在finally进行unlock</strong>）</p>
<p>（3）synchronized不可响应中断，一个线程获取不到锁就一直等着；ReentrantLock可以相应中断。</p>
<p>（4 ）ReentrantLock和synchronized最主要的就<strong>区别是ReentrantLock还可以实现公平锁机制</strong>。也就是在锁上等待时间最长的线程将获得锁的使用权。通俗的理解就是谁排队时间最长谁先执行获取锁（不公平锁是只要锁被释放，其他线程一起争抢锁）</p>
<h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><p> 从ReentrantLock的构造中可以看到，ReentrantLock提供两种锁：公平锁和非公平锁，其内部实现了两种同步器<strong>NonfairSync</strong>、<strong>FairSync</strong>派生自<strong>AQS</strong>，主要才采用了模板方法模式，主要<strong>重写了AQS的tryAcquire、lock方法</strong></p>
<h4 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a>ReentrantLock的实现原理</h4><p>ReentrantLock在内部使用了内部类Sync来管理锁，所以真正的获取锁是由Sync的实现类控制的。Sync有两个实现，分别为NonfairSync（非公平锁）和FairSync（公平锁）。Sync通过继承AQS实现，在AQS中维护了一个<strong>private volatile int state</strong>来计数重入次数，避免了频繁的持有释放操作带来效率问题。所以说本质上常见的同步锁是使用CAS+volatile来实现的</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_ReentrantLock2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//非公平锁</span></span><br><span class="line">	Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock(); <span class="comment">//synchronized(this)</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">				System.out.println(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			System.out.println(<span class="string">&quot;m2 ...&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T02_ReentrantLock2 rl = <span class="keyword">new</span> T02_ReentrantLock2();</span><br><span class="line">		<span class="keyword">new</span> Thread(rl::m1).start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">new</span> Thread(rl::m2).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果</span><br><span class="line">==========================================</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">m2 ...     </span><br><span class="line">==========================================  </span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>发现该操作已经在执行中则不再执行</li>
<li>如果该操作已经在执行，则等待一个个执行（同步执行，与synchronized类似）</li>
<li>如果该操作已经在执行，则尝试等待一段时间，超时则放弃执行</li>
<li>如果发现该操作已经在执行，等待执行。这时可中断正在进行的操作立刻释放锁继续下一操作</li>
</ul>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul>
<li>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</li>
<li>CountDownLatch是一个同步容器，但是有人叫它发令枪，也有人叫它门闩。初始化设定线程的个数，调用countDownLatch.await()阻塞所有线程，直到countDownLatch.countDown()为0，那么将继续执行剩余的操作。</li>
</ul>
<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><ul>
<li><p>countDownLatch类中只提供了一个构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>类中有三个方法是最重要的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;   </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;  </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new CountDownLatch(2);这里设置成2是因为下面只创建了两个新线程，如果大于2，则会到countDownLatch.countDown()方法中不肯能为0.导致主线程一直阻塞</span></span><br><span class="line">       <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始执行&quot;</span>);</span><br><span class="line">        <span class="comment">//第一个子线程开始执行</span></span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// countDownLatch.countDown(); 这一句话要写在finally中，不然的话出现异常会导致无法减一，然后出现死锁的</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">//第二个子线程开始执行</span></span><br><span class="line">        ExecutorService executorService2 = Executors.newSingleThreadExecutor();</span><br><span class="line">        executorService2.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService2.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待两个线程执行完毕&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;两个子线程执行完毕，继续执行主线程&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">========================================</span><br><span class="line">主线程开始执行</span><br><span class="line">等待两个线程执行完毕</span><br><span class="line">子线程pool-<span class="number">2</span>-thread-<span class="number">1</span></span><br><span class="line">子线程pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">两个子线程执行完毕，继续执行主线程</span><br><span class="line">主线程执行完毕</span><br><span class="line">========================================</span><br><span class="line">使用CountDownLatch使主线程阻塞，直到线程<span class="number">1</span>，<span class="number">2</span>执行完主线程才会继续执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>游戏多线程加载图片，音乐等相关资源，需要全部加载完必须的资源才能正常的进入游戏</li>
</ul>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>从字面上的意思可以知道，这个类的中文意思是“循环栅栏”。大概的意思就是一个可循环利用的屏障。它的作用就是会让所有线程都等待完成后才会继续下一步行动</p>
<p>例子：当你和朋友一起吃饭，有人先到，有人后到，正常情况下就会等到一起才会点菜吃饭</p>
<h4 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h4><ul>
<li>CyclicBarrier提供了一个构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示需要等到几个线程一起才能执行下一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"> <span class="comment">//parties 是参与线程的个数， Runnable 参数，这个参数的意思是最后一个到达线程要做的任务</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction这个线程做什么处理)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>类中有两个重要方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程调用 await() 表示自己已经到达栅栏</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span></span><br><span class="line"><span class="function"><span class="comment">//BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span></span><br></pre></td></tr></table></figure>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_TestCyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        CyclicBarrier barrier = new CyclicBarrier(20);</span></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">20</span>, () -&gt; System.out.println(<span class="string">&quot;满20&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=====================================</span><br><span class="line">满<span class="number">20</span></span><br><span class="line">满<span class="number">20</span></span><br><span class="line">满<span class="number">20</span></span><br><span class="line">满<span class="number">20</span></span><br><span class="line">满<span class="number">20</span></span><br></pre></td></tr></table></figure>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>可以用于多线程计算数据，最后合并计算结果的场景。</li>
</ul>
<h3 id="phaser"><a href="#phaser" class="headerlink" title="phaser"></a>phaser</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>​    phaser与CountDownLatch非常相似，允许我们协调线程的执行。与CountDownLatch相比，它具有一些额外的功能。Phaser是在线程动态数需要继续执行之前等待的屏障。在CountDownLatch中，该数字无法动态配置，需要在创建实例时提供</p>
<h4 id="主要方法-2"><a href="#主要方法-2" class="headerlink" title="主要方法"></a>主要方法</h4><ul>
<li>构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造默认阶段数为0，创建一个没有初始注册方，没有父级且初始阶段号为0的新相位器。使用此相位器的任何线程都需要首先为其注册  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建指定数量为parties的相位器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, parties);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>核心方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//使线程阻塞，等待指定线程数目之后再继续运行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndAwaitAdvance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//注销到达的相关线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndDeregister</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//注册一个新线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doRegister(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_TestPhaser2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">static</span> MarriagePhaser phaser = <span class="keyword">new</span> MarriagePhaser();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        phaser.bulkRegister(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;p&quot;</span> + i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;新郎&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;新娘&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MarriagePhaser</span> <span class="keyword">extends</span> <span class="title">Phaser</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">//该方法会在phaser.arriveAndAwaitAdvance();进行相关判断，phase阶段一定是从0开始进行系列操作，只有当前Phaser中有指定数量的线程时才会进行运行</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (phase) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人到齐了！&quot;</span> + registeredParties);</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人吃完了！&quot;</span> + registeredParties);</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人离开了！&quot;</span> + registeredParties);</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;婚礼结束！新郎新娘抱抱！&quot;</span> + registeredParties);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">milliSleep</span><span class="params">(<span class="keyword">int</span> milli)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(milli);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            milliSleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s 到达现场！\n&quot;</span>, name);</span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            milliSleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s 吃完!\n&quot;</span>, name);</span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            milliSleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s 离开！\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(<span class="string">&quot;新郎&quot;</span>) || name.equals(<span class="string">&quot;新娘&quot;</span>)) &#123;</span><br><span class="line">                milliSleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s 洞房！\n&quot;</span>, name);</span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phaser.arriveAndDeregister();</span><br><span class="line">          <span class="comment">/*      phaser.register();</span></span><br><span class="line"><span class="comment">                System.out.println(phaser.getPhase());*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            arrive();</span><br><span class="line">            eat();</span><br><span class="line">            leave();</span><br><span class="line">            hug();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">======================================</span><br><span class="line">p3 到达现场！</span><br><span class="line">新郎 到达现场！</span><br><span class="line">p2 到达现场！</span><br><span class="line">p1 到达现场！</span><br><span class="line">p0 到达现场！</span><br><span class="line">p4 到达现场！</span><br><span class="line">新娘 到达现场！</span><br><span class="line">所有人到齐了！<span class="number">7</span></span><br><span class="line"></span><br><span class="line">新娘 吃完!</span><br><span class="line">p0 吃完!</span><br><span class="line">p1 吃完!</span><br><span class="line">p4 吃完!</span><br><span class="line">新郎 吃完!</span><br><span class="line">p2 吃完!</span><br><span class="line">p3 吃完!</span><br><span class="line">所有人吃完了！<span class="number">7</span></span><br><span class="line"></span><br><span class="line">p0 离开！</span><br><span class="line">p3 离开！</span><br><span class="line">新郎 离开！</span><br><span class="line">新娘 离开！</span><br><span class="line">p2 离开！</span><br><span class="line">p4 离开！</span><br><span class="line">p1 离开！</span><br><span class="line">所有人离开了！<span class="number">7</span></span><br><span class="line"></span><br><span class="line">新娘 洞房！</span><br><span class="line">新郎 洞房！</span><br><span class="line">婚礼结束！新郎新娘抱抱！<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>在需要对数据进行拦截的时候</li>
</ul>
<h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>ReadWriteLock是JDK5中提供的读写分离锁。读写分离锁可以有效地帮助减少锁竞争，以提高系统性能</p>
<p>读写锁允许多个线程同时读，使得B1,B2,B3之间真正并行。但是，考虑都数据完整性，<strong>写写操作和读写操作间依然时需要相互等待和持有锁的</strong></p>
<h4 id="主要方法-3"><a href="#主要方法-3" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读锁</span></span><br><span class="line"><span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//写锁</span></span><br><span class="line"><span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T10_TestReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">static</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;read over!&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Lock lock, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            value = v;</span><br><span class="line">            System.out.println(<span class="string">&quot;write over!&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟写操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable readR = ()-&gt; read(readLock);</span><br><span class="line">        Runnable writeR = ()-&gt;write(writeLock, <span class="keyword">new</span> Random().nextInt());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) <span class="keyword">new</span> Thread(readR).start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) <span class="keyword">new</span> Thread(writeR).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==========</span><br><span class="line">read over!</span><br><span class="line">read over!</span><br><span class="line">read over!</span><br><span class="line">read over!</span><br><span class="line">read over!</span><br><span class="line">write over!</span><br><span class="line">write over!</span><br></pre></td></tr></table></figure>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><p>semaphore 是一个计数信号量，必须由获取它的线程释放。</p>
<p>常用于限制可以访问某些资源的线程数量，例如通过 Semaphore 限流。</p>
<p>Semaphore 只有3个操作：</p>
<ol>
<li>初始化</li>
<li>增加</li>
<li>减少</li>
</ol>
<h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T11_TestSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Semaphore s = new Semaphore(2);</span></span><br><span class="line">        Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">2</span>, <span class="keyword">true</span>);<span class="comment">//设置是否是公平锁，默认是非公平锁</span></span><br><span class="line">        <span class="comment">//允许一个线程同时执行</span></span><br><span class="line">        <span class="comment">//Semaphore s = new Semaphore(1);</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//进行请求</span></span><br><span class="line">                s.acquire();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;T1 running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;T1 running...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                s.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;T2 running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;T2 running...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                s.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==========================</span><br><span class="line">T1 running...</span><br><span class="line">T2 running...</span><br><span class="line">T1 running...</span><br><span class="line">T2 running...</span><br></pre></td></tr></table></figure>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><h4 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h4><p>一个用于两个工作线程之间交换数据的封装工具类，简单说就是一个线程在完成一定的事务后想与另一个线程交换数据，则第一个先拿出数据的线程会一直等待第二个线程，直到第二个线程拿着数据到来时才能彼此交换对应数据</p>
<h4 id="主要方法-4"><a href="#主要方法-4" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exchanger()：无参构造方法。</span><br><span class="line"><span class="function">V <span class="title">exchange</span><span class="params">(V v)</span>：等待另一个线程到达此交换点（除非当前线程被中断），然后将给定的对象传送给该线程，并接收该线程的对象。</span></span><br><span class="line"><span class="function">V <span class="title">exchange</span><span class="params">(V v, <span class="keyword">long</span> timeout, TimeUnit unit)</span>：等待另一个线程到达此交换点（除非当前线程被中断或超出了指定的等待时间），然后将给定的对象传送给该线程，并接收该线程的对象。</span></span><br></pre></td></tr></table></figure>
<h4 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T12_TestExchanger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * exchanger只能是两个线程之间，多个线程需要进行线程同步</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String s = <span class="string">&quot;T1&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//在此会阻塞等待T2线程进行数据交换</span></span><br><span class="line">                s = exchanger.exchange(s);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + s);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String s = <span class="string">&quot;T2&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s = exchanger.exchange(s);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + s);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=============================</span><br><span class="line">t2 T1</span><br><span class="line">t1 T2</span><br></pre></td></tr></table></figure>
<h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><h4 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h4><p>LockSupport是一个线程工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞，也可以在任意位置唤醒。它的内部其实两类主要的方法：<strong>park</strong>（停车阻塞线程）和<strong>unpark</strong>（启动唤醒线程）。</p>
<h4 id="主要方法-5"><a href="#主要方法-5" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span></span>; <span class="comment">// 暂停当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span></span>; <span class="comment">// 暂停当前线程，不过有超时时间的限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span></span>; <span class="comment">// 暂停当前线程，直到某个时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span></span>; <span class="comment">// 无期限暂停当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(<span class="keyword">long</span> nanos)</span></span>; <span class="comment">// 暂停当前线程，不过有超时时间的限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(<span class="keyword">long</span> deadline)</span></span>; <span class="comment">// 暂停当前线程，直到某个时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span>; <span class="comment">// 恢复当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBlocker</span><span class="params">(Thread t)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T13_TestLockSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="comment">//                    当前线程停止，进入到阻塞状态</span></span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//LockSupport.park()之后，可以使用unpark方法使进程继续运行</span></span><br><span class="line">        <span class="comment">//不进行 LockSupport.unpark(t)则会导致线程一直都会阻塞</span></span><br><span class="line">       LockSupport.unpark(t);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="park和unpark的优点"><a href="#park和unpark的优点" class="headerlink" title="park和unpark的优点"></a>park和unpark的优点</h4><p><strong>一个线程它有可能在别的线程unPark之前，或者之后，或者同时调用了park，那么因为park的特性，它可以不用担心自己的park的时序问题，否则，如果park必须要在unpark之前，那么给编程带来很大的麻烦！！</strong></p>
<p>考虑一下，两个线程同步，要如何处理？</p>
<p>在Java5里是用wait/notify/notifyAll来同步的。wait/notify机制有个很蛋疼的地方是，比如<strong>线程B要用notify通知线程A，那么线程B要确保线程A已经在wait调用上等待了，否则线程A可能永远都在等待。</strong>另外，<strong>是调用notify，还是notifyAll？</strong></p>
<p>notify只会唤醒一个线程，如果错误地有两个线程在同一个对象上wait等待，那么又悲剧了。为了安全起见，貌似只能调用notifyAll了。</p>
<p><strong>park/unpark模型真正解耦了线程之间的同步，线程之间不再需要一个Object或者其它变量来存储状态，不再需要关心对方的状态。</strong></p>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程2</title>
    <url>/posts/56eb878c/</url>
    <content><![CDATA[<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><p>保证线程可见性</p>
<p><strong>使用volatile，将会强制所有线程都去堆内存中读取变量的值</strong></p>
<p>-MESI（CPU的缓存一致性协议）</p>
<p><strong>详细可看</strong></p>
<p><a href="https://www.cnblogs.com/z00377750/p/9180644.html">https://www.cnblogs.com/z00377750/p/9180644.html</a></p>
</li>
<li><p>禁止指令重排序（CPU级别的支持）</p>
<ul>
<li>cpu级别增加读写屏障</li>
</ul>
</li>
</ul>
<h4 id="图解说明："><a href="#图解说明：" class="headerlink" title="图解说明："></a>图解说明：</h4><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113818.png" alt="image-20200814153856725"></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道，不知B线程何时去修改真正的变量的值，此时使用volatile关键字，会让所有线程都会读到变量的修改值</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="volatie和synchronized区别"><a href="#volatie和synchronized区别" class="headerlink" title="volatie和synchronized区别"></a>volatie和synchronized区别</h4><ul>
<li><p>volatile本质是在告诉<strong>jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取</strong>； synchronized则是<strong>锁定当前变量</strong>，只有当<strong>前线程可以访问</strong>该变量，<strong>其他线程被阻塞住</strong>。</p>
</li>
<li><p>volatile<strong>仅能使用在变量级别</strong>；synchronized则可以使用<strong>在变量、方法、和类级别</strong>的</p>
</li>
<li><p>volatile<strong>仅能实现变量的修改可见性</strong>，<strong>不能保证原子性</strong>；而<strong>synchronized则可以保证变量的修改可见性和原子性</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile并不能保证多个线程共同修改变量时所带来的不一致问题，也就是说volatile不能替代synchronized</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞</p>
</li>
<li><p>volatile标记的变量<strong>不会被编译器优化，不会进行指令重排序</strong>；synchronized标记的变量可以<strong>被编译器优化</strong></p>
</li>
</ul>
<h4 id="volatile其他"><a href="#volatile其他" class="headerlink" title="volatile其他"></a>volatile其他</h4><ol>
<li><p><strong>volatile 引用类型（包括数组）只能保证引用本身的可见性</strong>，不能保证内部字段的可见性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_VolatileNotSync</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) count++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T04_VolatileNotSync t = <span class="keyword">new</span> T04_VolatileNotSync();</span><br><span class="line">		</span><br><span class="line">		List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">			threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">&quot;thread-&quot;</span>+i));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		threads.forEach((o)-&gt;o.start());</span><br><span class="line">		</span><br><span class="line">		threads.forEach((o)-&gt;&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				o.join();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		System.out.println(t.count);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line"> 输出结果的原因是：<span class="keyword">volatile</span>虽然能够保证count的可见性，但是不能够保障count++的原子性</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113823.png" alt="image-20200814160705502"></p>
</li>
</ol>
<h3 id="CAS（compare-and-swap）"><a href="#CAS（compare-and-swap）" class="headerlink" title="CAS（compare and swap）"></a>CAS（compare and swap）</h3><h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h4><p>CAS：Compare and Swap，即比较再交换。</p>
<p>jdk5增加了并发包java.util.concurrent.*,其下面的类使用CAS算法实现了区别于synchronouse同步锁的一种乐观锁。JDK 5之前Java语言是靠synchronized关键字保证同步的，这是一种独占锁，也是是悲观锁。</p>
<p><strong>CAS属于CPU原语级别的支持，正常程序不会被打断</strong></p>
<h4 id="CAS算法理解"><a href="#CAS算法理解" class="headerlink" title="CAS算法理解"></a>CAS算法理解</h4><p>CAS有3个操作数，<strong>内存值V，旧的预期值A，要修改的新值B</strong>。<strong>当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</strong></p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223114037.png" alt="image-20210223114037788"></p>
<h4 id="CAS实现原理"><a href="#CAS实现原理" class="headerlink" title="CAS实现原理"></a>CAS实现原理</h4><h4 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h4><ul>
<li>循环时间太长；</li>
<li>只能保证一个共享变量原子操作；</li>
<li>会出现ABA问题；</li>
</ul>
<h6 id="循环时间长开销很大："><a href="#循环时间长开销很大：" class="headerlink" title="循环时间长开销很大："></a>循环时间长开销很大：</h6><p>CAS 通常是配合无限循环一起使用的，我们可以看到 getAndAddInt 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p>
<h6 id="只能保证一个变量的原子操作："><a href="#只能保证一个变量的原子操作：" class="headerlink" title="只能保证一个变量的原子操作："></a>只能保证一个变量的原子操作：</h6><p>当对一个变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个变量操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：1）使用互斥锁来保证原子性；2）将多个变量封装成对象，通过 AtomicReference 来保证原子性。</p>
<h6 id="什么是ABA问题？ABA问题怎么解决？"><a href="#什么是ABA问题？ABA问题怎么解决？" class="headerlink" title="什么是ABA问题？ABA问题怎么解决？"></a>什么是ABA问题？ABA问题怎么解决？</h6><p>CAS 的使用流程通常如下：1）首先从地址 V 读取值 A；2）根据 A 计算目标值 B；3）通过 CAS 以原子的方式将地址 V 中的值从 A 修改为 B。</p>
<p>但是在第1步中读取的值是A，并且在第3步修改成功了，我们就能说它的值在第1步和第3步之间没有被其他线程改变过了吗？</p>
<p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的类“<strong>AtomicStampedReference</strong>”，它<strong>可以通过控制变量值的版本</strong>来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h3 id="AutomicXXX（CAS-volatile）"><a href="#AutomicXXX（CAS-volatile）" class="headerlink" title="AutomicXXX（CAS+ volatile）"></a>AutomicXXX（CAS+ volatile）</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul>
<li><p>Java从JDK1.5开始提供了java.util.concurrent.atomic包，方便程序员在多线程环境下，无锁的进行原子操作。原子变量的底层使用了处理器提供的原子指令，但是不同的CPU架构可能提供的原子指令不一样，也有可能需要某种形式的内部锁,所以该方法不能绝对保证线程不被阻塞。</p>
</li>
<li><p>原子类其内部实现不是简单的使用synchronized，而是一个更为高效的方式CAS (compare and swap) + volatile和native方法（同步的工作更多的交给了硬件），从而避免了synchronized的高开销，执行效率大为提升</p>
</li>
<li><p>虽然基于CAS的线程安全机制很好很高效，但要说的是，并非所有线程安全都可以用这样的方法来实现，这只适合一些粒度比较小，型如计数器这样的需求用起来才有效，否则也不会有锁的存在了</p>
</li>
<li><p>在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。Atomic包里的类基本都是使用Unsafe实现的包装类</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210416111937.jpg" alt="20210223113841"></p>
</li>
</ul>
<h4 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h4><p>主要以AtomicInteger为例</p>
<ul>
<li><strong>有参构造函数</strong>：从构造函数函数可以看出，数值存放在成员变量value中;</li>
<li>成员变量value声明为volatile类型，说明了多线程下的可见性，即任何一个线程的修改，在其它线程中都会被立刻看到</li>
<li><strong>compareAndSet</strong>方法（value的值通过内部this和valueOffset传递）</li>
<li>接收2个参数，一个是期望数据(expected)，一个是新数据(new)；如果atomic里面的数据和期望数据一致，则将新数据设定给atomic的数据，返回true，表明成功；否则就不设定，并返回false。</li>
</ul>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程1</title>
    <url>/posts/cfe2d636/</url>
    <content><![CDATA[<h2 id="线程的状态图"><a href="#线程的状态图" class="headerlink" title="线程的状态图"></a><strong>线程的状态图</strong></h2><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113754.jpg" alt="img"></p>
<ol>
<li><p><strong>新建(NEW)</strong>：新创建了一个线程对象。</p>
</li>
<li><p><strong>可运行(RUNNABLE)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p>
</li>
<li><p><strong>运行(RUNNING)</strong>：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p>
</li>
<li><p><strong>阻塞(BLOCKED)</strong>：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</span><br><span class="line">(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</span><br><span class="line">(三). 其他阻塞：运行(running)的线程执行Thread.sleep(<span class="keyword">long</span> ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>死亡(DEAD)</strong>：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run方法是thread里面的一个普通的方法，所以我们直接调用run方法，这个时候它是会运行在我们的主线程中的，因为这个时候我们的程序中只有主线程一个线程，所以如果有两个线程，都是直接调用的run方法，那么他们的执行顺序一定是顺序执行</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="启动线程方式"><a href="#启动线程方式" class="headerlink" title="启动线程方式"></a>启动线程方式</h2><ol>
<li>继承Thread</li>
<li>实现Runable接口</li>
<li>Executors.newCachedTread（线程池，本质还是上面两种方式其中一种去实现线程）</li>
<li>使用Lamda表达式（本质还是继承Thread）</li>
<li>实现Callable接口</li>
</ol>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="synchronized概述"><a href="#synchronized概述" class="headerlink" title="synchronized概述"></a>synchronized概述</h3><p><strong>synchronized是Java的内建锁，用来确保线程安全，是解决并发问题的一种重要手段</strong>,<strong>synchronized可以保证在多线程状态下，每次仅有一个线程访问共享资源</strong></p>
<p><strong>synchronized的作用主要有以下三个：</strong></p>
<ol>
<li>原子性：线程互斥的访问同步代码块，可以将小原子合成大原子</li>
<li>可见性：synchronized解锁之前，必须将工作内存中的数据同步到主内存，其它线程操作该变量时每次都可以看到被修改后的值。</li>
<li>有序性：一个线程的加锁，必须等到其它线程将锁释放；一个线程要释放锁，首先要加锁。</li>
</ol>
<h3 id="synchronized同步原理"><a href="#synchronized同步原理" class="headerlink" title="synchronized同步原理"></a>synchronized同步原理</h3><p>synchronized仅是Java中的一个关键字，在使用的过程中并没有看到显示的加锁和解锁过程。因此有必要通过<strong>javap</strong>命令，查看相应的字节码文件。</p>
<h5 id="synchronized修饰代码块"><a href="#synchronized修饰代码块" class="headerlink" title="synchronized修饰代码块"></a>synchronized修饰代码块</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁操作</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>javap查看相应的class文件：</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113800.png" alt="img"></p>
<p><strong>可以看出在执行同步代码块之前之后都有一个monitor字样，其中前面的是monitorenter，后面的是离开monitorexit，不难想象一个线程也执行同步代码块，首先要获取锁，而获取锁的过程就是monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行monitorexit指令。</strong></p>
<p><strong>为什么会有两个monitorexit呢？</strong></p>
<p><strong>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</strong></p>
<h5 id="synchronized修饰方法"><a href="#synchronized修饰方法" class="headerlink" title="synchronized修饰方法"></a>synchronized修饰方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>   <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello again&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113803.png" alt="在这里插入图片描述"></p>
<p><strong>仅有ACC_SYNCHRONIZED这么一个标志，该标记表明线程进入该方法时，需要monitorenter，退出该方法时需要monitorexit。</strong></p>
<h3 id="synchronized可重入的原理"><a href="#synchronized可重入的原理" class="headerlink" title="synchronized可重入的原理"></a>synchronized可重入的原理</h3><p><strong>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。</strong>底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>JDK1.6之前，synchronized是一个重量级锁，何谓重量级锁？就是多个线程竞争同一把锁，未获得锁的线程都会被阻塞，等到持有锁的线程将锁释放之后，这些线程又被唤醒。其中线程的阻塞和唤醒都与操作系统有关，是一个极其耗费CPU资源的过程。因此为了提高synchronized的性能特地在JDK1.6做了优化</p>
<h4 id="Java对象内存模型"><a href="#Java对象内存模型" class="headerlink" title="Java对象内存模型"></a><strong>Java对象内存模型</strong></h4><p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113805.png" alt="java中对象内存模型"></p>
<p>一个Java对象由，对象标记，类型指针，真实数据，内存对齐四部分组成。</p>
<ul>
<li>对象标记也称Mark Word字段，存储当前对象的一些运行时数据。</li>
<li>类型指针，JVM根据该指针确定该对象是哪个类的实例化对象。</li>
<li>真实数据自然是对象的属性值。</li>
<li>内存补齐，是当数据不是对齐数的整数倍的时候，进行调整，使得对象的整体大小是对齐数的整数倍方便寻址。典型的以空间换时间的思想。</li>
</ul>
<p><strong>其中对象标记和类型指针统称为Java对象头。</strong></p>
<h5 id="Mark-Word字段"><a href="#Mark-Word字段" class="headerlink" title="Mark Word字段"></a>Mark Word字段</h5><p>Mark Word用于存储对象自身运行时的数据，如hashcode，GC分代年龄，锁状态标志位，线程持有的锁，偏向线程ID，等等。</p>
<p><img src="https://gitee.com/CNRF/image/raw/master/img/20210223113808.jpg" alt="img"></p>
<h5 id="为社么Java的任意对象都可以作为锁？"><a href="#为社么Java的任意对象都可以作为锁？" class="headerlink" title="为社么Java的任意对象都可以作为锁？"></a>为社么Java的任意对象都可以作为锁？</h5><p><strong>在Java对象头中，存在一个monitor对象</strong>，每个对象自创建之后在对象头中就含有monitor对象，monitor是线程私有的，不同的对象monitor自然也是不同的，因此对象作为锁的本质是对象头中的monitor对象作为了锁。这便是为什么Java的任意对象都可以作为锁的原因。</p>
<blockquote>
<p>当对象在<strong>无锁的状态下进行了hashcode</strong>的计算（equals方法等）时，无法进入到偏向锁的状态（<strong>因为偏向锁会在前56位中记录线程id，但是如果有hashcode时无法记录id</strong>，如内存图所示）</p>
</blockquote>
<h4 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h4><h6 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h6><p>偏向锁针对的是锁不存在竞争，每次仅有一个线程来获取该锁，为了提高获取锁的效率，因此将该锁偏向该线程。提升性能。</p>
<p><strong>偏向锁的获取：</strong></p>
<blockquote>
<p>1.首先检测是否为可偏向状态（锁标识是否设置成1，锁标志位是否为01）.<br>        2.如果处于可偏向状态，测试Mark Word中的线程ID是否指向自己，如果是，不需要再次获取锁，直接执行同步代码。<br>        3.如果线程Id，不是自己的线程Id，通过CAS获取锁，获取成功表明当前偏向锁不存在竞争，获取失败，则说明当前偏向锁存在        锁竞争，偏向锁膨胀为轻量级锁。</p>
</blockquote>
<p><strong>偏向锁的撤销：</strong></p>
<p>偏向锁只有当出现竞争时，才会出现锁撤销。</p>
<blockquote>
<p>1。等待一个全局安全点，此时所有的线程都是暂停的，检查持有锁的线程状态，如果能找到说明当前线程还存活，说明还在执            行同步块中的代码，首相将该线程阻塞，然后进行锁升级，升级到轻量级锁，唤醒该线程继续执行代同步码。</p>
<p>2.如果持有偏向锁的线程未存活，将对象头中的线程置null，然后直接锁升级。</p>
</blockquote>
<h6 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a><strong>轻量级锁：</strong></h6><p>偏向锁考虑的是不存在多个线程竞争同一把锁，而轻量级锁考虑的是，多个线程不会在同一时刻来竞争同一把锁。</p>
<p><strong>轻量级锁的获取：</strong></p>
<blockquote>
<p>1.在线程的栈帧中创建用于存储锁记录得空间，</p>
<p>2.并将Mark Word复制到锁记录中，（这一步不论是否存在竞争都可以执行）。</p>
<p>3.尝试使用CAS将对象头中得Mark word字段变成指向锁记录得指针。</p>
<p>4 操作成功，不存在锁竞争，执行同步代码。</p>
<p>5操作失败，锁已经被其它线程抢占了，这时轻量级锁膨胀为重量级锁。</p>
</blockquote>
<p><strong>轻量级锁得释放：</strong></p>
<blockquote>
<p>反替换，使用CAS将栈帧中得锁录空间替换到对象头，成功没有锁竞争，锁得以释放，失败说明存在竞争，那块指向锁记录得指针有别的线程在用，因此锁膨胀升级为重量级锁。</p>
</blockquote>
<h6 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a><strong>重量级锁：</strong></h6><p>重量级锁描述同一时刻有多个线程竞争同一把锁。</p>
<blockquote>
<p>当多个线程共同竞争同一把锁时，竞争失败得锁会被阻塞，等到持有锁的线程将锁释放后再次唤醒阻塞的线程，因为线程的唤醒和阻塞是一个很耗费CPU资源的操作，因此此处采取自适应自旋来获取重量级锁来获取重量级锁。</p>
</blockquote>
<h6 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h6><p><strong>无锁 – &gt; 偏向锁 ——-&gt; 轻量级锁 —— &gt; 重量级锁</strong></p>
<h6 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a>其它优化</h6><p><strong>自旋锁：</strong></p>
<p>线程未获得锁后，不是一昧的阻塞，而是让线程不断尝试获取锁。</p>
<p>缺点：若线程占用锁时间过长，导致CPU资源白白浪费。</p>
<p>解决方式：当尝试次数(一般是10次，具体看JVM的实现)达到每个值得时候，线程挂起。</p>
<p><strong>自适应自旋锁：</strong></p>
<p>自旋得次数由上一次获取锁的自旋次数决定，次数稍微延长一点点。</p>
<p><strong>锁消除</strong></p>
<p>对于线程的私有变量，不存在并发问题，没有必要加锁，即使加锁编译后，也会去掉。</p>
<p><strong>锁粗化</strong></p>
<p>当一个循环中存在加锁操作时，可以将加锁操作提到循环外面执行，一次加锁代替多次加锁，提升性能。</p>
<p><strong>执行时间短（加锁代码），线程数少，偏向用自旋锁</strong><br><strong>执行时间长，线程数多，用系统重量级</strong></p>
]]></content>
      <categories>
        <category>多线程和高并发</category>
      </categories>
      <tags>
        <tag>多线程和高并发</tag>
      </tags>
  </entry>
</search>
